<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Energy Calculator - v8.7 (Eq Click Tab Switch)</title> <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        // Energy types (matched with hex codes below)
                        ki: '#FF9800', nen: '#2196F3', chakra: '#9C27B0', magic: '#26a69a', cursed: '#dc2626',
                        reiatsu: '#475569', haki: '#1f2937', alchemy: '#f59e0b', nature: '#84cc16',
                        'ki-dark': '#e65100', 'nen-dark': '#0d47a1', 'chakra-dark': '#4a148c', 'magic-dark': '#00796b', 'cursed-dark': '#b91c1c',
                        'reiatsu-dark': '#1e293b', 'haki-dark': '#000000', 'alchemy-dark': '#b45309', 'nature-dark': '#4d7c0f',
                        // UI feedback
                        'success-light': '#e8f5e9', 'success': '#4CAF50', 'success-dark': '#2e7d32',
                        'error-light': '#ffebee', 'error': '#f44336', 'error-dark': '#c62828',
                        // Stats panel
                        'stats-border': '#60a5fa', 'stats-header': '#1e3a8a',
                        // Kaioken active state
                        'kaioken-border': '#f87171', 'kaioken-header': '#b91c1c', 'kaioken-focus': '#ef4444',
                        // Focus Rings per type (ensure these are used correctly in JS map)
                        'magic-focus': '#26a69a', 'cursed-focus': '#dc2626', 'reiatsu-focus': '#475569',
                        'haki-focus': '#1f2937', 'alchemy-focus': '#f59e0b', 'nature-focus': '#84cc16',
                        'ki-focus': '#FF9800', 'nen-focus': '#2196F3', 'chakra-focus': '#9C27B0' // Added matching focus rings
                    },
                    animation: {
                        spin: 'spin 1s linear infinite', shake: 'shake 0.5s ease-in-out', fadeIn: 'fadeIn 0.3s ease-in', pulse: 'pulse 1.5s infinite',
                        'pulse-additive': 'pulse-additive 0.5s', 'pulse-multiplicative': 'pulse-multiplicative 0.5s', 'pulse-result': 'pulse-result 0.3s ease-in-out',
                        'flash-red': 'flash-red-bg 0.5s ease-out', 'flash-green': 'flash-green-bg 0.5s ease-out', 'kaioken-glow': 'kaioken-glow 1.5s infinite ease-in-out',
                        // Dynamic glow animations linked in JS map
                        'animate-pulse-glow-ki': 'pulse-glow-ki 1.5s infinite ease-in-out',
                        'animate-pulse-glow-nen': 'pulse-glow-nen 1.5s infinite ease-in-out',
                        'animate-pulse-glow-chakra': 'pulse-glow-chakra 1.5s infinite ease-in-out',
                        'animate-pulse-glow-magic': 'pulse-glow-magic 1.5s infinite ease-in-out',
                        'animate-pulse-glow-cursed': 'pulse-glow-cursed 1.5s infinite ease-in-out',
                        'animate-pulse-glow-reiatsu': 'pulse-glow-reiatsu 1.5s infinite ease-in-out',
                        'animate-pulse-glow-haki': 'pulse-glow-haki 1.5s infinite ease-in-out',
                        'animate-pulse-glow-alchemy': 'pulse-glow-alchemy 1.5s infinite ease-in-out',
                        'animate-pulse-glow-nature': 'pulse-glow-nature 1.5s infinite ease-in-out',
                        // Animation for source input pulse
                        'animate-pulse-source': 'pulse-source-input 0.8s ease-out',
                    },
                    keyframes: {
                        spin: { '0%': { transform: 'rotate(0deg)' }, '100%': { transform: 'rotate(360deg)' }, },
                        shake: { '0%, 100%': { transform: 'translateX(0)' }, '25%, 75%': { transform: 'translateX(-5px)' }, '50%': { transform: 'translateX(5px)' }, },
                        fadeIn: { from: { opacity: 0, transform: 'translateY(10px)' }, to: { opacity: 1, transform: 'translateY(0)' }, },
                        pulse: { '0%, 100%': { transform: 'scale(1)' }, '50%': { transform: 'scale(1.05)' }, },
                        'pulse-additive': { '0%, 100%': { color: '#558b2f' }, '50%': { color: '#8BC34A' }, },
                        'pulse-multiplicative': { '0%, 100%': { color: '#e65100' }, '50%': { color: '#FF9800' }, },
                        'pulse-result': { '0%, 100%': { transform: 'scale(1)' }, '50%': { transform: 'scale(1.05)' }, },
                        'flash-red-bg': { '50%': { backgroundColor: '#ffebee', borderColor: '#f44336' } },
                        'flash-green-bg': { '50%': { backgroundColor: '#e8f5e9', borderColor: '#4CAF50' } },
                        'kaioken-glow': { '0%, 100%': { boxShadow: `0 0 10px #f8717180` }, '50%': { boxShadow: `0 0 20px #f87171CC` } },
                        // Dynamic Glow Keyframes (ensure names match animation names)
                         'pulse-glow-ki': { '0%, 100%': { boxShadow: `0 0 8px #FF980066` }, '50%': { boxShadow: `0 0 16px #FF9800B3` } },
                         'pulse-glow-nen': { '0%, 100%': { boxShadow: `0 0 8px #2196F366` }, '50%': { boxShadow: `0 0 16px #2196F3B3` } },
                         'pulse-glow-chakra': { '0%, 100%': { boxShadow: `0 0 8px #9C27B066` }, '50%': { boxShadow: `0 0 16px #9C27B0B3` } },
                         'pulse-glow-magic': { '0%, 100%': { boxShadow: `0 0 8px #26a69a66` }, '50%': { boxShadow: `0 0 16px #26a69aB3` } },
                         'pulse-glow-cursed': { '0%, 100%': { boxShadow: `0 0 8px #dc262666` }, '50%': { boxShadow: `0 0 16px #dc2626B3` } },
                         'pulse-glow-reiatsu': { '0%, 100%': { boxShadow: `0 0 8px #47556966` }, '50%': { boxShadow: `0 0 16px #475569B3` } },
                         'pulse-glow-haki': { '0%, 100%': { boxShadow: `0 0 8px #1f293766` }, '50%': { boxShadow: `0 0 16px #1f2937B3` } },
                         'pulse-glow-alchemy': { '0%, 100%': { boxShadow: `0 0 8px #f59e0b66` }, '50%': { boxShadow: `0 0 16px #f59e0bB3` } },
                         'pulse-glow-nature': { '0%, 100%': { boxShadow: `0 0 8px #84cc1666` }, '50%': { boxShadow: `0 0 16px #84cc16B3` } },
                         // Keyframe for source input pulse
                         'pulse-source-input': { '0%, 100%': { boxShadow: 'none' }, '50%': { boxShadow: '0 0 12px theme("colors.blue.400")' } }, // Use theme() here
                    }
                }
            }
        }
    </script>
    <link rel="preconnect" href="https://rsms.me/">
    <link rel="stylesheet" href="https://rsms.me/inter/inter.css">
    <style>
        /* Base Styles */
        body { font-family: 'Inter', sans-serif; background-color: #f9f9f9; color: #333; }
        .energy-pool { @apply p-5 mb-5 rounded-lg shadow-sm border-l-4; transition: box-shadow 0.3s ease-in-out, opacity 0.3s ease-in-out; }

        /* Dynamic Pool Styles */
        .energy-pool-ki { border-left-color: #FF9800; } .energy-pool-ki h3 { color: #e65100; }
        .energy-pool-nen { border-left-color: #2196F3; } .energy-pool-nen h3 { color: #0d47a1; }
        .energy-pool-chakra { border-left-color: #9C27B0; } .energy-pool-chakra h3 { color: #4a148c; }
        .energy-pool-magic { border-left-color: #26a69a; } .energy-pool-magic h3 { color: #00796b; }
        .energy-pool-cursed { border-left-color: #dc2626; } .energy-pool-cursed h3 { color: #b91c1c; }
        .energy-pool-reiatsu { border-left-color: #475569; } .energy-pool-reiatsu h3 { color: #1e293b; }
        .energy-pool-haki { border-left-color: #1f2937; } .energy-pool-haki h3 { color: #000000; }
        .energy-pool-alchemy { border-left-color: #f59e0b; } .energy-pool-alchemy h3 { color: #b45309; }
        .energy-pool-nature { border-left-color: #84cc16; } .energy-pool-nature h3 { color: #4d7c0f; }

        /* Base Slider Track */
        .energy-slider { @apply w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer; }
        /* Base Slider Thumb */
        .energy-slider::-webkit-slider-thumb { appearance: none; width: 20px; height: 20px; border-radius: 50%; cursor: pointer; box-shadow: 0 1px 3px rgba(0,0,0,0.2); transition: background 0.3s; border: none; }
        .energy-slider::-moz-range-thumb { width: 20px; height: 20px; border-radius: 50%; cursor: pointer; box-shadow: 0 1px 3px rgba(0,0,0,0.2); transition: background 0.3s; border: none; }

        /* Slider Thumb Colors (Using direct Hex Codes) */
        #ki-energy-slider::-webkit-slider-thumb { background: #FF9800; } #ki-energy-slider::-moz-range-thumb { background: #FF9800; }
        #nen-energy-slider::-webkit-slider-thumb { background: #2196F3; } #nen-energy-slider::-moz-range-thumb { background: #2196F3; }
        #chakra-energy-slider::-webkit-slider-thumb { background: #9C27B0; } #chakra-energy-slider::-moz-range-thumb { background: #9C27B0; }
        #magic-energy-slider::-webkit-slider-thumb { background: #26a69a; } #magic-energy-slider::-moz-range-thumb { background: #26a69a; }
        #cursed-energy-slider::-webkit-slider-thumb { background: #dc2626; } #cursed-energy-slider::-moz-range-thumb { background: #dc2626; }
        #reiatsu-energy-slider::-webkit-slider-thumb { background: #475569; } #reiatsu-energy-slider::-moz-range-thumb { background: #475569; }
        #haki-energy-slider::-webkit-slider-thumb { background: #1f2937; } #haki-energy-slider::-moz-range-thumb { background: #1f2937; }
        #alchemy-energy-slider::-webkit-slider-thumb { background: #f59e0b; } #alchemy-energy-slider::-moz-range-thumb { background: #f59e0b; }
        #nature-energy-slider::-webkit-slider-thumb { background: #84cc16; } #nature-energy-slider::-moz-range-thumb { background: #84cc16; }

        /* Slider Thumb Hover Colors (Using direct Hex Codes) */
        #ki-energy-slider:hover::-webkit-slider-thumb { background: #e65100; } #ki-energy-slider:hover::-moz-range-thumb { background: #e65100; }
        #nen-energy-slider:hover::-webkit-slider-thumb { background: #0d47a1; } #nen-energy-slider:hover::-moz-range-thumb { background: #0d47a1; }
        #chakra-energy-slider:hover::-webkit-slider-thumb { background: #4a148c; } #chakra-energy-slider:hover::-moz-range-thumb { background: #4a148c; }
        #magic-energy-slider:hover::-webkit-slider-thumb { background: #00796b; } #magic-energy-slider:hover::-moz-range-thumb { background: #00796b; }
        #cursed-energy-slider:hover::-webkit-slider-thumb { background: #b91c1c; } #cursed-energy-slider:hover::-moz-range-thumb { background: #b91c1c; }
        #reiatsu-energy-slider:hover::-webkit-slider-thumb { background: #1e293b; } #reiatsu-energy-slider:hover::-moz-range-thumb { background: #1e293b; }
        #haki-energy-slider:hover::-webkit-slider-thumb { background: #000000; } #haki-energy-slider:hover::-moz-range-thumb { background: #000000; }
        #alchemy-energy-slider:hover::-webkit-slider-thumb { background: #b45309; } #alchemy-energy-slider:hover::-moz-range-thumb { background: #b45309; }
        #nature-energy-slider:hover::-webkit-slider-thumb { background: #4d7c0f; } #nature-energy-slider:hover::-moz-range-thumb { background: #4d7c0f; }

        /* Other Styles */
        .modifier-type-option.additive { border-color: theme('colors.success'); color: theme('colors.success-dark'); }
        .modifier-type-option.additive.active { background-color: theme('colors.success-light'); box-shadow: 0 1px 5px rgba(76, 175, 80, 0.3); animation: pulse-additive 0.5s; color: theme('colors.success'); }
        .modifier-type-option.multiplicative { border-color: theme('colors.ki'); color: theme('colors.ki-dark'); }
        .modifier-type-option.multiplicative.active { background-color: theme('colors.ki / 0.1'); box-shadow: 0 1px 5px rgba(255, 152, 0, 0.3); animation: pulse-multiplicative 0.5s; color: theme('colors.ki'); }
        .animate-pulse-result { animation: pulse-result 0.3s ease-in-out; }
        .animate-flash-red { animation: flash-red-bg 0.5s ease-out; }
        .animate-flash-green { animation: flash-green-bg 0.5s ease-out; }
        .animate-kaioken-glow { animation: kaioken-glow 1.5s infinite ease-in-out; }
        /* Static Glow classes */
        .static-glow-ki { box-shadow: 0 0 10px #FF980080; } .static-glow-nen { box-shadow: 0 0 10px #2196F380; } .static-glow-chakra { box-shadow: 0 0 10px #9C27B080; } .static-glow-magic { box-shadow: 0 0 10px #26a69a80; } .static-glow-cursed { box-shadow: 0 0 10px #dc262680; } .static-glow-reiatsu { box-shadow: 0 0 10px #47556980; } .static-glow-haki { box-shadow: 0 0 10px #1f293780; } .static-glow-alchemy { box-shadow: 0 0 10px #f59e0b80; } .static-glow-nature { box-shadow: 0 0 10px #84cc1680; }

        .sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 0, 0); white-space: nowrap; border-width: 0; }
        .stats-panel { border-left-width: 4px; transition: border-color 0.3s ease-in-out, box-shadow 1.5s ease-in-out; }
        .stats-panel-header { transition: color 0.3s ease-in-out; }
        .lbl { @apply block mb-1 font-medium text-sm text-gray-600; }
        .inpt { @apply w-full p-2 border border-gray-300 rounded-md focus:ring-2 focus:border-transparent text-sm transition-colors duration-300; }
        /* .inpt-ro class is removed */
        .regen-btn { @apply px-3 py-2 text-white rounded-md focus:outline-none focus:ring-2 focus:ring-offset-2 transition-all duration-150 ease-in-out text-sm font-semibold shadow-sm active:scale-95; }
        .save-load-btn { @apply px-3 py-1 text-sm text-white rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-offset-1 transition-all duration-150 ease-in-out active:scale-95; }

        /* Style for the new span elements replacing readonly inputs */
        .readonly-display {
            @apply inline-block font-medium text-gray-800 min-h-[42px] px-2 py-2 w-full bg-gray-50 rounded-md border border-gray-200; /* Mimic input height and padding, subtle background */
            line-height: 1.5; /* Adjust line height for vertical centering if needed */
            word-break: break-all; /* Allow long numbers without spaces to break */
        }

        /* Equation Number Styles */
        .equation-number {
            @apply font-semibold text-blue-600 hover:text-blue-800 underline transition-colors duration-150;
            cursor: pointer; /* Explicitly set cursor */
        }
        .equation-number:hover {
             /* Use rgba for text-shadow glow */
             text-shadow: 0 0 8px rgba(147, 197, 253, 0.8); /* blue-300 with alpha */
        }
        .equation-operator {
            @apply text-gray-600 mx-1;
        }
        .equation-group { /* Optional: for parentheses */
             @apply mx-0.5;
        }

        /* Animation class for pulsing the source input */
        .animate-pulse-source {
            animation: pulse-source-input 0.8s ease-out;
        }

    </style>
</head>
<body class="p-4 md:p-6">

    <div class="mb-4 flex gap-2">
        <button id="save-state-btn" class="save-load-btn bg-blue-500 hover:bg-blue-600 focus:ring-blue-400">Save State</button>
        <button id="load-state-btn" class="save-load-btn bg-gray-500 hover:bg-gray-600 focus:ring-gray-400">Load State</button>
        <button id="clear-state-btn" class="save-load-btn bg-red-500 hover:bg-red-600 focus:ring-red-400">Clear Saved</button>
    </div>
    <h1 class="text-3xl font-bold mb-6 text-center text-gray-800">Energy Calculator</h1>

    <div class="flex flex-col md:flex-row gap-6 max-w-7xl mx-auto">

        <div class="flex-grow md:w-3/4">

            <div id="message-area" class="mb-4 p-3 rounded-md text-sm hidden" role="alert"></div>

            <div class="energy-pool bg-white p-5 mb-5 rounded-lg shadow-sm border-l-4 border-gray-400">
                 <h3 class="text-xl font-semibold mb-4 flex items-center"> Damage Modifiers <span class="flex-grow h-px bg-gray-200 ml-3"></span> </h3>
                 <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                     <div><label for="base-damage" class="lbl">Base Damage:</label><input type="text" id="base-damage" placeholder="e.g., 100" aria-required="true" class="inpt focus:ring-success"></div>
                     <div><label for="attack-compression-points" class="lbl">Attack Compression Points:</label><input type="text" id="attack-compression-points" placeholder="e.g., 10" value="0" class="inpt focus:ring-red-500"></div>
                     <div><label for="base-multiplier" class="lbl">Base Multiplier:</label><input type="text" id="base-multiplier" placeholder="e.g., 1.5" value="1" class="inpt focus:ring-success"></div>
                     <div><label for="form-multiplier" class="lbl">Form Multiplier:</label><input type="text" id="form-multiplier" placeholder="e.g., 2" value="1" class="inpt focus:ring-success"></div>
                 </div>
                 <div id="dynamic-modifiers-container" class="mb-4"><h4 class="text-md font-semibold mb-2 text-gray-700">Additional Factors:</h4></div>
                 <button id="add-dynamic-box" aria-label="Add modifier factor" class="px-4 py-2 bg-chakra text-white rounded-md hover:bg-chakra-dark focus:outline-none focus:ring-2 focus:ring-chakra focus:ring-offset-2 transition-all duration-150 ease-in-out text-sm font-semibold shadow-sm active:scale-95"> Add Factor </button>
            </div>

            <div class="form-group mb-5">
                 <label for="energy-type" class="lbl">Energy Type:</label>
                 <select id="energy-type" aria-label="Select energy type" class="w-full p-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-success focus:border-transparent text-sm bg-white">
                     <option value="ki">Ki Energy</option> <option value="nen">Nen Energy</option> <option value="chakra">Chakra Energy</option> <option value="magic">Magic Energy</option> <option value="cursed">Cursed Energy</option> <option value="reiatsu">Reiatsu</option> <option value="haki">Haki</option> <option value="alchemy">Alchemy</option> <option value="nature">Nature Energy</option>
                 </select>
            </div>

            <div id="energy-pools-container" class="mb-5">
                </div>

            <div id="all-sliders-container" class="bg-white p-5 mb-5 rounded-lg shadow-sm">
                <h3 class="text-xl font-semibold mb-4 text-gray-700 border-b pb-2">Energy Usage Sliders</h3>
                <div id="sliders-grid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-x-6 gap-y-4">
                    </div>
            </div>

            <button id="calculate-btn" aria-label="Calculate final damage value" class="w-full px-4 py-3 bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 transition-all duration-150 ease-in-out text-lg font-semibold shadow-md mb-5 active:scale-95"> Calculate Damage </button>
            <div id="loading" class="loading text-center p-5 hidden">
                <div class="loading-spinner inline-block w-8 h-8 border-4 border-t-success border-gray-200 rounded-full animate-spin" aria-hidden="true"></div>
                <div class="loading-text mt-2 text-gray-600">Calculating...</div><span class="sr-only">Loading, please wait</span>
             </div>
            <div id="result" class="result bg-success-light p-5 rounded-lg border-l-4 border-success shadow-sm hidden animate-fadeIn" aria-live="polite">
                <div class="result-title text-lg font-semibold mb-2 text-success-dark">Calculated Damage:</div>
                <div id="result-value" class="result-value text-3xl font-bold mb-3 break-words">0</div>
                <div id="result-details" class="result-details text-sm text-gray-700 mt-3 border-t border-success/30 pt-3">
                    <p><strong>Total Energy Used:</strong> <span id="result-total-energy-used">0</span></p>
                    <p><strong>Total Extra Damage from Energy:</strong> <span id="result-total-extra-damage">0.00</span></p>

                    <div class="mt-3 pt-3 border-t border-success/20">
                        <p class="font-semibold mb-1">Calculation:</p>
                        <div id="equation-display" class="text-sm bg-gray-50 p-2 rounded border border-gray-200 break-words leading-relaxed">
                            Equation not yet calculated.
                        </div>
                    </div>

                    <hr class="my-2 border-success/20"> <p><strong>Scientific Notation:</strong> <span id="result-scientific">0</span></p>
                    <p><strong>In Words:</strong> <span id="result-words">Zero</span></p>
                </div>
             </div>

        </div><div id="stats-panel" class="stats-panel md:w-1/4 lg:w-1/5 p-5 bg-white rounded-lg shadow-sm self-start sticky top-6 border-stats-border">
             <h3 id="stats-panel-header" class="stats-panel-header text-xl font-semibold mb-4 flex items-center text-stats-header"> Stats <span class="flex-grow h-px bg-gray-200 ml-3"></span> </h3>
             <div class="space-y-3">
                 <p class="text-sm text-gray-600">Selected Current Energy: <span id="stat-current-energy" class="font-medium text-gray-800 break-words">0</span></p>
                 <hr class="border-gray-200">
                 <p class="text-sm text-gray-600">Total Damage Dealt: <span id="stat-total-damage" class="font-medium text-gray-800 break-words">0</span></p>
                 <p class="text-sm text-gray-600">Total Energy Spent: <span id="stat-total-energy-spent" class="font-medium text-gray-800 break-words">0</span></p>
                 <p class="text-sm text-gray-600">Highest Damage: <span id="stat-highest-damage" class="font-medium text-gray-800 break-words">0</span></p>
                 <p class="text-sm text-gray-600">Number of Attacks: <span id="stat-attack-count" class="font-medium text-gray-800 break-words">0</span></p>

                 <div id="kaioken-section" class="hidden pt-3 border-t border-gray-200">
                     <div class="flex items-center gap-2 mb-3">
                         <input type="checkbox" id="kaioken-checkbox" class="rounded border-gray-300 text-red-600 shadow-sm focus:ring-kaioken-focus">
                         <label for="kaioken-checkbox" class="text-sm font-medium text-kaioken-header">Kaioken?</label>
                     </div>
                     <div id="kaioken-details" class="hidden space-y-2">
                         <div class="flex items-center gap-2">
                             <div class="flex-grow">
                                 <label for="max-health" class="lbl">Max Health:</label>
                                 <input type="text" id="max-health" placeholder="e.g., 1000" value="1000" class="inpt focus:ring-kaioken-focus">
                             </div>
                             <button id="regen-health-btn" title="Regenerate Health to Max" class="px-2 py-1 text-xs bg-success hover:bg-success-dark text-white rounded-md focus:outline-none focus:ring-2 focus:ring-success focus:ring-offset-1 self-end mb-1 transition-transform active:scale-95">Regen Health</button>
                         </div>
                         <div><label for="kaioken-strain" class="lbl">Kaioken Strain (% Max HP):</label><input type="text" id="kaioken-strain" placeholder="e.g., 10" value="10" class="inpt focus:ring-kaioken-focus"></div>
                         <div>
                             <label class="lbl">Current Health:</label>
                             <span id="current-health" class="readonly-display current-health">1000</span>
                        </div>
                     </div>
                 </div>
             </div>
        </div> </div><template id="energy-pool-template">
        <div class="energy-pool bg-gradient-to-br from-white p-5 mb-5 rounded-lg shadow-sm border-l-4" style="display: none;">
            <h3 class="text-xl font-semibold mb-4 flex items-center">
                <span class="pool-title">Energy Pool Title</span>
                <span class="flex-grow h-px bg-gray-200 ml-3"></span>
            </h3>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div><label class="lbl max-energy-label" for="">Max Energy:</label><input type="text" value="1000" class="inpt max-energy"></div>
                <div><label class="lbl max-multiplier-label" for="">Max Energy Multiplier:</label><input type="text" value="1" class="inpt max-multiplier"></div>
                <div>
                    <label class="lbl total-energy-label" for="">Total Energy (Calculated):</label>
                    <span class="readonly-display total-energy">0</span>
                </div>
                <div>
                    <label class="lbl current-energy-label" for="">Current Energy:</label>
                    <span class="readonly-display current-energy">0</span>
                </div>
                <div><label class="lbl damage-per-power-label" for="">Damage per Energy Point:</label><input type="text" value="1" class="inpt damage-per-power"></div>
                <div>
                    <label class="lbl regen-percent-label" for="">Regeneration Rate (% of Max):</label>
                    <div class="flex items-center gap-2">
                        <input type="text" placeholder="e.g., 10" class="flex-grow p-2 border border-gray-300 rounded-md focus:ring-2 focus:border-transparent text-sm regen-percent">
                        <button class="regen-btn bg-success hover:bg-success-dark focus:ring-success px-3 py-2 text-white rounded-md focus:outline-none focus:ring-2 focus:ring-offset-2 transition-all duration-150 ease-in-out text-sm font-semibold shadow-sm active:scale-95">Regen</button>
                    </div>
                </div>
            </div>
        </div>
    </template>

    <template id="energy-slider-template">
         <div class="energy-slider-section hidden">
             <label class="lbl text-sm slider-label" for="">Energy Used (%):</label>
             <input type="range" class="energy-slider w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer" min="0" max="100" value="0">
             <div class="flex justify-between text-xs text-gray-500 px-1"><span>0%</span><span>50%</span><span>100%</span></div>
             <div class="energy-slider-value-display flex justify-between items-center text-xs bg-gray-100 text-gray-700 p-1 rounded-md min-h-[2.5rem]">
                 <span class="slider-percent-value">0%</span>
                 <span class="slider-details-value text-right">(E: 0, D: 0.00)</span>
             </div>
         </div>
    </template>


    <script>
        // --- DOM Element References ---
        const energyTypeSelect = document.getElementById('energy-type');
        const energyPoolsContainer = document.getElementById('energy-pools-container');
        const slidersGrid = document.getElementById('sliders-grid');
        const energyPoolTemplate = document.getElementById('energy-pool-template');
        const energySliderTemplate = document.getElementById('energy-slider-template');
        const calculateBtn = document.getElementById('calculate-btn');
        const resultDiv = document.getElementById('result');
        const resultValueEl = document.getElementById('result-value');
        const resultTotalEnergyUsedEl = document.getElementById('result-total-energy-used');
        const resultTotalExtraDamageEl = document.getElementById('result-total-extra-damage');
        const resultScientificEl = document.getElementById('result-scientific');
        const resultWordsEl = document.getElementById('result-words');
        const equationDisplayEl = document.getElementById('equation-display'); // Added ref
        const loadingDiv = document.getElementById('loading');
        const messageArea = document.getElementById('message-area');
        const dynamicModifiersContainer = document.getElementById('dynamic-modifiers-container');
        const addDynamicBoxBtn = document.getElementById('add-dynamic-box');
        const baseDamageInput = document.getElementById('base-damage');
        const baseMultiplierInput = document.getElementById('base-multiplier');
        const formMultiplierInput = document.getElementById('form-multiplier');
        const attackCompressionPointsInput = document.getElementById('attack-compression-points');
        const statsPanel = document.getElementById('stats-panel');
        const statsPanelHeader = document.getElementById('stats-panel-header');
        const statCurrentEnergyEl = document.getElementById('stat-current-energy');
        const statTotalDamageEl = document.getElementById('stat-total-damage');
        const statTotalEnergySpentEl = document.getElementById('stat-total-energy-spent');
        const statAttackCountEl = document.getElementById('stat-attack-count');
        const statHighestDamageEl = document.getElementById('stat-highest-damage');
        const kaiokenSection = document.getElementById('kaioken-section');
        const kaiokenCheckbox = document.getElementById('kaioken-checkbox');
        const kaiokenDetails = document.getElementById('kaioken-details');
        const maxHealthInput = document.getElementById('max-health');
        const kaiokenStrainInput = document.getElementById('kaioken-strain');
        const currentHealthEl = document.getElementById('current-health'); // Now a span
        const regenHealthBtn = document.getElementById('regen-health-btn');
        const saveBtn = document.getElementById('save-state-btn');
        const loadBtn = document.getElementById('load-state-btn');
        const clearBtn = document.getElementById('clear-state-btn');

        // --- Global State & Constants ---
        let totalDamageDealt = 0, totalEnergySpent = 0, attackCount = 0, highestDamage = 0;
        const LOCAL_STORAGE_KEY = 'energyCalculatorState_v1';
        let poolAnimationTimeoutId = null;
        const ALL_ENERGY_TYPES = ['ki', 'nen', 'chakra', 'magic', 'cursed', 'reiatsu', 'haki', 'alchemy', 'nature'];
        let dynamicModifierCount = 0;

        // Map for easy lookup of display names and styles defined in Tailwind config
        const ENERGY_TYPE_DETAILS = {
            ki:      { name: 'Ki',      color: 'ki',      colorDark: 'ki-dark',      gradientTo: 'to-orange-100', focusRing: 'focus:ring-ki-focus',      staticGlow: 'static-glow-ki',      pulseGlow: 'animate-pulse-glow-ki',      border: 'border-l-ki' },
            nen:     { name: 'Nen',     color: 'nen',     colorDark: 'nen-dark',     gradientTo: 'to-blue-100',   focusRing: 'focus:ring-nen-focus',     staticGlow: 'static-glow-nen',     pulseGlow: 'animate-pulse-glow-nen',     border: 'border-l-nen' },
            chakra:  { name: 'Chakra',  color: 'chakra',  colorDark: 'chakra-dark',  gradientTo: 'to-purple-100', focusRing: 'focus:ring-chakra-focus',  staticGlow: 'static-glow-chakra',  pulseGlow: 'animate-pulse-glow-chakra',  border: 'border-l-chakra' },
            magic:   { name: 'Magic',   color: 'magic',   colorDark: 'magic-dark',   gradientTo: 'to-teal-100',   focusRing: 'focus:ring-magic-focus',   staticGlow: 'static-glow-magic',   pulseGlow: 'animate-pulse-glow-magic',   border: 'border-l-magic' },
            cursed:  { name: 'Cursed',  color: 'cursed',  colorDark: 'cursed-dark',  gradientTo: 'to-red-100',    focusRing: 'focus:ring-cursed-focus',  staticGlow: 'static-glow-cursed',  pulseGlow: 'animate-pulse-glow-cursed',  border: 'border-l-cursed' },
            reiatsu: { name: 'Reiatsu', color: 'reiatsu', colorDark: 'reiatsu-dark', gradientTo: 'to-slate-100',  focusRing: 'focus:ring-reiatsu-focus', staticGlow: 'static-glow-reiatsu', pulseGlow: 'animate-pulse-glow-reiatsu', border: 'border-l-reiatsu' },
            haki:    { name: 'Haki',    color: 'haki',    colorDark: 'haki-dark',    gradientTo: 'to-gray-100',   focusRing: 'focus:ring-haki-focus',    staticGlow: 'static-glow-haki',    pulseGlow: 'animate-pulse-glow-haki',    border: 'border-l-haki' },
            alchemy: { name: 'Alchemy', color: 'alchemy', colorDark: 'alchemy-dark', gradientTo: 'to-amber-100',  focusRing: 'focus:ring-alchemy-focus', staticGlow: 'static-glow-alchemy', pulseGlow: 'animate-pulse-glow-alchemy', border: 'border-l-alchemy' },
            nature:  { name: 'Nature',  color: 'nature',  colorDark: 'nature-dark',  gradientTo: 'to-lime-100',   focusRing: 'focus:ring-nature-focus',  staticGlow: 'static-glow-nature',  pulseGlow: 'animate-pulse-glow-nature',  border: 'border-l-nature' },
        };

        // --- Utility Functions ---
        function safeParseFloat(value, defaultValue = 0) { if (typeof value !== 'string' && typeof value !== 'number') return defaultValue; const num = parseFloat(String(value).replace(/,/g, '')); return isNaN(num) ? defaultValue : num; }
        function formatSimpleNumber(num) { if (typeof num !== 'number' || isNaN(num)) return '0'; try { const options = { maximumFractionDigits: 2 }; return num.toLocaleString('en-US', options); } catch (e) { return num.toString(); } }
        function showMessage(text, type = 'info') { messageArea.textContent = text; messageArea.className = 'mb-4 p-3 rounded-md text-sm border'; messageArea.classList.remove('hidden'); switch (type) { case 'error': messageArea.classList.add('bg-error-light', 'text-error-dark', 'border-error'); break; case 'success': messageArea.classList.add('bg-success-light', 'text-success-dark', 'border-success'); break; default: messageArea.classList.add('bg-blue-100', 'text-blue-800', 'border-blue-300'); } setTimeout(() => { messageArea.classList.add('hidden'); }, 5000); }
        function showLoading(isLoading) { loadingDiv.classList.toggle('hidden', !isLoading); if(isLoading) resultDiv.classList.add('hidden'); calculateBtn.disabled = isLoading; calculateBtn.classList.toggle('opacity-50', isLoading); calculateBtn.classList.toggle('cursor-not-allowed', isLoading); }
        function triggerAnimation(element, animationClass, duration = 500) { if (!element) return; element.classList.remove(animationClass); void element.offsetWidth; element.classList.add(animationClass); setTimeout(() => { element.classList.remove(animationClass); }, duration); }

        /**
         * Formats numbers using abbreviations K, M for < 1B,
         * or scientific notation for >= 1B.
         */
        function formatStatNumber(num) {
            if (typeof num !== 'number' || isNaN(num)) return '0';
            const absNum = Math.abs(num);
            if (absNum >= 1e9) { return num.toExponential(2); }
            if (absNum >= 1e6) { let shortNum = num / 1e6; let formatted = shortNum.toLocaleString('en-US', { minimumFractionDigits: absNum < 10e6 ? 2 : 1, maximumFractionDigits: absNum < 10e6 ? 2 : 1 }); formatted = formatted.replace(/\.0$/, ''); return formatted + 'M'; }
            if (absNum >= 1e3) { let shortNum = num / 1e3; let formatted = shortNum.toLocaleString('en-US', { minimumFractionDigits: absNum < 10e3 ? 2 : 1, maximumFractionDigits: absNum < 10e3 ? 2 : 1 }); formatted = formatted.replace(/\.0$/, ''); return formatted + 'K'; }
            if (absNum < 1000) { return num.toLocaleString('en-US', { maximumFractionDigits: 2 }); }
            return num.toLocaleString('en-US');
        }

        /**
         * Parses formatted numbers (commas, K, M, B, T, Q, scientific) back to numbers.
         */
        function parseFormattedNumber(str) {
            if (typeof str !== 'string') return 0;
            str = str.trim().toUpperCase().replace(/,/g, ''); // Standardize case and remove commas

            if (str.includes('E')) { const num = parseFloat(str); return isNaN(num) ? 0 : num; } // Handle scientific

            const lastChar = str.slice(-1);
            const numPart = parseFloat(str.slice(0, -1));
            const fullNum = parseFloat(str);

            if (!isNaN(fullNum) && !['K', 'M', 'B', 'T', 'Q'].includes(lastChar)) { return fullNum; } // Plain number
            if (isNaN(numPart) && ['K', 'M', 'B', 'T', 'Q'].includes(lastChar)) return 0; // Invalid number part

            switch (lastChar) { // Handle abbreviations
                case 'K': return numPart * 1e3;
                case 'M': return numPart * 1e6;
                case 'B': return numPart * 1e9;
                case 'T': return numPart * 1e12;
                case 'Q': return numPart * 1e15;
                default: return isNaN(fullNum) ? 0 : fullNum; // Fallback
            }
        }

         /**
         * Escapes special HTML characters in a string.
         */
        function escapeHtml(unsafe) {
            if (typeof unsafe !== 'string') return '';
            return unsafe
                 .replace(/&/g, "&amp;")
                 .replace(/</g, "&lt;")
                 .replace(/>/g, "&gt;")
                 .replace(/"/g, "&quot;")
                 .replace(/'/g, "&#039;");
         }


        // --- Energy Pool Logic ---
        function getEnergyElements(type) {
            if (!ALL_ENERGY_TYPES.includes(type)) { console.error("Invalid type:", type); return null; }
            return {
                poolDiv: document.getElementById(`${type}-pool`),
                maxEnergyEl: document.getElementById(`${type}-max-energy`),
                maxMultiplierEl: document.getElementById(`${type}-max-multiplier`),
                totalEnergyEl: document.getElementById(`${type}-total-energy`), // Now a span
                currentEnergyEl: document.getElementById(`${type}-current-energy`), // Now a span
                damagePerPowerEl: document.getElementById(`${type}-damage-per-power`),
                regenPercentEl: document.getElementById(`${type}-regen-percent`),
                sliderSection: document.getElementById(`${type}-slider-section`),
                energySlider: document.getElementById(`${type}-energy-slider`),
                sliderValueDisplay: document.getElementById(`${type}-slider-value-display`) // The container div
            };
        }

         function updateSliderVisibility(type) {
             const els = getEnergyElements(type);
             if (els?.totalEnergyEl && els.sliderSection) {
                 const totalEnergy = parseFormattedNumber(els.totalEnergyEl.textContent); // Use new parser
                 const shouldShow = totalEnergy > 0;
                 els.sliderSection.classList.toggle('hidden', !shouldShow);
                 if (!shouldShow && els.energySlider) {
                     els.energySlider.value = 0;
                     updateSingleSliderDisplay(type);
                 }
             }
         }

         function calculateAndResetEnergy(type) {
             const els = getEnergyElements(type);
             if (!els?.maxEnergyEl || !els?.maxMultiplierEl || !els?.totalEnergyEl || !els?.currentEnergyEl) { console.error(`Elements missing for reset: ${type}`); return 0; }
             const maxEnergy = safeParseFloat(els.maxEnergyEl.value, 0);
             const multiplier = safeParseFloat(els.maxMultiplierEl.value, 1);
             const totalEnergy = maxEnergy * multiplier;
             els.totalEnergyEl.textContent = formatStatNumber(totalEnergy);
             els.currentEnergyEl.textContent = formatStatNumber(totalEnergy);
             updateSliderVisibility(type);
             updateSingleSliderDisplay(type);
             return totalEnergy;
         }

         function regenerateEnergy(type) {
             const els = getEnergyElements(type);
             if (!els?.totalEnergyEl || !els?.currentEnergyEl || !els?.regenPercentEl) { console.error(`Elements missing for regen: ${type}`); return; }
             const totalEnergy = parseFormattedNumber(els.totalEnergyEl.textContent); // Use new parser
             let currentEnergy = parseFormattedNumber(els.currentEnergyEl.textContent); // Use new parser
             const regenPercent = safeParseFloat(els.regenPercentEl.value, 0);

             if (totalEnergy <= 0) { showMessage('Max Energy must be positive to regenerate.', 'error'); return; }
             if (regenPercent <= 0) { showMessage('Regen Rate must be positive.', 'error'); return; }
             const regenAmount = totalEnergy * (regenPercent / 100);
             let newEnergy = Math.min(currentEnergy + regenAmount, totalEnergy);
             els.currentEnergyEl.textContent = formatStatNumber(newEnergy); // Format output
             showMessage(`${formatStatNumber(regenAmount)} ${type} regenerated. Current: ${formatStatNumber(newEnergy)}`, 'success');
             triggerAnimation(els.currentEnergyEl, 'animate-flash-green');
             updateSingleSliderDisplay(type);
             updateStatsDisplay();
         }


        // --- Kaioken Styling ---
        function applyKaiokenStyle() { if (!statsPanel || !statsPanelHeader) return; statsPanel.classList.remove('border-stats-border'); statsPanel.classList.add('border-kaioken-border', 'animate-kaioken-glow'); statsPanelHeader.classList.remove('text-stats-header'); statsPanelHeader.classList.add('text-kaioken-header'); }
        function removeKaiokenStyle() { if (!statsPanel || !statsPanelHeader) return; statsPanel.classList.add('border-stats-border'); statsPanel.classList.remove('border-kaioken-border', 'animate-kaioken-glow'); statsPanelHeader.classList.add('text-stats-header'); statsPanelHeader.classList.remove('text-kaioken-header'); }

        // --- Health Update ---
         function updateCurrentHealthDisplay() {
             if (!currentHealthEl) return;
             if (energyTypeSelect.value === 'ki' && kaiokenCheckbox.checked && maxHealthInput) {
                 const maxHealth = safeParseFloat(maxHealthInput.value, 0);
                 let currentHealth = parseFormattedNumber(currentHealthEl.textContent); // Use new parser
                 if (currentHealth === -1 || currentHealth > maxHealth || currentHealthEl.textContent.trim() === '' || currentHealthEl.textContent === '0') {
                     currentHealthEl.textContent = formatStatNumber(maxHealth); // Format output
                 }
             } else if (maxHealthInput && (currentHealthEl.textContent.trim() === '' || currentHealthEl.textContent === '0')) {
                 currentHealthEl.textContent = formatStatNumber(safeParseFloat(maxHealthInput.value, 0)); // Format output
             }
         }
         function regenerateHealth() {
             if (!maxHealthInput || !currentHealthEl) { console.error("Health elements missing."); return; }
             const maxHealth = safeParseFloat(maxHealthInput.value, 0);
             currentHealthEl.textContent = formatStatNumber(maxHealth); // Use formatter
             showMessage('Health fully regenerated!', 'success');
             triggerAnimation(currentHealthEl, 'animate-flash-green');
         }


        // --- Show/Hide Logic & Pool Animation ---
        function showSelectedEnergyPool() {
            const selectedType = energyTypeSelect.value;
            const details = ENERGY_TYPE_DETAILS[selectedType];
            let newlyVisiblePool = null;

            if (poolAnimationTimeoutId) { clearTimeout(poolAnimationTimeoutId); poolAnimationTimeoutId = null; }

            // Hide all pools, remove glow/pulse classes
            ALL_ENERGY_TYPES.forEach(type => {
                const els = getEnergyElements(type);
                const typeDetails = ENERGY_TYPE_DETAILS[type];
                if (els?.poolDiv && typeDetails) {
                    els.poolDiv.classList.remove(typeDetails.pulseGlow, typeDetails.staticGlow);
                    if (type !== selectedType) { els.poolDiv.style.display = 'none'; }
                }
            });

            // Find the pool to show
            const poolToShowEls = getEnergyElements(selectedType);
            if (poolToShowEls?.poolDiv && details) {
                poolToShowEls.poolDiv.style.display = 'block';
                newlyVisiblePool = poolToShowEls.poolDiv;
                poolToShowEls.poolDiv.classList.add(details.pulseGlow); // Apply pulse

                poolAnimationTimeoutId = setTimeout(() => { // Switch to static glow
                    const currentSelectedType = energyTypeSelect.value;
                    const stillSelectedPoolEls = getEnergyElements(currentSelectedType);
                    const stillSelectedDetails = ENERGY_TYPE_DETAILS[currentSelectedType];
                    if (stillSelectedPoolEls?.poolDiv && stillSelectedDetails && currentSelectedType === selectedType) {
                        stillSelectedPoolEls.poolDiv.classList.remove(stillSelectedDetails.pulseGlow);
                        stillSelectedPoolEls.poolDiv.classList.add(stillSelectedDetails.staticGlow);
                    }
                    poolAnimationTimeoutId = null;
                }, 5000);
            }

            // Show/Hide Kaioken section
             if (kaiokenSection) { if (selectedType === 'ki') { kaiokenSection.classList.remove('hidden'); if (kaiokenCheckbox.checked) { kaiokenDetails.classList.remove('hidden'); updateCurrentHealthDisplay(); } } else { kaiokenSection.classList.add('hidden'); if (kaiokenCheckbox.checked) { kaiokenCheckbox.checked = false; kaiokenDetails.classList.add('hidden'); removeKaiokenStyle(); } } }

            // --- Persist Current Energy Logic ---
            const els = getEnergyElements(selectedType);
            if (els?.maxEnergyEl && els?.maxMultiplierEl && els?.totalEnergyEl && els?.currentEnergyEl) {
                const maxEnergy = safeParseFloat(els.maxEnergyEl.value, 0);
                const multiplier = safeParseFloat(els.maxMultiplierEl.value, 1);
                const totalEnergy = maxEnergy * multiplier;
                els.totalEnergyEl.textContent = formatStatNumber(totalEnergy); // Update span

                let currentEnergy = parseFormattedNumber(els.currentEnergyEl.textContent); // Use new parser
                if (currentEnergy === -1 || currentEnergy > totalEnergy || els.currentEnergyEl.textContent.trim() === '' || els.currentEnergyEl.textContent === '0') {
                    els.currentEnergyEl.textContent = formatStatNumber(totalEnergy); // Update span
                }

                updateSliderVisibility(selectedType);
                updateSingleSliderDisplay(selectedType);
            }

            updateStatsDisplay();
        }


        // --- Dynamic Modifiers Logic ---
        function addDynamicModifier(modifierData = null) { dynamicModifierCount++; const modifierId = `dynamic-modifier-${dynamicModifierCount}`; const newModifierDiv = document.createElement('div'); const initialType = modifierData?.type || 'additive'; const initialValue = modifierData?.value || '0'; const initialName = modifierData?.name || ''; const isActiveAdditive = initialType === 'additive'; const boxClasses = `dynamic-box p-4 mt-3 border rounded-md border-l-4 relative transition-all duration-300 ease-in-out animate-fadeIn ${isActiveAdditive ? 'additive bg-success-light border-success' : 'multiplicative bg-ki/10 border-ki'}`; newModifierDiv.className = boxClasses; newModifierDiv.id = modifierId; newModifierDiv.innerHTML = ` <div class="absolute top-2 right-2"><button class="remove-dynamic-box bg-error text-white rounded-md shadow-sm w-6 h-6 flex items-center justify-center text-xs hover:bg-error-dark focus:outline-none focus:ring-2 focus:ring-error focus:ring-offset-1 transition-transform active:scale-95" aria-label="Remove this modifier" data-target="${modifierId}">×</button></div><div class="modifier-type-selector flex gap-2 mb-3 border-b pb-2"><div class="modifier-type-option additive ${isActiveAdditive ? 'active' : ''} flex-1 p-2 text-center border rounded-md cursor-pointer transition-all duration-300 ease-in-out text-sm" data-value="additive" tabindex="0" role="radio" aria-checked="${isActiveAdditive}"><input type="radio" name="modifier-type-${modifierId}" value="additive" class="sr-only" ${isActiveAdditive ? 'checked' : ''}> Additive (+)</div><div class="modifier-type-option multiplicative ${!isActiveAdditive ? 'active' : ''} flex-1 p-2 text-center border rounded-md cursor-pointer transition-all duration-300 ease-in-out text-sm" data-value="multiplicative" tabindex="0" role="radio" aria-checked="${!isActiveAdditive}"><input type="radio" name="modifier-type-${modifierId}" value="multiplicative" class="sr-only" ${!isActiveAdditive ? 'checked' : ''}> Multiplier (×)</div></div><div class="grid grid-cols-1 sm:grid-cols-2 gap-3"><div><label for="modifier-name-${modifierId}" class="lbl">Modifier Name:</label><input type="text" id="modifier-name-${modifierId}" placeholder="e.g., Buff" value="${initialName}" class="modifier-name-input w-full p-1.5 border border-gray-300 rounded-md focus:ring-1 focus:ring-success focus:border-transparent text-sm"></div><div><label for="modifier-value-${modifierId}" class="lbl">Value:</label><input type="text" id="modifier-value-${modifierId}" placeholder="e.g., 50 or 1.2" value="${initialValue}" class="modifier-value-input w-full p-1.5 border border-gray-300 rounded-md focus:ring-1 focus:ring-success focus:border-transparent text-sm"></div></div>`; dynamicModifiersContainer.appendChild(newModifierDiv); addListenersToModifierBox(newModifierDiv); }
        // Updated to trigger equation update
        function addListenersToModifierBox(modifierDiv) {
            modifierDiv.querySelector('.remove-dynamic-box')?.addEventListener('click', function() {
                document.getElementById(this.dataset.target)?.remove();
                updateEquationDisplay(); // Update equation when modifier removed
            });
            modifierDiv.querySelectorAll('.modifier-type-option').forEach(option => {
                option.addEventListener('click', function() {
                    const box = this.closest('.dynamic-box'); const value = this.dataset.value; box.querySelectorAll('input[type="radio"]').forEach(radio => radio.checked = (radio.value === value)); box.querySelectorAll('.modifier-type-option').forEach(opt => { const isActive = opt.dataset.value === value; opt.classList.toggle('active', isActive); opt.setAttribute('aria-checked', isActive); }); box.classList.remove('additive', 'multiplicative', 'bg-success-light', 'border-success', 'bg-ki/10', 'border-ki'); box.classList.add(value === 'additive' ? 'additive' : 'multiplicative'); box.classList.add(value === 'additive' ? 'bg-success-light' : 'bg-ki/10'); box.classList.add(value === 'additive' ? 'border-success' : 'border-ki');
                    updateEquationDisplay(); // Update equation on type change
                });
                option.addEventListener('keydown', function(e) { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); this.click(); } });
            });
            const valueInput = modifierDiv.querySelector('.modifier-value-input');
            if (valueInput) {
                valueInput.addEventListener('input', updateEquationDisplay); // Update equation on value input
                valueInput.addEventListener('change', updateEquationDisplay); // Also on change/blur
            }
        }


        // --- Stats Update Logic ---
        // UPDATED to use formatStatNumber and read textContent for current energy display
        function updateStatsDisplay() {
            if (statTotalDamageEl) statTotalDamageEl.textContent = formatStatNumber(totalDamageDealt);
            if (statTotalEnergySpentEl) statTotalEnergySpentEl.textContent = formatStatNumber(totalEnergySpent);
            if (statHighestDamageEl) statHighestDamageEl.textContent = formatStatNumber(highestDamage);
            if (statAttackCountEl) statAttackCountEl.textContent = attackCount.toLocaleString();

            const selectedType = energyTypeSelect.value;
            const els = getEnergyElements(selectedType);
            // Display the already formatted value from the span
            if (statCurrentEnergyEl && els?.currentEnergyEl) {
                statCurrentEnergyEl.textContent = els.currentEnergyEl.textContent || '0';
            } else if (statCurrentEnergyEl) {
                statCurrentEnergyEl.textContent = 'N/A';
            }
        }

        // --- Calculation Logic ---
        // Updated slider display function to use parseFormattedNumber
         function updateSingleSliderDisplay(type) {
             const els = getEnergyElements(type);
             if (!els?.energySlider || !els?.sliderValueDisplay || !els?.currentEnergyEl || !els?.damagePerPowerEl) { return; }
             const percentSpan = els.sliderValueDisplay.querySelector('.slider-percent-value');
             const detailsSpan = els.sliderValueDisplay.querySelector('.slider-details-value');
             if (!percentSpan || !detailsSpan) { console.error("Slider display spans not found for", type); return; }

             const sliderPercent = els.energySlider.value;
             const currentEnergy = parseFormattedNumber(els.currentEnergyEl.textContent); // Use new parser
             const damagePerPower = safeParseFloat(els.damagePerPowerEl.value, 1);

             const potentialEnergyUsed = currentEnergy * (sliderPercent / 100);
             const actualEnergyUsed = Math.min(potentialEnergyUsed, currentEnergy);
             const extraDamage = actualEnergyUsed * damagePerPower;

             percentSpan.textContent = `${sliderPercent}%`;
             detailsSpan.textContent = `(E: ${formatStatNumber(actualEnergyUsed)}, D: ${formatStatNumber(extraDamage)})`;
         }

         // Updated performCalculation with new compression logic & parseFormattedNumber
         function performCalculation() {
             showLoading(true);
             setTimeout(() => {
                 let finalDamage = 0;
                 let healthDepleted = false;
                 try {
                     const baseDamage = safeParseFloat(baseDamageInput.value, 0);
                     const compressionPoints = safeParseFloat(attackCompressionPointsInput.value, 0);
                     const baseMultiplier = safeParseFloat(baseMultiplierInput.value, 1);
                     const formMultiplier = safeParseFloat(formMultiplierInput.value, 1);
                     const energyType = energyTypeSelect.value;

                     // 1. Calculate base damage part first
                     let baseDamagePart = baseDamage * baseMultiplier * formMultiplier;

                     // 2. Calculate compression multiplier separately
                     let compressionMultiplierValue = 1;
                     if (compressionPoints > 0) {
                         compressionMultiplierValue = (compressionPoints * 1.5) + (Math.floor(compressionPoints / 10) * 3);
                         compressionMultiplierValue = Math.max(1, compressionMultiplierValue);
                     }

                     // 3. Apply compression multiplier to the base part
                     finalDamage = baseDamagePart * compressionMultiplierValue;

                     // 4. Apply Dynamic Multiplicative Modifiers
                     document.querySelectorAll('#dynamic-modifiers-container .dynamic-box').forEach(modifierDiv => {
                        const valueInput = modifierDiv.querySelector('.modifier-value-input');
                        const typeOption = modifierDiv.querySelector('.modifier-type-option.active');
                        if (valueInput && typeOption && typeOption.dataset.value === 'multiplicative') {
                            const modifierValue = safeParseFloat(valueInput.value, 0);
                            finalDamage *= ((modifierValue === 0) ? 1 : modifierValue);
                        }
                     });

                     // 5. Calculate Energy Bonuses & Costs
                     let totalEnergyUsedFromSliders = 0;
                     let totalExtraDamageFromEnergy = 0;
                     ALL_ENERGY_TYPES.forEach(type => {
                         const els = getEnergyElements(type);
                         if (els?.energySlider && els.currentEnergyEl && els.damagePerPowerEl) {
                             const sliderPercent = safeParseFloat(els.energySlider.value, 0);
                             if (sliderPercent > 0) {
                                 const currentEnergy = parseFormattedNumber(els.currentEnergyEl.textContent); // Use new parser
                                 const damagePerPower = safeParseFloat(els.damagePerPowerEl.value, 1);
                                 const energyUsedThisType = currentEnergy * (sliderPercent / 100);
                                 const actualEnergyUsed = Math.min(energyUsedThisType, currentEnergy);
                                 const extraDamageThisType = actualEnergyUsed * damagePerPower;
                                 totalEnergyUsedFromSliders += actualEnergyUsed;
                                 totalExtraDamageFromEnergy += extraDamageThisType;
                                 let newCurrentEnergyThisType = Math.max(0, currentEnergy - actualEnergyUsed);
                                 els.currentEnergyEl.textContent = formatStatNumber(newCurrentEnergyThisType); // Format output
                                 if (newCurrentEnergyThisType < currentEnergy) { triggerAnimation(els.currentEnergyEl, 'animate-flash-red'); }
                                 updateSingleSliderDisplay(type);
                             }
                         }
                     });
                     finalDamage += totalExtraDamageFromEnergy; // Add energy bonus

                     // 6. Apply Additive Dynamic Modifiers
                     document.querySelectorAll('#dynamic-modifiers-container .dynamic-box').forEach(modifierDiv => {
                        const valueInput = modifierDiv.querySelector('.modifier-value-input');
                        const typeOption = modifierDiv.querySelector('.modifier-type-option.active');
                        if (valueInput && typeOption && typeOption.dataset.value === 'additive') {
                            const modifierValue = safeParseFloat(valueInput.value, 0);
                            finalDamage += modifierValue;
                        }
                     });

                     // 7. Apply Kaioken Strain
                     healthDepleted = false;
                     if (energyType === 'ki' && kaiokenCheckbox.checked) {
                         const currentHealthVal = parseFormattedNumber(currentHealthEl.textContent); // Use new parser
                         if (currentHealthVal > 0) {
                             const maxHealth = safeParseFloat(maxHealthInput.value, 0);
                             const kaiokenStrainPercent = safeParseFloat(kaiokenStrainInput.value, 0);
                             if (maxHealth > 0 && kaiokenStrainPercent > 0) {
                                 const strainCost = maxHealth * (kaiokenStrainPercent / 100);
                                 let newHealth = Math.max(0, currentHealthVal - strainCost);
                                 currentHealthEl.textContent = formatStatNumber(newHealth); // Format output
                                 if (newHealth < currentHealthVal) { triggerAnimation(currentHealthEl, 'animate-flash-red'); }
                                 if (newHealth === 0) { healthDepleted = true; }
                             }
                         }
                     }

                     // --- Update Stats & Display Results ---
                     totalDamageDealt += finalDamage;
                     totalEnergySpent += totalEnergyUsedFromSliders;
                     attackCount++;
                     if (finalDamage > highestDamage) { highestDamage = finalDamage; }
                     updateStatsDisplay();

                     resultValueEl.textContent = formatSimpleNumber(finalDamage); // Use simple format for main result
                     triggerAnimation(resultValueEl, 'animate-pulse-result', 300);
                     resultTotalEnergyUsedEl.textContent = formatStatNumber(totalEnergyUsedFromSliders);
                     resultTotalExtraDamageEl.textContent = formatStatNumber(totalExtraDamageFromEnergy);
                     displayAllFormats(finalDamage);
                     updateEquationDisplay();
                     resultDiv.classList.remove('hidden', 'bg-error-light', 'border-error', 'text-error-dark');
                     resultDiv.classList.add('bg-success-light', 'border-success', 'text-success-dark');
                     resultDiv.querySelector('.result-title').className = 'result-title text-lg font-semibold mb-2 text-success-dark';
                     let successMsg = 'Calculation successful!';
                     if (healthDepleted) { successMsg += ' Warning: Health depleted by Kaioken strain!'; }
                     showMessage(successMsg, healthDepleted ? 'error' : 'success');

                 } catch (error) {
                     console.error("Calculation Error:", error);
                     resultValueEl.textContent = 'Error'; resultTotalEnergyUsedEl.textContent = 'N/A'; resultTotalExtraDamageEl.textContent = 'N/A'; resultScientificEl.textContent = 'N/A'; resultWordsEl.textContent = 'Error';
                     resultDiv.classList.remove('hidden', 'bg-success-light', 'border-success', 'text-success-dark'); resultDiv.classList.add('bg-error-light', 'border-error', 'text-error-dark'); resultDiv.querySelector('.result-title').className = 'result-title text-lg font-semibold mb-2 text-error-dark';
                     showMessage(`Calculation failed: ${error.message || 'Unknown error'}`, 'error');
                     if (equationDisplayEl) equationDisplayEl.innerHTML = '<span class="text-error-dark">Error calculating equation.</span>';
                 } finally {
                     showLoading(false);
                 }
             }, 50);
         }


        // --- Number Formatting ---
         function displayAllFormats(damage) { try { resultScientificEl.textContent = damage.toExponential(2).replace(/e\+?(-?)/, ' x 10^$1'); } catch (e) { resultScientificEl.textContent = "Invalid"; console.error("Scientific notation error:", e); } try { resultWordsEl.textContent = convertNumberToWords(damage); } catch (e) { resultWordsEl.textContent = "Error: " + e.message; console.error("Number to words error:", e); } }
         function convertNumberToWords(number) { const units = ['', 'One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Eleven', 'Twelve', 'Thirteen', 'Fourteen', 'Fifteen', 'Sixteen', 'Seventeen', 'Eighteen', 'Nineteen']; const tens = ['', '', 'Twenty', 'Thirty', 'Forty', 'Fifty', 'Sixty', 'Seventy', 'Eighty', 'Ninety']; const scales = ['', 'Thousand', 'Million', 'Billion', 'Trillion', 'Quadrillion', 'Quintillion', 'Sextillion', 'Septillion', 'Octillion', 'Nonillion', 'Decillion', 'Undecillion', 'Duodecillion', 'Tredecillion', 'Quattuordecillion', 'Quindecillion']; if (typeof number !== 'number' || !isFinite(number)) { return 'Invalid Number'; } if (number === 0) { return 'Zero'; } const MAX_SAFE_INTEGER_FOR_WORDS = BigInt("9".repeat((scales.length) * 3)); let numForCheck = number < 0 ? BigInt(Math.abs(Math.trunc(number))) : BigInt(Math.trunc(number)); if (numForCheck > MAX_SAFE_INTEGER_FOR_WORDS) { console.warn("Number too large for full word conversion, returning scientific."); return number.toExponential(2) + " (Too large for words)"; } let isNegative = number < 0; if (isNegative) number = -number; let integerPart; let fractionalPart = 0; try { const numStr = number.toLocaleString('en-US', { useGrouping: false, maximumFractionDigits: 20 }); const parts = numStr.split('.'); integerPart = BigInt(parts[0]); if (parts.length > 1) { fractionalPart = parseFloat('0.' + parts[1]); } } catch (e) { console.error("Error processing number for words:", number, e); return "Number too large or invalid format"; } let words = isNegative ? 'Negative ' : ''; function convertHundreds(num) { let word = ''; const h = Math.floor(num / 100); const r = num % 100; if (h > 0) word += units[h] + ' Hundred'; if (r > 0) { if (word !== '') word += ' '; if (r < 20) { word += units[r]; } else { const t = Math.floor(r / 10); const o = r % 10; word += tens[t]; if (o > 0) word += '-' + units[o]; } } return word; } if (integerPart === 0n) { words += 'Zero'; } else { let scaleIndex = 0; let tempWords = []; let currentInt = integerPart; while (currentInt > 0n) { if (scaleIndex >= scales.length) { console.error("Number exceeds defined scales during conversion:", number); return number.toExponential(2) + " (Too large for words)"; } const chunk = Number(currentInt % 1000n); if (chunk !== 0) { const chunkWords = convertHundreds(chunk); tempWords.push(chunkWords + (scaleIndex > 0 ? ' ' + scales[scaleIndex] : '')); } currentInt /= 1000n; scaleIndex++; } words += tempWords.reverse().filter(w => w.trim()).join(', '); } if (fractionalPart > 1e-9) { words += ' Point'; let fractionalStr = fractionalPart.toFixed(6).substring(2).replace(/0+$/, ''); if (fractionalStr.length > 0) { for (const digit of fractionalStr) { words += ' ' + (units[parseInt(digit)] || 'Zero'); } } else { words = words.replace(/ Point$/, ''); } } return words.trim(); }

        // --- State Management ---
        // Updated to handle textContent for spans
        function gatherState() {
            const state = {
                baseDamage: baseDamageInput.value, baseMultiplier: baseMultiplierInput.value, formMultiplier: formMultiplierInput.value, attackCompressionPoints: attackCompressionPointsInput.value,
                selectedEnergyType: energyTypeSelect.value, sliderPercentages: {}, energyPools: {}, dynamicModifiers: [],
                kaiokenActive: kaiokenCheckbox.checked, maxHealth: maxHealthInput.value, kaiokenStrain: kaiokenStrainInput.value,
                currentHealth: currentHealthEl?.textContent || '0',
                totalDamageDealt: totalDamageDealt, totalEnergySpent: totalEnergySpent, attackCount: attackCount, highestDamage: highestDamage
            };
            ALL_ENERGY_TYPES.forEach(type => {
                const els = getEnergyElements(type);
                if (els) {
                    state.energyPools[type] = {
                        maxEnergy: els.maxEnergyEl?.value || '0', maxMultiplier: els.maxMultiplierEl?.value || '1',
                        currentEnergy: els.currentEnergyEl?.textContent || '0',
                        totalEnergy: els.totalEnergyEl?.textContent || '0',
                        damagePerPower: els.damagePerPowerEl?.value || '1', regenPercent: els.regenPercentEl?.value || ''
                    };
                    state.sliderPercentages[type] = els.energySlider?.value || '0';
                }
            });
            dynamicModifiersContainer.querySelectorAll('.dynamic-box').forEach(box => { const nameInput = box.querySelector('.modifier-name-input'); const valueInput = box.querySelector('.modifier-value-input'); const typeOption = box.querySelector('.modifier-type-option.active'); if (nameInput && valueInput && typeOption) { state.dynamicModifiers.push({ name: nameInput.value, value: valueInput.value, type: typeOption.dataset.value }); } });
            return state;
        }
        // Updated to handle textContent for spans
        function applyState(state) {
            if (!state) return;
            baseDamageInput.value = state.baseDamage || ''; baseMultiplierInput.value = state.baseMultiplier || '1'; formMultiplierInput.value = state.formMultiplier || '1'; attackCompressionPointsInput.value = state.attackCompressionPoints || '0';
            energyTypeSelect.value = state.selectedEnergyType || 'ki';

            if (state.energyPools) {
                ALL_ENERGY_TYPES.forEach(type => {
                    const els = getEnergyElements(type);
                    const poolData = state.energyPools[type];
                    if (els && poolData && els.maxEnergyEl && els.totalEnergyEl && els.currentEnergyEl) {
                        els.maxEnergyEl.value = poolData.maxEnergy || '';
                        els.maxMultiplierEl.value = poolData.maxMultiplier || '1';
                        els.damagePerPowerEl.value = poolData.damagePerPower || '1';
                        els.regenPercentEl.value = poolData.regenPercent || '';
                        const loadedTotalNum = (safeParseFloat(poolData.maxEnergy, 0) * safeParseFloat(poolData.maxMultiplier, 1));
                        els.totalEnergyEl.textContent = formatStatNumber(loadedTotalNum);
                        // Use parseFormattedNumber to read saved state before capping/formatting
                        const savedCurrentNum = parseFormattedNumber(poolData.currentEnergy || '0');
                        els.currentEnergyEl.textContent = formatStatNumber(Math.min(savedCurrentNum, loadedTotalNum));
                    }
                });
            }
            if (state.sliderPercentages) { ALL_ENERGY_TYPES.forEach(type => { const els = getEnergyElements(type); if (els?.energySlider) { els.energySlider.value = state.sliderPercentages[type] || '0'; } /* Update display called later */ }); }

            dynamicModifiersContainer.innerHTML = '<h4 class="text-md font-semibold mb-2 text-gray-700">Additional Factors:</h4>'; dynamicModifierCount = 0; if (state.dynamicModifiers && Array.isArray(state.dynamicModifiers)) { state.dynamicModifiers.forEach(modData => { addDynamicModifier(modData); }); }

            kaiokenCheckbox.checked = state.kaiokenActive || false; maxHealthInput.value = state.maxHealth || '1000'; kaiokenStrainInput.value = state.kaiokenStrain || '10';
            if(currentHealthEl) {
                const savedHealthNum = parseFormattedNumber(state.currentHealth || '0');
                 currentHealthEl.textContent = formatStatNumber(savedHealthNum);
            }

            totalDamageDealt = state.totalDamageDealt || 0; totalEnergySpent = state.totalEnergySpent || 0; attackCount = state.attackCount || 0; highestDamage = state.highestDamage || 0;
            // Update displays after state applied
            ALL_ENERGY_TYPES.forEach(type => { updateSliderVisibility(type); updateSingleSliderDisplay(type); });
             updateEquationDisplay(); // Update equation display after loading state
        }

        function saveState() { try { const state = gatherState(); const stateString = JSON.stringify(state); localStorage.setItem(LOCAL_STORAGE_KEY, stateString); showMessage('State saved successfully!', 'success'); } catch (error) { console.error("Error saving state:", error); showMessage(`Failed to save state. ${error.message}`, 'error'); } }
        function loadState() { const stateString = localStorage.getItem(LOCAL_STORAGE_KEY); if (stateString) { try { const state = JSON.parse(stateString); applyState(state); showMessage('State loaded successfully!', 'success'); return true; /* Indicate state was loaded */ } catch (error) { console.error("Error loading state:", error); showMessage(`Failed to load saved state. Data might be corrupted. ${error.message}`, 'error'); localStorage.removeItem(LOCAL_STORAGE_KEY); } } return false; /* Indicate no state loaded */ }
        function clearState() { if (confirm('Are you sure you want to clear the saved state? This cannot be undone.')) { localStorage.removeItem(LOCAL_STORAGE_KEY); showMessage('Saved state cleared. Reloading.', 'success'); setTimeout(() => window.location.reload(), 1000); } }


        // --- Generate Elements from Templates ---
        function generateEnergySections() {
            if (!energyPoolTemplate || !energySliderTemplate || !energyPoolsContainer || !slidersGrid) { console.error("Required templates or containers not found!"); return; }
            energyPoolsContainer.innerHTML = ''; slidersGrid.innerHTML = ''; // Clear containers
            ALL_ENERGY_TYPES.forEach(type => {
                const details = ENERGY_TYPE_DETAILS[type]; if (!details) return;
                // Generate Energy Pool
                const poolClone = energyPoolTemplate.content.cloneNode(true);
                const poolDiv = poolClone.querySelector('.energy-pool');
                if (poolDiv) {
                    poolDiv.id = `${type}-pool`; poolDiv.style.display = 'none';
                    poolDiv.classList.add(details.border, details.gradientTo);
                    const titleEl = poolDiv.querySelector('.pool-title');
                    if (titleEl) titleEl.textContent = `${details.name} Energy Pool`;
                    // Setup inputs and spans
                    const setupElement = (selectorSuffix, isInput = true, focusClass = '') => {
                        const el = poolDiv.querySelector(`.${selectorSuffix}`);
                        const labelEl = poolDiv.querySelector(`.${selectorSuffix}-label`);
                        if (el) {
                            el.id = `${type}-${selectorSuffix}`; // Set ID
                            // Only set 'for' if the target is an input/select/textarea
                            if(labelEl && isInput) labelEl.htmlFor = el.id;
                            else if (labelEl) labelEl.removeAttribute('for'); // Remove 'for' if target is span

                            if (isInput && focusClass) el.classList.add(focusClass); // Add focus ring only to inputs
                        }
                    };
                    setupElement('max-energy', true, details.focusRing);
                    setupElement('max-multiplier', true, details.focusRing);
                    setupElement('total-energy', false); // It's a span
                    setupElement('current-energy', false); // It's a span
                    setupElement('damage-per-power', true, details.focusRing);
                    setupElement('regen-percent', true, details.focusRing); // Input part
                    const regenBtn = poolDiv.querySelector('.regen-btn'); if (regenBtn) { regenBtn.dataset.type = type; }
                    energyPoolsContainer.appendChild(poolClone);
                } else { console.error(`Could not find .energy-pool in template clone for ${type}`);}
                // Generate Energy Slider
                const sliderClone = energySliderTemplate.content.cloneNode(true);
                const sliderSection = sliderClone.querySelector('.energy-slider-section');
                if (sliderSection) {
                     sliderSection.id = `${type}-slider-section`; sliderSection.dataset.type = type;
                     const sliderLabel = sliderSection.querySelector('.slider-label'); const energySlider = sliderSection.querySelector('.energy-slider'); const valueDisplay = sliderSection.querySelector('.energy-slider-value-display');
                     if (sliderLabel) { sliderLabel.htmlFor = `${type}-energy-slider`; sliderLabel.textContent = `${details.name} Energy Used (%):`; }
                     if (energySlider) { energySlider.id = `${type}-energy-slider`; energySlider.dataset.type = type; }
                     if (valueDisplay) { valueDisplay.id = `${type}-slider-value-display`; } // ID for the container div
                     slidersGrid.appendChild(sliderClone);
                } else { console.error(`Could not find .energy-slider-section in template clone for ${type}`);}
            });
            console.log("Energy sections generated.");
        }

        // +++ Equation Display Function +++
        // Updated to include factor name titles
        function updateEquationDisplay() {
            if (!equationDisplayEl) return;

            let equationHTML = '';
            const op = (operator) => `<span class="equation-operator">${operator}</span>`;
            const group = (content) => `<span class="equation-group">(</span>${content}<span class="equation-group">)</span>`;
            // Updated num helper to accept optional title
            const num = (value, targetId, title = '') => {
                 const titleAttr = title ? ` title="${escapeHtml(title)}"` : '';
                 return `<span class="equation-number" data-target-id="${targetId}"${titleAttr}>${formatSimpleNumber(value)}</span>`;
            };

            try {
                // 1. Group (Base * BaseMult * FormMult)
                const baseDamage = safeParseFloat(baseDamageInput.value, 0);
                const baseMultiplier = safeParseFloat(baseMultiplierInput.value, 1);
                const formMultiplier = safeParseFloat(formMultiplierInput.value, 1);

                let basePart = num(baseDamage, 'base-damage');
                if (baseMultiplier !== 1 || baseMultiplierInput.value.trim() !== '1') {
                    basePart += op('*') + num(baseMultiplier, 'base-multiplier');
                }
                if (formMultiplier !== 1 || formMultiplierInput.value.trim() !== '1') {
                    basePart += op('*') + num(formMultiplier, 'form-multiplier');
                }
                let baseCalculationHTML = (basePart !== num(baseDamage, 'base-damage')) ? group(basePart) : basePart;

                // 2. Compression Multiplier (applied after base group)
                const compressionPoints = safeParseFloat(attackCompressionPointsInput.value, 0);
                let compressionMultiplierValue = 1;
                if (compressionPoints > 0) {
                    compressionMultiplierValue = (compressionPoints * 1.5) + (Math.floor(compressionPoints / 10) * 3);
                    compressionMultiplierValue = Math.max(1, compressionMultiplierValue);
                    baseCalculationHTML += op('*') + `<span class="equation-number" data-target-id="attack-compression-points" title="${compressionPoints} points">${formatSimpleNumber(compressionMultiplierValue)}</span>`;
                }
                 equationHTML = baseCalculationHTML;

                // 3. Dynamic Multiplicative Modifiers
                let multiplicativeTerms = [];
                document.querySelectorAll('#dynamic-modifiers-container .dynamic-box').forEach((modifierDiv) => {
                    const valueInput = modifierDiv.querySelector('.modifier-value-input');
                    const typeOption = modifierDiv.querySelector('.modifier-type-option.active');
                    const nameInput = modifierDiv.querySelector('.modifier-name-input'); // Get name input
                    const modifierId = valueInput?.id;
                    const factorName = nameInput?.value.trim() || 'Factor'; // Get name

                    if (valueInput && typeOption && modifierId && typeOption.dataset.value === 'multiplicative') {
                        const modifierValue = safeParseFloat(valueInput.value, 0);
                        const multiplier = (modifierValue === 0) ? 1 : modifierValue;
                        if (multiplier !== 1 || valueInput.value.trim() !== '1') {
                             multiplicativeTerms.push(num(multiplier, modifierId, factorName)); // Pass name
                        }
                    }
                });
                if (multiplicativeTerms.length > 0) {
                     equationHTML += op('*') + group(multiplicativeTerms.join(op('*')));
                }

                // 4. Energy Damage Bonus
                let energyTerms = [];
                ALL_ENERGY_TYPES.forEach(type => {
                    const els = getEnergyElements(type);
                    if (els?.energySlider && els.currentEnergyEl && els.damagePerPowerEl) {
                        const sliderPercent = safeParseFloat(els.energySlider.value, 0);
                        if (sliderPercent > 0) {
                            const currentEnergy = parseFormattedNumber(els.currentEnergyEl.textContent); // Use new parser
                            const damagePerPower = safeParseFloat(els.damagePerPowerEl.value, 1);
                            const energyUsed = Math.min(currentEnergy * (sliderPercent / 100), currentEnergy);
                            const energyDamage = energyUsed * damagePerPower;
                            if (energyDamage !== 0) {
                                const energyTitle = `${ENERGY_TYPE_DETAILS[type]?.name || type} Energy Used`;
                                const dppTitle = `${ENERGY_TYPE_DETAILS[type]?.name || type} Damage/Point`;
                                energyTerms.push(group(num(energyUsed, `${type}-energy-slider`, energyTitle) + op('*') + num(damagePerPower, `${type}-damage-per-power`, dppTitle)));
                            }
                        }
                    }
                });
                 if (energyTerms.length > 0) {
                     equationHTML = group(equationHTML); // Group multiplicative part before adding energy
                     equationHTML += op('+') + group(energyTerms.join(op('+')));
                 }

                // 5. Dynamic Additive Modifiers (Applied last)
                let additiveTerms = [];
                 document.querySelectorAll('#dynamic-modifiers-container .dynamic-box').forEach((modifierDiv) => {
                    const valueInput = modifierDiv.querySelector('.modifier-value-input');
                    const typeOption = modifierDiv.querySelector('.modifier-type-option.active');
                    const nameInput = modifierDiv.querySelector('.modifier-name-input'); // Get name input
                    const modifierId = valueInput?.id;
                    const factorName = nameInput?.value.trim() || 'Factor'; // Get name

                     if (valueInput && typeOption && modifierId && typeOption.dataset.value === 'additive') {
                         const modifierValue = safeParseFloat(valueInput.value, 0);
                         if (modifierValue !== 0) {
                             additiveTerms.push(num(modifierValue, modifierId, factorName)); // Pass name
                         }
                     }
                 });
                 if (additiveTerms.length > 0) {
                      if (energyTerms.length > 0 || multiplicativeTerms.length > 0 || compressionPoints > 0 || baseMultiplier !== 1 || formMultiplier !== 1) {
                           equationHTML = group(equationHTML); // Group previous calculation if adding additive terms
                      }
                      equationHTML += op('+') + group(additiveTerms.join(op('+')));
                 }

                equationDisplayEl.innerHTML = equationHTML;

            } catch (error) {
                console.error("Error updating equation:", error);
                equationDisplayEl.innerHTML = '<span class="text-error-dark">Could not generate equation.</span>';
            }
        }

        // +++ UPDATED: Click Handler for Equation Numbers +++
        function handleEquationClick(event) {
            const target = event.target;
            if (target.classList.contains('equation-number') && target.dataset.targetId) {
                const targetId = target.dataset.targetId;
                const sourceElement = document.getElementById(targetId);

                if (sourceElement) {
                    // --- Scroll & Pulse Logic ---
                    sourceElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    let elementToPulse = sourceElement;
                    if (sourceElement.tagName === 'SPAN' && sourceElement.classList.contains('readonly-display')) { elementToPulse = sourceElement.closest('.energy-pool') || sourceElement; }
                    else if (sourceElement.type === 'range') { elementToPulse = sourceElement.closest('.energy-slider-section') || sourceElement; }
                    else if (sourceElement.classList.contains('modifier-value-input')) { elementToPulse = sourceElement.closest('.dynamic-box') || sourceElement; }
                    triggerAnimation(elementToPulse, 'animate-pulse-source', 800);
                    if (sourceElement.tagName === 'INPUT' && !sourceElement.readOnly && sourceElement.type !== 'range') { sourceElement.focus(); }
                    // --- End Scroll & Pulse ---

                    // --- Switch Tab Logic for DPP ---
                    if (targetId.endsWith('-damage-per-power')) {
                        const parts = targetId.split('-');
                        const energyType = parts[0];
                        if (ALL_ENERGY_TYPES.includes(energyType) && energyTypeSelect.value !== energyType) {
                            console.log(`Switching to ${energyType} pool...`);
                            energyTypeSelect.value = energyType;
                            showSelectedEnergyPool(); // Update display
                            updateEquationDisplay(); // Re-update equation in case context changes
                        }
                    }
                     // --- End Switch Tab ---
                } else { console.warn(`Equation link target element not found: #${targetId}`); }
            }
        }


        // --- Event Listeners Setup ---
        function setupEventListeners() {
            energyTypeSelect.addEventListener('change', () => {
                showSelectedEnergyPool();
                updateEquationDisplay(); // Update equation on type change
            });
            calculateBtn.addEventListener('click', performCalculation); // performCalculation calls updateEquationDisplay
            addDynamicBoxBtn.addEventListener('click', () => addDynamicModifier()); // addDynamicModifier adds listeners

            // Basic input listeners - update equation on change/blur
            [baseDamageInput, attackCompressionPointsInput, baseMultiplierInput, formMultiplierInput].forEach(input => {
                if(input) {
                    input.addEventListener('input', updateEquationDisplay);
                    input.addEventListener('change', updateEquationDisplay);
                }
            });

            // Attach listeners to dynamically generated sliders and inputs
            ALL_ENERGY_TYPES.forEach(type => {
                const els = getEnergyElements(type);
                if (els) {
                    // Update equation when these inputs change
                    if (els.maxEnergyEl) els.maxEnergyEl.addEventListener('input', () => { calculateAndResetEnergy(type); updateStatsDisplay(); updateEquationDisplay(); });
                    if (els.maxMultiplierEl) els.maxMultiplierEl.addEventListener('input', () => { calculateAndResetEnergy(type); updateStatsDisplay(); updateEquationDisplay(); });
                    if (els.damagePerPowerEl) els.damagePerPowerEl.addEventListener('input', () => { updateSingleSliderDisplay(type); updateEquationDisplay(); }); // Update equation too
                    if (els.regenPercentEl) els.regenPercentEl.addEventListener('input', updateEquationDisplay); // Update on regen input change too

                    // Update equation when slider moves
                    if (els.energySlider) els.energySlider.addEventListener('input', () => { updateSingleSliderDisplay(type); updateEquationDisplay(); });

                    // Regen button listener
                    const regenBtn = els.poolDiv?.querySelector('.regen-btn');
                     if (regenBtn) { regenBtn.addEventListener('click', function() { regenerateEnergy(this.dataset.type); /* Regen updates equation indirectly via current energy change */ }); }
                } else { console.warn(`Could not find elements for type ${type} to attach listeners.`); }
            });

            // Kaioken listeners - update equation if relevant
             if (kaiokenCheckbox) { kaiokenCheckbox.addEventListener('change', () => { const isChecked = kaiokenCheckbox.checked; kaiokenDetails.classList.toggle('hidden', !isChecked); if (isChecked) { applyKaiokenStyle(); updateCurrentHealthDisplay(); } else { removeKaiokenStyle(); } updateEquationDisplay(); }); }
             if (maxHealthInput) { maxHealthInput.addEventListener('input', () => { updateCurrentHealthDisplay(); updateEquationDisplay(); }); }
             if (kaiokenStrainInput) { kaiokenStrainInput.addEventListener('input', updateEquationDisplay); }
             if (regenHealthBtn) { regenHealthBtn.addEventListener('click', regenerateHealth); }

             // Save/Load/Clear Listeners
             if (saveBtn) saveBtn.addEventListener('click', saveState);
             if (loadBtn) loadBtn.addEventListener('click', loadState); // loadState calls applyState which calls updateEquation
             if (clearBtn) clearBtn.addEventListener('click', clearState);

             // Add delegated listener for equation clicks
             if (equationDisplayEl) {
                 equationDisplayEl.addEventListener('click', handleEquationClick);
             }
             console.log("Event listeners set up.");
        }


        // --- Initial Setup on Page Load ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM Loaded. Initializing...");
            generateEnergySections(); // 1. Generate HTML elements

            // 2. Initialize energy values from defaults (needed before loadState)
            ALL_ENERGY_TYPES.forEach(type => { calculateAndResetEnergy(type); });

            const stateLoaded = loadState(); // 3. Try loading saved state (applyState calls updateEquation)

            setupEventListeners(); // 4. Attach event listeners

            // 5. Set initial UI state and update displays
            showSelectedEnergyPool(); // Show the correct pool based on dropdown
            updateStatsDisplay(); // Update stats panel
            if (!stateLoaded) { // If no state was loaded, update equation based on defaults
                updateEquationDisplay();
            }

            console.log(`Initialization complete. ${stateLoaded ? '(State Loaded)' : '(No State Loaded)'}`);
        });

    </script>

</body>
</html>
