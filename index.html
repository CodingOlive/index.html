<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Energy Calculator - v9.7 (Attack Reservation)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link
        rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css"
    />
    <script>
        // Tailwind CSS Configuration
        // Extends the default Tailwind theme with custom colors, animations, and keyframes.
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        // Energy types (matched with hex codes below)
                        ki: '#FF9800', nen: '#2196F3', chakra: '#9C27B0', magic: '#26a69a', cursed: '#dc2626',
                        reiatsu: '#475569', haki: '#1f2937', alchemy: '#f59e0b', nature: '#84cc16',
                        force: '#d946ef', // Force color is Fuchsia (fuchsia-500)
                        // Darker variants for text/hover states
                        'ki-dark': '#e65100', 'nen-dark': '#0d47a1', 'chakra-dark': '#4a148c', 'magic-dark': '#00796b', 'cursed-dark': '#b91c1c',
                        'reiatsu-dark': '#1e293b', 'haki-dark': '#000000', 'alchemy-dark': '#b45309', 'nature-dark': '#4d7c0f',
                        'force-dark': '#a21caf', // Force dark color (fuchsia-700)
                        // UI feedback colors
                        'success-light': '#e8f5e9', 'success': '#4CAF50', 'success-dark': '#2e7d32',
                        'error-light': '#ffebee', 'error': '#f44336', 'error-dark': '#c62828',
                        // Stats panel specific colors
                        'stats-border': '#60a5fa', 'stats-header': '#1e3a8a',
                        // Kaioken active state colors
                        'kaioken-border': '#f87171', 'kaioken-header': '#b91c1c', 'kaioken-focus': '#ef4444',
                        // Focus Rings for inputs, specific to each energy type
                        'magic-focus': '#26a69a', 'cursed-focus': '#dc2626', 'reiatsu-focus': '#475569',
                        'haki-focus': '#1f2937', 'alchemy-focus': '#f59e0b', 'nature-focus': '#84cc16',
                        'ki-focus': '#FF9800', 'nen-focus': '#2196F3', 'chakra-focus': '#9C27B0',
                        'force-focus': '#d946ef', // Force focus color (fuchsia-500)
                    },
                    // Custom animations definitions, combining custom names with Animate.css names
                    animation: {
                        spin: 'spin 1s linear infinite', shake: 'shake 0.5s ease-in-out', fadeIn: 'fadeIn 0.3s ease-in', pulse: 'pulse 1.5s infinite',
                        'pulse-additive': 'pulse-additive 0.5s', 'pulse-multiplicative': 'pulse-multiplicative 0.5s', 'pulse-result': 'pulse-result 0.3s ease-in-out',
                        'flash-red': 'flash-red-bg 0.5s ease-out', 'flash-green': 'flash-green-bg 0.5s ease-out', 'kaioken-glow': 'kaioken-glow 1.5s infinite ease-in-out',
                        // Specific pulse glow animations for each energy type pool
                        'animate-pulse-glow-ki': 'pulse-glow-ki 1.5s infinite ease-in-out',
                        'animate-pulse-glow-nen': 'pulse-glow-nen 1.5s infinite ease-in-out',
                        'animate-pulse-glow-chakra': 'pulse-glow-chakra 1.5s infinite ease-in-out',
                        'animate-pulse-glow-magic': 'pulse-glow-magic 1.5s infinite ease-in-out',
                        'animate-pulse-glow-cursed': 'pulse-glow-cursed 1.5s infinite ease-in-out',
                        'animate-pulse-glow-reiatsu': 'pulse-glow-reiatsu 1.5s infinite ease-in-out',
                        'animate-pulse-glow-haki': 'pulse-glow-haki 1.5s infinite ease-in-out',
                        'animate-pulse-glow-alchemy': 'pulse-glow-alchemy 1.5s infinite ease-in-out',
                        'animate-pulse-glow-nature': 'pulse-glow-nature 1.5s infinite ease-in-out',
                        'animate-pulse-glow-force': 'pulse-glow-force 1.5s infinite ease-in-out',
                        // Animation for highlighting linked input from equation
                        'animate-pulse-source': 'pulse-source-input 0.8s ease-out',
                    },
                    // Keyframe definitions for custom animations
                    keyframes: {
                        spin: { '0%': { transform: 'rotate(0deg)' }, '100%': { transform: 'rotate(360deg)' }, },
                        shake: { '0%, 100%': { transform: 'translateX(0)' }, '25%, 75%': { transform: 'translateX(-5px)' }, '50%': { transform: 'translateX(5px)' }, },
                        fadeIn: { from: { opacity: 0, transform: 'translateY(10px)' }, to: { opacity: 1, transform: 'translateY(0)' }, },
                        pulse: { '0%, 100%': { transform: 'scale(1)' }, '50%': { transform: 'scale(1.05)' }, },
                        'pulse-additive': { '0%, 100%': { color: '#558b2f' }, '50%': { color: '#8BC34A' }, },
                        'pulse-multiplicative': { '0%, 100%': { color: '#e65100' }, '50%': { color: '#FF9800' }, },
                        'pulse-result': { '0%, 100%': { transform: 'scale(1)' }, '50%': { transform: 'scale(1.05)' }, },
                        'flash-red-bg': { '50%': { backgroundColor: '#ffebee', borderColor: '#f44336' } }, // Flash background red
                        'flash-green-bg': { '50%': { backgroundColor: '#e8f5e9', borderColor: '#4CAF50' } }, // Flash background green
                        'kaioken-glow': { '0%, 100%': { boxShadow: `0 0 10px #f8717180` }, '50%': { boxShadow: `0 0 20px #f87171CC` } }, // Kaioken panel glow
                         // Keyframes for energy pool pulse glows
                         'pulse-glow-ki': { '0%, 100%': { boxShadow: `0 0 8px #FF980066` }, '50%': { boxShadow: `0 0 16px #FF9800B3` } },
                         'pulse-glow-nen': { '0%, 100%': { boxShadow: `0 0 8px #2196F366` }, '50%': { boxShadow: `0 0 16px #2196F3B3` } },
                         'pulse-glow-chakra': { '0%, 100%': { boxShadow: `0 0 8px #9C27B066` }, '50%': { boxShadow: `0 0 16px #9C27B0B3` } },
                         'pulse-glow-magic': { '0%, 100%': { boxShadow: `0 0 8px #26a69a66` }, '50%': { boxShadow: `0 0 16px #26a69aB3` } },
                         'pulse-glow-cursed': { '0%, 100%': { boxShadow: `0 0 8px #dc262666` }, '50%': { boxShadow: `0 0 16px #dc2626B3` } },
                         'pulse-glow-reiatsu': { '0%, 100%': { boxShadow: `0 0 8px #47556966` }, '50%': { boxShadow: `0 0 16px #475569B3` } },
                         'pulse-glow-haki': { '0%, 100%': { boxShadow: `0 0 8px #1f293766` }, '50%': { boxShadow: `0 0 16px #1f2937B3` } },
                         'pulse-glow-alchemy': { '0%, 100%': { boxShadow: `0 0 8px #f59e0b66` }, '50%': { boxShadow: `0 0 16px #f59e0bB3` } },
                         'pulse-glow-nature': { '0%, 100%': { boxShadow: `0 0 8px #84cc1666` }, '50%': { boxShadow: `0 0 16px #84cc16B3` } },
                         'pulse-glow-force': { '0%, 100%': { boxShadow: `0 0 8px #d946ef66` }, '50%': { boxShadow: `0 0 16px #d946efB3` } },
                         // Keyframes for pulsing the source input linked from the equation
                         'pulse-source-input': { '0%, 100%': { boxShadow: 'none' }, '50%': { boxShadow: '0 0 12px theme("colors.blue.400")' } },
                    }
                }
            }
        }
    </script>
    <link rel="preconnect" href="https://rsms.me/">
    <link rel="stylesheet" href="https://rsms.me/inter/inter.css">
    <style>
        /* Base Styles */
        body { font-family: 'Inter', sans-serif; background-color: #f9f9f9; color: #333; }
        /* Base style for energy pool sections */
        .energy-pool { @apply p-5 mb-5 rounded-lg shadow-sm border-l-4; transition: box-shadow 0.3s ease-in-out, opacity 0.3s ease-in-out; }

        /* Dynamic Pool Styles - Sets border and heading color based on energy type */
        .energy-pool-ki { border-left-color: #FF9800; } .energy-pool-ki h3 { color: #e65100; }
        .energy-pool-nen { border-left-color: #2196F3; } .energy-pool-nen h3 { color: #0d47a1; }
        .energy-pool-chakra { border-left-color: #9C27B0; } .energy-pool-chakra h3 { color: #4a148c; }
        .energy-pool-magic { border-left-color: #26a69a; } .energy-pool-magic h3 { color: #00796b; }
        .energy-pool-cursed { border-left-color: #dc2626; } .energy-pool-cursed h3 { color: #b91c1c; }
        .energy-pool-reiatsu { border-left-color: #475569; } .energy-pool-reiatsu h3 { color: #1e293b; }
        .energy-pool-haki { border-left-color: #1f2937; } .energy-pool-haki h3 { color: #000000; }
        .energy-pool-alchemy { border-left-color: #f59e0b; } .energy-pool-alchemy h3 { color: #b45309; }
        .energy-pool-nature { border-left-color: #84cc16; } .energy-pool-nature h3 { color: #4d7c0f; }
        .energy-pool-force { border-left-color: #d946ef; } .energy-pool-force h3 { color: #a21caf; }

        /* Base Slider Track Style */
        .energy-slider {
            @apply w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer;
            transition: background 0.2s ease-in-out; /* Transition for gradient background change */
         }
        /* Base Slider Thumb Style (common styling) */
        .energy-slider::-webkit-slider-thumb { appearance: none; width: 20px; height: 20px; border-radius: 50%; cursor: pointer; box-shadow: 0 1px 3px rgba(0,0,0,0.2); transition: background 0.3s; border: none; background: #9ca3af; /* Default thumb color */ }
        .energy-slider::-moz-range-thumb { width: 20px; height: 20px; border-radius: 50%; cursor: pointer; box-shadow: 0 1px 3px rgba(0,0,0,0.2); transition: background 0.3s; border: none; background: #9ca3af; /* Default thumb color */ }

        /* Slider Thumb Colors (Specific to each energy type via ID) */
        #ki-energy-slider::-webkit-slider-thumb { background: #FF9800; } #ki-energy-slider::-moz-range-thumb { background: #FF9800; }
        #nen-energy-slider::-webkit-slider-thumb { background: #2196F3; } #nen-energy-slider::-moz-range-thumb { background: #2196F3; }
        #chakra-energy-slider::-webkit-slider-thumb { background: #9C27B0; } #chakra-energy-slider::-moz-range-thumb { background: #9C27B0; }
        #magic-energy-slider::-webkit-slider-thumb { background: #26a69a; } #magic-energy-slider::-moz-range-thumb { background: #26a69a; }
        #cursed-energy-slider::-webkit-slider-thumb { background: #dc2626; } #cursed-energy-slider::-moz-range-thumb { background: #dc2626; }
        #reiatsu-energy-slider::-webkit-slider-thumb { background: #475569; } #reiatsu-energy-slider::-moz-range-thumb { background: #475569; }
        #haki-energy-slider::-webkit-slider-thumb { background: #1f2937; } #haki-energy-slider::-moz-range-thumb { background: #1f2937; }
        #alchemy-energy-slider::-webkit-slider-thumb { background: #f59e0b; } #alchemy-energy-slider::-moz-range-thumb { background: #f59e0b; }
        #nature-energy-slider::-webkit-slider-thumb { background: #84cc16; } #nature-energy-slider::-moz-range-thumb { background: #84cc16; }
        #force-energy-slider::-webkit-slider-thumb { background: #d946ef; } #force-energy-slider::-moz-range-thumb { background: #d946ef; }

        /* Slider Thumb Hover Colors */
        #ki-energy-slider:hover::-webkit-slider-thumb { background: #e65100; } #ki-energy-slider:hover::-moz-range-thumb { background: #e65100; }
        #nen-energy-slider:hover::-webkit-slider-thumb { background: #0d47a1; } #nen-energy-slider:hover::-moz-range-thumb { background: #0d47a1; }
        #chakra-energy-slider:hover::-webkit-slider-thumb { background: #4a148c; } #chakra-energy-slider:hover::-moz-range-thumb { background: #4a148c; }
        #magic-energy-slider:hover::-webkit-slider-thumb { background: #00796b; } #magic-energy-slider:hover::-moz-range-thumb { background: #00796b; }
        #cursed-energy-slider:hover::-webkit-slider-thumb { background: #b91c1c; } #cursed-energy-slider:hover::-moz-range-thumb { background: #b91c1c; }
        #reiatsu-energy-slider:hover::-webkit-slider-thumb { background: #1e293b; } #reiatsu-energy-slider:hover::-moz-range-thumb { background: #1e293b; }
        #haki-energy-slider:hover::-webkit-slider-thumb { background: #000000; } #haki-energy-slider:hover::-moz-range-thumb { background: #000000; }
        #alchemy-energy-slider:hover::-webkit-slider-thumb { background: #b45309; } #alchemy-energy-slider:hover::-moz-range-thumb { background: #b45309; }
        #nature-energy-slider:hover::-webkit-slider-thumb { background: #4d7c0f; } #nature-energy-slider:hover::-moz-range-thumb { background: #4d7c0f; }
        #force-energy-slider:hover::-webkit-slider-thumb { background: #a21caf; } #force-energy-slider:hover::-moz-range-thumb { background: #a21caf; }

        /* Dynamic Modifier Box Styles */
        .modifier-type-option.additive { border-color: theme('colors.success'); color: theme('colors.success-dark'); }
        .modifier-type-option.additive.active { background-color: theme('colors.success-light'); box-shadow: 0 1px 5px rgba(76, 175, 80, 0.3); animation: pulse-additive 0.5s; color: theme('colors.success'); }
        .modifier-type-option.multiplicative { border-color: theme('colors.ki'); color: theme('colors.ki-dark'); }
        .modifier-type-option.multiplicative.active { background-color: theme('colors.ki / 0.1'); box-shadow: 0 1px 5px rgba(255, 152, 0, 0.3); animation: pulse-multiplicative 0.5s; color: theme('colors.ki'); }

        /* Custom Animation Classes */
        .animate-pulse-result { animation: pulse-result 0.3s ease-in-out; }
        .animate-flash-red { animation: flash-red-bg 0.5s ease-out; }
        .animate-flash-green { animation: flash-green-bg 0.5s ease-out; }
        .animate-kaioken-glow { animation: kaioken-glow 1.5s infinite ease-in-out; }

        /* Static Glow classes for energy pools */
        .static-glow-ki { box-shadow: 0 0 10px #FF980080; } .static-glow-nen { box-shadow: 0 0 10px #2196F380; } .static-glow-chakra { box-shadow: 0 0 10px #9C27B080; } .static-glow-magic { box-shadow: 0 0 10px #26a69a80; } .static-glow-cursed { box-shadow: 0 0 10px #dc262680; } .static-glow-reiatsu { box-shadow: 0 0 10px #47556980; } .static-glow-haki { box-shadow: 0 0 10px #1f293780; } .static-glow-alchemy { box-shadow: 0 0 10px #f59e0b80; } .static-glow-nature { box-shadow: 0 0 10px #84cc1680; }
        .static-glow-force { box-shadow: 0 0 10px #d946ef80; }

        /* Accessibility utility class */
        .sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 0, 0); white-space: nowrap; border-width: 0; }
        /* Stats Panel Styling */
        .stats-panel { border-left-width: 4px; transition: border-color 0.3s ease-in-out, box-shadow 1.5s ease-in-out; }
        .stats-panel-header { transition: color 0.3s ease-in-out; }
        /* Common Label Style */
        .lbl { @apply block mb-1 font-medium text-sm text-gray-600; }
        /* Common Input Style */
        .inpt { @apply w-full p-2 border border-gray-300 rounded-md focus:ring-2 focus:border-transparent text-sm transition-colors duration-300; }
        /* Common Regen Button Style */
        .regen-btn { @apply px-3 py-2 text-white rounded-md focus:outline-none focus:ring-2 focus:ring-offset-2 transition-all duration-150 ease-in-out text-sm font-semibold shadow-sm active:scale-95; }
        /* Save/Load Button Style */
        .save-load-btn { @apply px-3 py-1 text-sm text-white rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-offset-1 transition-all duration-150 ease-in-out active:scale-95; }

        /* Style for span elements used as read-only displays */
        .readonly-display {
            @apply inline-block font-medium text-gray-800 min-h-[42px] px-2 py-2 w-full bg-gray-50 rounded-md border border-gray-200;
            line-height: 1.5; /* Vertically center text */
            word-break: break-all; /* Prevent layout breaks */
        }

        /* Equation Display Styles */
        .equation-number {
            @apply font-semibold text-blue-600 hover:text-blue-800 underline transition-colors duration-150;
            cursor: pointer;
        }
        .equation-number:hover {
             text-shadow: 0 0 8px rgba(147, 197, 253, 0.8); /* blue-300 with alpha */
        }
        .equation-operator { @apply text-gray-600 mx-1; }
        .equation-group { @apply mx-0.5; }

        /* Animation for pulsing the source input linked from equation */
        .animate-pulse-source {
            animation: pulse-source-input 0.8s ease-out;
        }

        /* *** NEW: Attack Button Active State *** */
        .attack-btn.active {
            @apply ring-2 ring-offset-2 scale-105 brightness-110; /* Add ring, slightly enlarge, and brighten */
        }
        #super-attack-btn.active {
            @apply ring-blue-600 bg-blue-700; /* Specific active style for super */
        }
        #ultimate-attack-btn.active {
            @apply ring-purple-600 bg-purple-700; /* Specific active style for ultimate */
        }
        /* End New CSS */

    </style>
</head>
<body class="p-4 md:p-6">

    <div class="mb-4 flex gap-2">
        <button id="save-state-btn" class="save-load-btn bg-blue-500 hover:bg-blue-600 focus:ring-blue-400">Save State</button>
        <button id="load-state-btn" class="save-load-btn bg-gray-500 hover:bg-gray-600 focus:ring-gray-400">Load State</button>
        <button id="clear-state-btn" class="save-load-btn bg-red-500 hover:bg-red-600 focus:ring-red-400">Clear Saved</button>
    </div>
    <h1 class="text-3xl font-bold mb-6 text-center text-gray-800">Energy Calculator</h1>

    <div class="flex flex-col md:flex-row gap-6 max-w-7xl mx-auto">

        <div class="flex-grow md:w-3/4">

            <div id="message-area" class="mb-4 p-3 rounded-md text-sm hidden" role="alert"></div>

            <div class="energy-pool bg-white p-5 mb-5 rounded-lg shadow-sm border-l-4 border-gray-400">
                 <h3 class="text-xl font-semibold mb-4 flex items-center">
                     Damage Modifiers
                     <span class="flex-grow h-px bg-gray-200 ml-3"></span> </h3>
                 <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                     <div><label for="base-damage" class="lbl">Base Damage:</label><input type="text" id="base-damage" placeholder="e.g., 100" aria-required="true" class="inpt focus:ring-success"></div>
                     <div><label for="attack-compression-points" class="lbl">Attack Compression Points:</label><input type="text" id="attack-compression-points" placeholder="e.g., 10" value="0" class="inpt focus:ring-red-500"></div>
                     <div><label for="base-multiplier" class="lbl">Base Multiplier:</label><input type="text" id="base-multiplier" placeholder="e.g., 1.5" value="1" class="inpt focus:ring-success"></div>
                     <div><label for="form-multiplier" class="lbl">Form Multiplier:</label><input type="text" id="form-multiplier" placeholder="e.g., 2" value="1" class="inpt focus:ring-success"></div>
                 </div>
                 <div id="dynamic-modifiers-container" class="mb-4"><h4 class="text-md font-semibold mb-2 text-gray-700">Additional Factors:</h4></div>
                 <button id="add-dynamic-box" aria-label="Add modifier factor" class="px-4 py-2 bg-chakra text-white rounded-md hover:bg-chakra-dark focus:outline-none focus:ring-2 focus:ring-chakra focus:ring-offset-2 transition-all duration-150 ease-in-out text-sm font-semibold shadow-sm active:scale-95">
                     Add Factor
                 </button>
            </div>

            <div class="form-group mb-5">
                 <label for="energy-type" class="lbl">Energy Type:</label>
                 <select id="energy-type" aria-label="Select energy type" class="w-full p-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-success focus:border-transparent text-sm bg-white">
                     <option value="ki">Ki Energy</option>
                     <option value="nen">Nen Energy</option>
                     <option value="chakra">Chakra Energy</option>
                     <option value="magic">Magic Energy</option>
                     <option value="cursed">Cursed Energy</option>
                     <option value="reiatsu">Reiatsu</option>
                     <option value="haki">Haki</option>
                     <option value="alchemy">Alchemy</option>
                     <option value="nature">Nature Energy</option>
                     <option value="force">Force Energy</option>
                 </select>
            </div>

            <div id="energy-pools-container" class="mb-5">
                 </div>

            <div id="attacks-section" class="bg-white p-5 mb-5 rounded-lg shadow-sm">
                <h3 class="text-xl font-semibold mb-4 text-gray-700 border-b pb-2">Attacks</h3>
                <div class="flex flex-col sm:flex-row gap-3">
                     <button id="super-attack-btn" data-attack-type="super" data-reserve-percent="5" class="attack-btn flex-1 px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-400 focus:ring-offset-2 transition-all duration-150 ease-in-out text-sm font-semibold shadow-sm active:scale-95">
                         Super Attack (Reserves 5%)
                     </button>
                     <button id="ultimate-attack-btn" data-attack-type="ultimate" data-reserve-percent="10" class="attack-btn flex-1 px-4 py-2 bg-purple-500 text-white rounded-md hover:bg-purple-600 focus:outline-none focus:ring-2 focus:ring-purple-400 focus:ring-offset-2 transition-all duration-150 ease-in-out text-sm font-semibold shadow-sm active:scale-95">
                         Ultimate Attack (Reserves 10%)
                     </button>
                </div>
                <p id="attack-status-message" class="text-xs text-gray-500 mt-2 min-h-[1.25rem]"></p>
            </div>
            <div id="all-sliders-container" class="bg-white p-5 mb-5 rounded-lg shadow-sm">
                <h3 class="text-xl font-semibold mb-4 text-gray-700 border-b pb-2">Energy Usage Sliders</h3>
                <div id="sliders-grid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-x-6 gap-y-4">
                     </div>
            </div>

            <button id="calculate-btn" aria-label="Calculate final damage value" class="w-full px-4 py-3 bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 transition-all duration-150 ease-in-out text-lg font-semibold shadow-md mb-5 active:scale-95">
                Calculate Damage
            </button>
            <div id="loading" class="loading text-center p-5 hidden">
                 <div class="loading-spinner inline-block w-8 h-8 border-4 border-t-success border-gray-200 rounded-full animate-spin" aria-hidden="true"></div>
                 <div class="loading-text mt-2 text-gray-600">Calculating...</div><span class="sr-only">Loading, please wait</span>
             </div>
            <div id="result" class="result bg-success-light p-5 rounded-lg border-l-4 border-success shadow-sm hidden" aria-live="polite">
                <div class="result-title text-lg font-semibold mb-2 text-success-dark">Calculated Damage:</div>
                <div id="result-value" class="result-value text-3xl font-bold mb-3 break-words">0</div>
                <div id="result-details" class="result-details text-sm text-gray-700 mt-3 border-t border-success/30 pt-3">
                    <p><strong>Total Energy Used:</strong> <span id="result-total-energy-used">0</span></p>
                    <p><strong>Total Extra Damage from Energy:</strong> <span id="result-total-extra-damage">0.00</span></p>
                    <div class="mt-3 pt-3 border-t border-success/20">
                        <p class="font-semibold mb-1">Calculation:</p>
                        <div id="equation-display" class="text-sm bg-gray-50 p-2 rounded border border-gray-200 break-words leading-relaxed">
                             Equation not yet calculated.
                        </div>
                    </div>
                    <hr class="my-2 border-success/20"> <p><strong>Scientific Notation:</strong> <span id="result-scientific">0</span></p>
                    <p><strong>In Words:</strong> <span id="result-words">Zero</span></p>
                </div>
             </div>

        </div> <div id="stats-panel" class="stats-panel md:w-1/4 lg:w-1/5 p-5 bg-white rounded-lg shadow-sm self-start sticky top-6 border-stats-border">
             <h3 id="stats-panel-header" class="stats-panel-header text-xl font-semibold mb-4 flex items-center text-stats-header">
                 Stats
                 <span class="flex-grow h-px bg-gray-200 ml-3"></span> </h3>
             <div class="space-y-3">
                 <p class="text-sm text-gray-600">Selected Current Energy: <span id="stat-current-energy" class="font-medium text-gray-800 break-words">0</span></p>
                 <hr class="border-gray-200">
                 <p class="text-sm text-gray-600">Total Damage Dealt: <span id="stat-total-damage" class="font-medium text-gray-800 break-words">0</span></p>
                 <p class="text-sm text-gray-600">Total Energy Spent: <span id="stat-total-energy-spent" class="font-medium text-gray-800 break-words">0</span></p>
                 <p class="text-sm text-gray-600">Highest Damage: <span id="stat-highest-damage" class="font-medium text-gray-800 break-words">0</span></p>
                 <div class="flex items-center justify-between text-sm text-gray-600">
                     <span>Number of Attacks: <span id="stat-attack-count" class="font-medium text-gray-800 break-words">0</span></span>
                     <button id="reset-attack-count-btn" title="Reset Attack Count" class="px-2 py-0.5 text-xs bg-gray-200 hover:bg-red-200 text-gray-600 hover:text-red-700 rounded focus:outline-none focus:ring-1 focus:ring-red-400 focus:ring-offset-1 transition-colors duration-150 active:scale-95">
                         Reset?
                     </button>
                 </div>
                 <div id="kaioken-section" class="hidden pt-3 border-t border-gray-200">
                     <div class="flex items-center gap-2 mb-3">
                         <input type="checkbox" id="kaioken-checkbox" class="rounded border-gray-300 text-red-600 shadow-sm focus:ring-kaioken-focus">
                         <label for="kaioken-checkbox" class="text-sm font-medium text-kaioken-header">Kaioken?</label>
                     </div>
                     <div id="kaioken-details" class="hidden space-y-2">
                         <div class="flex items-center gap-2">
                             <div class="flex-grow">
                                 <label for="max-health" class="lbl">Max Health:</label>
                                 <input type="text" id="max-health" placeholder="e.g., 1000" value="1000" class="inpt focus:ring-kaioken-focus">
                             </div>
                             <button id="regen-health-btn" title="Regenerate Health to Max" class="px-2 py-1 text-xs bg-success hover:bg-success-dark text-white rounded-md focus:outline-none focus:ring-2 focus:ring-success focus:ring-offset-1 self-end mb-1 transition-transform active:scale-95">Regen Health</button>
                         </div>
                         <div><label for="kaioken-strain" class="lbl">Kaioken Strain (% Max HP):</label><input type="text" id="kaioken-strain" placeholder="e.g., 10" value="10" class="inpt focus:ring-kaioken-focus"></div>
                         <div>
                             <label class="lbl">Current Health:</label>
                             <span id="current-health" class="readonly-display current-health">1000</span>
                         </div>
                     </div>
                 </div>
             </div>
         </div> </div> <template id="energy-pool-template">
         <div class="energy-pool bg-gradient-to-br from-white p-5 mb-5 rounded-lg shadow-sm border-l-4" style="display: none;">
             <h3 class="text-xl font-semibold mb-4 flex items-center">
                 <span class="pool-title">Energy Pool Title</span>
                 <span class="flex-grow h-px bg-gray-200 ml-3"></span>
             </h3>
             <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                 <div><label class="lbl max-energy-label" for="">Max Energy:</label><input type="text" value="1000" class="inpt max-energy"></div>
                 <div><label class="lbl max-multiplier-label" for="">Max Energy Multiplier:</label><input type="text" value="1" class="inpt max-multiplier"></div>
                 <div>
                     <label class="lbl total-energy-label" for="">Total Energy (Calculated):</label>
                     <span class="readonly-display total-energy">0</span>
                 </div>
                 <div>
                     <label class="lbl current-energy-label" for="">Current Energy:</label>
                     <span class="readonly-display current-energy">0</span>
                 </div>
                 <div><label class="lbl damage-per-power-label" for="">Damage per Energy Point:</label><input type="text" value="1" class="inpt damage-per-power"></div>
                 <div>
                     <label class="lbl regen-percent-label" for="">Regeneration Rate (% of Max):</label>
                     <div class="flex items-center gap-2">
                         <input type="text" placeholder="e.g., 10" class="flex-grow p-2 border border-gray-300 rounded-md focus:ring-2 focus:border-transparent text-sm regen-percent">
                         <button class="regen-btn bg-success hover:bg-success-dark focus:ring-success px-3 py-2 text-white rounded-md focus:outline-none focus:ring-2 focus:ring-offset-2 transition-all duration-150 ease-in-out text-sm font-semibold shadow-sm active:scale-95">Regen</button>
                     </div>
                 </div>
             </div>
         </div>
     </template>

     <template id="energy-slider-template">
          <div class="energy-slider-section hidden">
               <label class="lbl text-sm slider-label" for="">Energy Used (%):</label>
               <input type="range" class="energy-slider w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer" min="0" max="100" value="0">
               <div class="flex justify-between text-xs text-gray-500 px-1"><span>0%</span><span>50%</span><span>100%</span></div>
               <div class="energy-slider-value-display flex justify-between items-center text-xs bg-gray-100 text-gray-700 p-1 rounded-md min-h-[2.5rem]">
                   <span class="slider-percent-value">0%</span>
                   <span class="slider-details-value text-right">(E: 0, D: 0.00)</span>
               </div>
          </div>
     </template>


    <script>
        // --- DOM Element References ---
        // Get references to frequently used DOM elements for performance.
        const energyTypeSelect = document.getElementById('energy-type');
        const energyPoolsContainer = document.getElementById('energy-pools-container');
        const slidersGrid = document.getElementById('sliders-grid');
        const energyPoolTemplate = document.getElementById('energy-pool-template');
        const energySliderTemplate = document.getElementById('energy-slider-template');
        const calculateBtn = document.getElementById('calculate-btn');
        const resultDiv = document.getElementById('result');
        const resultValueEl = document.getElementById('result-value');
        const resultTotalEnergyUsedEl = document.getElementById('result-total-energy-used');
        const resultTotalExtraDamageEl = document.getElementById('result-total-extra-damage');
        const resultScientificEl = document.getElementById('result-scientific');
        const resultWordsEl = document.getElementById('result-words');
        const equationDisplayEl = document.getElementById('equation-display');
        const loadingDiv = document.getElementById('loading');
        const messageArea = document.getElementById('message-area');
        const dynamicModifiersContainer = document.getElementById('dynamic-modifiers-container');
        const addDynamicBoxBtn = document.getElementById('add-dynamic-box');
        const baseDamageInput = document.getElementById('base-damage');
        const baseMultiplierInput = document.getElementById('base-multiplier');
        const formMultiplierInput = document.getElementById('form-multiplier');
        const attackCompressionPointsInput = document.getElementById('attack-compression-points');
        const statsPanel = document.getElementById('stats-panel');
        const statsPanelHeader = document.getElementById('stats-panel-header');
        const statCurrentEnergyEl = document.getElementById('stat-current-energy');
        const statTotalDamageEl = document.getElementById('stat-total-damage');
        const statTotalEnergySpentEl = document.getElementById('stat-total-energy-spent');
        const statAttackCountEl = document.getElementById('stat-attack-count');
        const statHighestDamageEl = document.getElementById('stat-highest-damage');
        const resetAttackCountBtn = document.getElementById('reset-attack-count-btn');
        const kaiokenSection = document.getElementById('kaioken-section');
        const kaiokenCheckbox = document.getElementById('kaioken-checkbox');
        const kaiokenDetails = document.getElementById('kaioken-details');
        const maxHealthInput = document.getElementById('max-health');
        const kaiokenStrainInput = document.getElementById('kaioken-strain');
        const currentHealthEl = document.getElementById('current-health');
        const regenHealthBtn = document.getElementById('regen-health-btn');
        const saveBtn = document.getElementById('save-state-btn');
        const loadBtn = document.getElementById('load-state-btn');
        const clearBtn = document.getElementById('clear-state-btn');
        // *** NEW References for Attack Section ***
        const superAttackBtn = document.getElementById('super-attack-btn');
        const ultimateAttackBtn = document.getElementById('ultimate-attack-btn');
        const attackStatusMessage = document.getElementById('attack-status-message');

        // --- Global State & Constants ---
        // Variables to store cumulative statistics.
        let totalDamageDealt = 0, totalEnergySpent = 0, attackCount = 0, highestDamage = 0;
        // Key for saving/loading state in localStorage.
        const LOCAL_STORAGE_KEY = 'energyCalculatorState_v1';
        // Timeout ID for managing energy pool glow animations.
        let poolAnimationTimeoutId = null;
        // List of all available energy types.
        const ALL_ENERGY_TYPES = ['ki', 'nen', 'chakra', 'magic', 'cursed', 'reiatsu', 'haki', 'alchemy', 'nature', 'force'];
        // Counter for generating unique IDs for dynamic modifiers.
        let dynamicModifierCount = 0;
        // *** NEW State/Constants for Attacks ***
        // Object to store the active attack state ('super', 'ultimate', or null) for each energy type.
        let activeAttacks = {};
        // Colors used for the slider track gradient when an attack is active.
        const ATTACK_RESERVE_COLOR = '#fed7aa'; // Tailwind orange-200
        const SLIDER_TRACK_COLOR = '#e5e7eb'; // Tailwind gray-200


        // Map containing details (name, colors, styles) for each energy type. Used for dynamic UI updates.
        const ENERGY_TYPE_DETAILS = {
            ki:      { name: 'Ki',      color: 'ki',      colorDark: 'ki-dark',      gradientTo: 'to-orange-100', focusRing: 'focus:ring-ki-focus',      staticGlow: 'static-glow-ki',      pulseGlow: 'animate-pulse-glow-ki',      border: 'border-l-ki' },
            nen:      { name: 'Nen',     color: 'nen',     colorDark: 'nen-dark',     gradientTo: 'to-blue-100',   focusRing: 'focus:ring-nen-focus',     staticGlow: 'static-glow-nen',     pulseGlow: 'animate-pulse-glow-nen',     border: 'border-l-nen' },
            chakra:   { name: 'Chakra',  color: 'chakra',  colorDark: 'chakra-dark',  gradientTo: 'to-purple-100', focusRing: 'focus:ring-chakra-focus',  staticGlow: 'static-glow-chakra',  pulseGlow: 'animate-pulse-glow-chakra',  border: 'border-l-chakra' },
            magic:    { name: 'Magic',   color: 'magic',   colorDark: 'magic-dark',   gradientTo: 'to-teal-100',   focusRing: 'focus:ring-magic-focus',   staticGlow: 'static-glow-magic',   pulseGlow: 'animate-pulse-glow-magic',   border: 'border-l-magic' },
            cursed:   { name: 'Cursed',  color: 'cursed',  colorDark: 'cursed-dark',  gradientTo: 'to-red-100',    focusRing: 'focus:ring-cursed-focus',  staticGlow: 'static-glow-cursed',  pulseGlow: 'animate-pulse-glow-cursed',  border: 'border-l-cursed' },
            reiatsu: { name: 'Reiatsu', color: 'reiatsu', colorDark: 'reiatsu-dark', gradientTo: 'to-slate-100',  focusRing: 'focus:ring-reiatsu-focus', staticGlow: 'static-glow-reiatsu', pulseGlow: 'animate-pulse-glow-reiatsu', border: 'border-l-reiatsu' },
            haki:     { name: 'Haki',    color: 'haki',    colorDark: 'haki-dark',    gradientTo: 'to-gray-100',   focusRing: 'focus:ring-haki-focus',    staticGlow: 'static-glow-haki',    pulseGlow: 'animate-pulse-glow-haki',    border: 'border-l-haki' },
            alchemy: { name: 'Alchemy', color: 'alchemy', colorDark: 'alchemy-dark', gradientTo: 'to-amber-100',  focusRing: 'focus:ring-alchemy-focus', staticGlow: 'static-glow-alchemy', pulseGlow: 'animate-pulse-glow-alchemy', border: 'border-l-alchemy' },
            nature:   { name: 'Nature',  color: 'nature',  colorDark: 'nature-dark',  gradientTo: 'to-lime-100',   focusRing: 'focus:ring-nature-focus',  staticGlow: 'static-glow-nature',  pulseGlow: 'animate-pulse-glow-nature',  border: 'border-l-nature' },
            force:    { name: 'Force',   color: 'force',   colorDark: 'force-dark',   gradientTo: 'to-fuchsia-100',focusRing: 'focus:ring-force-focus',   staticGlow: 'static-glow-force',   pulseGlow: 'animate-pulse-glow-force',   border: 'border-l-force' },
        };

        // --- Utility Functions ---

        /**
         * Safely parses a value to a float, handling potential errors and non-numeric inputs.
         * Removes commas before parsing.
         * @param {*} value - The value to parse.
         * @param {number} [defaultValue=0] - The value to return on failure.
         * @returns {number} The parsed float or the default value.
         */
        function safeParseFloat(value, defaultValue = 0) {
            if (typeof value !== 'string' && typeof value !== 'number') return defaultValue;
            // Remove commas for robust parsing (e.g., "1,000")
            const num = parseFloat(String(value).replace(/,/g, ''));
            return isNaN(num) ? defaultValue : num;
        }

        /**
         * Formats a number into a locale-aware string with commas and a maximum of 2 decimal places.
         * Provides a fallback for extremely large numbers that might cause issues with toLocaleString.
         * @param {number} num - The number to format.
         * @returns {string} The formatted number string or '0'.
         */
        function formatSimpleNumber(num) {
            if (typeof num !== 'number' || isNaN(num)) return '0';
            try {
                const options = { maximumFractionDigits: 2 };
                return num.toLocaleString('en-US', options);
            } catch (e) {
                // Fallback for very large numbers
                return num.toString();
            }
        }

        /**
         * Displays a temporary feedback message to the user.
         * Applies appropriate styling (info, success, error) and animations.
         * @param {string} text - The message text.
         * @param {'info'|'success'|'error'} [type='info'] - The message type.
         */
        function showMessage(text, type = 'info') {
            messageArea.textContent = text;
            // Reset classes and apply base + animation class
            messageArea.className = 'mb-4 p-3 rounded-md text-sm border animate__animated';
            messageArea.classList.remove('hidden', 'animate__fadeIn', 'animate__shakeX'); // Clear previous animations

            let animationClass = 'animate__fadeIn'; // Default animation
            // Apply type-specific background, text, border colors and animation
            switch (type) {
                case 'error':
                    messageArea.classList.add('bg-error-light', 'text-error-dark', 'border-error');
                    animationClass = 'animate__shakeX'; // Use shake for errors
                    break;
                case 'success':
                    messageArea.classList.add('bg-success-light', 'text-success-dark', 'border-success');
                    break;
                default: // info
                    messageArea.classList.add('bg-blue-100', 'text-blue-800', 'border-blue-300');
                    break;
            }
            messageArea.classList.add(animationClass); // Add the chosen animation

            // Clean up animation classes after completion to allow re-triggering
             messageArea.addEventListener('animationend', () => {
                  messageArea.classList.remove('animate__animated', animationClass);
             }, { once: true });

            // Automatically hide the message after 5 seconds
            setTimeout(() => {
                 messageArea.classList.add('hidden');
            }, 5000);
        }

        /**
         * Toggles the visibility of the loading indicator and enables/disables the calculate button.
         * @param {boolean} isLoading - True to show loading, false to hide.
         */
        function showLoading(isLoading) {
            loadingDiv.classList.toggle('hidden', !isLoading);
            if(isLoading) resultDiv.classList.add('hidden'); // Hide results while loading
            // Disable/enable button and adjust appearance
            calculateBtn.disabled = isLoading;
            calculateBtn.classList.toggle('opacity-50', isLoading);
            calculateBtn.classList.toggle('cursor-not-allowed', isLoading);
        }

        /**
         * Applies a one-time CSS animation to an element using Animate.css classes.
         * @param {HTMLElement} element - The DOM element to animate.
         * @param {string} animationClass - The Animate.css class name (e.g., 'animate__pulse').
         * @param {number} [duration=800] - Optional duration (mainly for reference).
         */
        function triggerAnimation(element, animationClass, duration = 800) {
            if (!element) return; // Guard against missing elements
            const animateCSSBase = 'animate__animated';
            const classesToAdd = [animateCSSBase, animationClass];

            // Remove classes first to allow re-triggering the animation
            element.classList.remove(...classesToAdd);
            // Force reflow/repaint is necessary for re-triggering animations reliably
            void element.offsetWidth;
            // Add animation classes
            element.classList.add(...classesToAdd);

            // Remove animation classes once finished to clean up the element's state
            element.addEventListener('animationend', () => {
                element.classList.remove(...classesToAdd);
            }, { once: true }); // Use {once: true} for automatic listener removal
        }


        /**
         * Formats large numbers for display in the stats panel, using abbreviations (K, M)
         * up to billions, and scientific notation for larger values. Handles decimals appropriately.
         * @param {number} num - The number to format.
         * @returns {string} The formatted number string.
         */
        function formatStatNumber(num) {
            if (typeof num !== 'number' || isNaN(num)) return '0';
            const absNum = Math.abs(num);

            if (absNum >= 1e9) { // Billions or more: use scientific notation
                return num.toExponential(2);
            }
            if (absNum >= 1e6) { // Millions: use 'M' suffix
                let shortNum = num / 1e6;
                // Use more decimal places for smaller millions (e.g., 1.23M vs 12.3M)
                let formatted = shortNum.toLocaleString('en-US', {
                    minimumFractionDigits: absNum < 10e6 ? 2 : 1,
                    maximumFractionDigits: absNum < 10e6 ? 2 : 1
                });
                formatted = formatted.replace(/\.0$/, ''); // Remove trailing '.0'
                return formatted + 'M';
            }
            if (absNum >= 1e3) { // Thousands: use 'K' suffix
                let shortNum = num / 1e3;
                // Use more decimal places for smaller thousands (e.g., 1.23K vs 12.3K)
                let formatted = shortNum.toLocaleString('en-US', {
                    minimumFractionDigits: absNum < 10e3 ? 2 : 1,
                    maximumFractionDigits: absNum < 10e3 ? 2 : 1
                });
                formatted = formatted.replace(/\.0$/, ''); // Remove trailing '.0'
                return formatted + 'K';
            }
             if (absNum < 1000) { // Less than 1000: standard formatting with max 2 decimals
                  return num.toLocaleString('en-US', { maximumFractionDigits: 2 });
             }
             // Fallback for any edge cases
            return num.toLocaleString('en-US');
        }

        /**
         * Parses potentially formatted number strings (with commas, K/M/B/T/Q suffixes, or scientific notation)
         * back into numerical values. Essential for reading values from inputs or display elements.
         * @param {string|number} str - The formatted string or number to parse.
         * @returns {number} The parsed number or 0 if invalid.
         */
        function parseFormattedNumber(str) {
            // Handle direct number input or invalid types
            if (typeof str !== 'string' && typeof str !== 'number') return 0;
            if (typeof str === 'number') return isNaN(str) ? 0 : str;

            // Standardize input: remove commas, convert to uppercase for suffix matching
            str = str.trim().toUpperCase().replace(/,/g, '');

            // Handle scientific notation (e.g., 1.23E+9)
            if (str.includes('E')) {
                const num = parseFloat(str);
                return isNaN(num) ? 0 : num;
            }

            // Check for suffixes (K, M, B, T, Q)
            const lastChar = str.slice(-1);
            const numPart = parseFloat(str.slice(0, -1)); // Number part before suffix
            const fullNum = parseFloat(str); // Try parsing the whole string

            // If it's a plain number without a recognized suffix
            if (!isNaN(fullNum) && !['K', 'M', 'B', 'T', 'Q'].includes(lastChar)) {
                return fullNum;
            }
            // If it has a suffix but the number part is invalid (e.g., "KM")
            if (isNaN(numPart) && ['K', 'M', 'B', 'T', 'Q'].includes(lastChar)) return 0;

            // Apply multiplier based on suffix
            switch (lastChar) {
                case 'K': return numPart * 1e3;  // Thousand
                case 'M': return numPart * 1e6;  // Million
                case 'B': return numPart * 1e9;  // Billion
                case 'T': return numPart * 1e12; // Trillion
                case 'Q': return numPart * 1e15; // Quadrillion
                // Add more suffixes (Quintillion, etc.) if needed
                default: return isNaN(fullNum) ? 0 : fullNum; // Fallback: treat as plain number if no valid suffix
            }
        }

         /**
          * Escapes special HTML characters in a string to prevent XSS vulnerabilities
          * when inserting user-provided text (like modifier names) into innerHTML.
          * @param {string} unsafe - The potentially unsafe string.
          * @returns {string} The HTML-escaped string.
          */
         function escapeHtml(unsafe) {
              if (typeof unsafe !== 'string') return '';
              // Replace special characters with their HTML entities
              return unsafe
                   .replace(/&/g, "&amp;")
                   .replace(/</g, "&lt;")
                   .replace(/>/g, "&gt;")
                   .replace(/"/g, "&quot;")
                   .replace(/'/g, "&#039;");
         }


        // --- Energy Pool Logic ---

        /**
         * Retrieves references to all relevant DOM elements associated with a specific energy type.
         * @param {string} type - The energy type key (e.g., 'ki', 'nen').
         * @returns {object|null} An object containing references, or null if the type is invalid.
         */
        function getEnergyElements(type) {
            if (!ALL_ENERGY_TYPES.includes(type)) {
                console.error("Invalid energy type requested:", type);
                return null;
            }
            // Return an object mapping logical names to the actual DOM elements
            return {
                poolDiv: document.getElementById(`${type}-pool`),
                maxEnergyEl: document.getElementById(`${type}-max-energy`),
                maxMultiplierEl: document.getElementById(`${type}-max-multiplier`),
                totalEnergyEl: document.getElementById(`${type}-total-energy`), // Span for display
                currentEnergyEl: document.getElementById(`${type}-current-energy`), // Span for display
                damagePerPowerEl: document.getElementById(`${type}-damage-per-power`),
                regenPercentEl: document.getElementById(`${type}-regen-percent`),
                sliderSection: document.getElementById(`${type}-slider-section`),
                energySlider: document.getElementById(`${type}-energy-slider`),
                sliderValueDisplay: document.getElementById(`${type}-slider-value-display`) // Container for slider text
            };
        }

         /**
          * Shows or hides the energy slider section for a given type based on whether
          * the calculated total energy for that pool is greater than zero.
          * Resets the slider value to 0 if the slider is hidden.
          * @param {string} type - The energy type key.
          */
         function updateSliderVisibility(type) {
              const els = getEnergyElements(type);
              if (els?.totalEnergyEl && els.sliderSection) {
                  // Parse the displayed total energy to check if it's positive
                  const totalEnergy = parseFormattedNumber(els.totalEnergyEl.textContent);
                  const shouldShow = totalEnergy > 0;
                  // Toggle the 'hidden' class based on the condition
                  els.sliderSection.classList.toggle('hidden', !shouldShow);
                  // If hiding the slider, reset its value and update its display text
                  if (!shouldShow && els.energySlider) {
                      els.energySlider.value = 0;
                      updateSingleSliderDisplay(type); // Refresh display after reset
                  }
              }
         }

         /**
          * Recalculates the total energy (Max Energy * Multiplier) for a pool,
          * resets the current energy to this new total, and updates the UI displays.
          * @param {string} type - The energy type key.
          * @returns {number} The calculated total energy.
          */
         function calculateAndResetEnergy(type) {
              const els = getEnergyElements(type);
              if (!els?.maxEnergyEl || !els?.maxMultiplierEl || !els?.totalEnergyEl || !els?.currentEnergyEl) {
                  console.error(`Elements missing for energy reset: ${type}`);
                  return 0;
              }
              // Read and parse input values
              const maxEnergy = safeParseFloat(els.maxEnergyEl.value, 0);
              const multiplier = safeParseFloat(els.maxMultiplierEl.value, 1);
              const totalEnergy = maxEnergy * multiplier;

              // Update display elements using the stat formatter
              els.totalEnergyEl.textContent = formatStatNumber(totalEnergy);
              els.currentEnergyEl.textContent = formatStatNumber(totalEnergy); // Reset current to new max

              // Update slider visibility and display based on the new total
              updateSliderVisibility(type);
              updateSingleSliderDisplay(type);
              return totalEnergy;
         }

         /**
          * Regenerates energy for a specific pool based on its regeneration percentage input.
          * Adds the regenerated amount to the current energy, capped at the total energy.
          * Updates the UI and shows a feedback message.
          * @param {string} type - The energy type key.
          */
         function regenerateEnergy(type) {
              const els = getEnergyElements(type);
              if (!els?.totalEnergyEl || !els?.currentEnergyEl || !els?.regenPercentEl) {
                  console.error(`Elements missing for energy regeneration: ${type}`);
                  return;
              }
              // Parse displayed values
              const totalEnergy = parseFormattedNumber(els.totalEnergyEl.textContent);
              let currentEnergy = parseFormattedNumber(els.currentEnergyEl.textContent);
              const regenPercent = safeParseFloat(els.regenPercentEl.value, 0);

              // Validate inputs
              if (totalEnergy <= 0) {
                  showMessage('Max Energy must be positive to regenerate.', 'error');
                  return;
              }
              if (regenPercent <= 0) {
                  showMessage('Regen Rate must be positive.', 'error');
                  return;
              }

              // Calculate regeneration amount and new energy level
              const regenAmount = totalEnergy * (regenPercent / 100);
              let newEnergy = Math.min(currentEnergy + regenAmount, totalEnergy); // Cap at total
              // Update display
              els.currentEnergyEl.textContent = formatStatNumber(newEnergy);

              // Provide feedback
              showMessage(`${formatStatNumber(regenAmount)} ${type} regenerated. Current: ${formatStatNumber(newEnergy)}`, 'success');
              triggerAnimation(els.currentEnergyEl, 'animate-flash-green'); // Visual feedback

              // Update related UI elements
              updateSingleSliderDisplay(type); // Refresh slider text
              updateStatsDisplay(); // Update stats panel
         }


        // --- Kaioken Styling ---

        /** Applies visual styles (border, glow, header color) to the stats panel when Kaioken is active. */
        function applyKaiokenStyle() {
            if (!statsPanel || !statsPanelHeader) return;
            statsPanel.classList.remove('border-stats-border'); // Remove default blue border
            statsPanel.classList.add('border-kaioken-border', 'animate-kaioken-glow'); // Add red border + glow
            statsPanelHeader.classList.remove('text-stats-header'); // Remove default blue header text
            statsPanelHeader.classList.add('text-kaioken-header'); // Add red header text
        }

        /** Removes Kaioken-specific visual styles and restores default stats panel appearance. */
        function removeKaiokenStyle() {
            if (!statsPanel || !statsPanelHeader) return;
            statsPanel.classList.add('border-stats-border'); // Restore default blue border
            statsPanel.classList.remove('border-kaioken-border', 'animate-kaioken-glow'); // Remove red border + glow
            statsPanelHeader.classList.add('text-stats-header'); // Restore default blue header text
            statsPanelHeader.classList.remove('text-kaioken-header'); // Remove red header text
        }

        // --- Health Update ---

         /**
          * Updates the displayed current health value. Ensures it doesn't exceed max health.
          * Resets health to max if Kaioken is activated or if current health is invalid/zero/over max.
          */
         function updateCurrentHealthDisplay() {
              if (!currentHealthEl || !maxHealthInput) return;

              const maxHealth = safeParseFloat(maxHealthInput.value, 0);
              let currentHealth = parseFormattedNumber(currentHealthEl.textContent); // Parse displayed value

              // Reset health to max if:
              // 1. Kaioken is active for Ki energy OR
              // 2. Current health is invalid (-1 from parsing error) OR
              // 3. Current health exceeds max health OR
              // 4. Display is empty or "0"
              if ((energyTypeSelect.value === 'ki' && kaiokenCheckbox.checked) || currentHealth === -1 || currentHealth > maxHealth || currentHealthEl.textContent.trim() === '' || currentHealthEl.textContent === '0') {
                  currentHealthEl.textContent = formatStatNumber(maxHealth); // Set display to formatted max health
              }
              // Otherwise, the valid current health value persists.
         }

         /**
          * Resets the current health display to the maximum health value entered.
          * Called by the "Regen Health" button.
          */
         function regenerateHealth() {
              if (!maxHealthInput || !currentHealthEl) {
                  console.error("Health elements missing for regeneration.");
                  return;
              }
              const maxHealth = safeParseFloat(maxHealthInput.value, 0);
              // Update display to formatted max health
              currentHealthEl.textContent = formatStatNumber(maxHealth);
              // Provide feedback
              showMessage('Health fully regenerated!', 'success');
              triggerAnimation(currentHealthEl, 'animate-flash-green'); // Visual feedback
         }


        // --- Show/Hide Logic & Pool Animation ---

        /**
         * Manages the visibility and animations of energy pool sections based on the dropdown selection.
         * Handles showing/hiding the Kaioken section.
         * Updates attack button states and slider limits for the selected pool.
         */
        function showSelectedEnergyPool() {
            const selectedType = energyTypeSelect.value; // Get currently selected type
            const details = ENERGY_TYPE_DETAILS[selectedType]; // Get details (colors, etc.) for this type
            let newlyVisiblePool = null; // Reference to the pool being shown

            // Clear any pending animation timeout for pool glow effects
            if (poolAnimationTimeoutId) {
                clearTimeout(poolAnimationTimeoutId);
                poolAnimationTimeoutId = null;
            }

            // Hide all energy pools first and remove animation/glow classes
            ALL_ENERGY_TYPES.forEach(type => {
                const els = getEnergyElements(type);
                const typeDetails = ENERGY_TYPE_DETAILS[type];
                if (els?.poolDiv && typeDetails) {
                    // Remove pulse/static glow and any lingering Animate.css classes
                    els.poolDiv.classList.remove(typeDetails.pulseGlow, typeDetails.staticGlow, 'animate__animated', 'animate__fadeIn');
                    // Hide the pool if it's not the one selected
                    if (type !== selectedType) {
                        els.poolDiv.style.display = 'none';
                    }
                }
            });

            // Find and show the selected pool
            const poolToShowEls = getEnergyElements(selectedType);
            if (poolToShowEls?.poolDiv && details) {
                poolToShowEls.poolDiv.style.display = 'block'; // Make it visible
                newlyVisiblePool = poolToShowEls.poolDiv;

                // Apply entrance animation (fadeIn) and initial pulse glow
                poolToShowEls.poolDiv.classList.add('animate__animated', 'animate__fadeIn');
                poolToShowEls.poolDiv.classList.add(details.pulseGlow);

                // Remove fadeIn animation class after it completes, keeping the pulse glow
                 poolToShowEls.poolDiv.addEventListener('animationend', (e) => {
                      if (e.animationName === 'fadeIn') { // Only act on the fadeIn animation
                          poolToShowEls.poolDiv.classList.remove('animate__animated', 'animate__fadeIn');
                      }
                 } , { once: true }); // Listener removes itself after firing once

                // Set a timeout to switch from pulsing glow to a static glow after 5 seconds
                poolAnimationTimeoutId = setTimeout(() => {
                    // Check if the same pool is still selected when the timeout fires
                    const currentSelectedType = energyTypeSelect.value;
                    const stillSelectedPoolEls = getEnergyElements(currentSelectedType);
                    const stillSelectedDetails = ENERGY_TYPE_DETAILS[currentSelectedType];
                    if (stillSelectedPoolEls?.poolDiv && stillSelectedDetails && currentSelectedType === selectedType) {
                        // Switch from pulse to static glow
                        stillSelectedPoolEls.poolDiv.classList.remove(stillSelectedDetails.pulseGlow);
                        stillSelectedPoolEls.poolDiv.classList.add(stillSelectedDetails.staticGlow);
                    }
                    poolAnimationTimeoutId = null; // Clear the timeout ID
                }, 5000); // 5-second delay
            }

             // Show/Hide Kaioken section based on whether 'Ki' energy is selected
             if (kaiokenSection) {
                  if (selectedType === 'ki') {
                      kaiokenSection.classList.remove('hidden'); // Show section
                      // If Kaioken checkbox is already checked, ensure details are visible and health is updated
                      if (kaiokenCheckbox.checked) {
                          kaiokenDetails.classList.remove('hidden');
                          updateCurrentHealthDisplay();
                      }
                  } else {
                      kaiokenSection.classList.add('hidden'); // Hide section for other types
                      // If switching away from Ki while Kaioken was active, deactivate it visually
                      if (kaiokenCheckbox.checked) {
                          kaiokenCheckbox.checked = false;
                          kaiokenDetails.classList.add('hidden');
                          removeKaiokenStyle(); // Remove red styling from stats panel
                      }
                  }
             }

            // --- Persist Current Energy Logic ---
            // Ensure current energy doesn't exceed the calculated total energy when switching pools
            const els = getEnergyElements(selectedType);
            if (els?.maxEnergyEl && els?.maxMultiplierEl && els?.totalEnergyEl && els?.currentEnergyEl) {
                const maxEnergy = safeParseFloat(els.maxEnergyEl.value, 0);
                const multiplier = safeParseFloat(els.maxMultiplierEl.value, 1);
                const totalEnergy = maxEnergy * multiplier;
                els.totalEnergyEl.textContent = formatStatNumber(totalEnergy); // Update total display

                let currentEnergy = parseFormattedNumber(els.currentEnergyEl.textContent); // Get current value

                // If current energy is invalid, exceeds total, or is zero/empty, reset it to total
                if (currentEnergy === -1 || currentEnergy > totalEnergy || els.currentEnergyEl.textContent.trim() === '' || els.currentEnergyEl.textContent === '0') {
                    els.currentEnergyEl.textContent = formatStatNumber(totalEnergy); // Update current display
                }
                // Otherwise, the valid current energy persists

                updateSliderVisibility(selectedType); // Update slider visibility based on total energy
                // updateSingleSliderDisplay(selectedType); // This is called by updateSliderLimitAndStyle below
            }

            // *** Update Attack Button State & Slider Limit for the newly selected pool ***
            updateAttackButtonStates(selectedType); // Update button visuals
            updateSliderLimitAndStyle(selectedType); // Apply limit/style for the slider

            updateStatsDisplay(); // Update the stats panel (shows correct current energy)
        }


         // --- Attack Logic --- (NEW SECTION)

         /**
          * Updates the visual state (active class) of the Super/Ultimate attack buttons
          * based on the active attack stored for the given energy type. Also updates the status message.
          * @param {string} type - The energy type key (e.g., 'ki').
          */
         function updateAttackButtonStates(type) {
             // Get the currently active attack for this specific energy type from the state object
             const currentAttack = activeAttacks[type] || null;

             // Toggle the 'active' class on buttons based on the state
             superAttackBtn.classList.toggle('active', currentAttack === 'super');
             ultimateAttackBtn.classList.toggle('active', currentAttack === 'ultimate');

             // Update the status message below the buttons
             if (currentAttack === 'super') {
                 attackStatusMessage.textContent = `Super Attack active for ${ENERGY_TYPE_DETAILS[type]?.name || type}. Slider limited to 95%.`;
                 // Use Tailwind colors defined in the config programmatically
                 attackStatusMessage.style.color = tailwind.theme.colors.blue[600];
             } else if (currentAttack === 'ultimate') {
                 attackStatusMessage.textContent = `Ultimate Attack active for ${ENERGY_TYPE_DETAILS[type]?.name || type}. Slider limited to 90%.`;
                  attackStatusMessage.style.color = tailwind.theme.colors.purple[600];
             } else {
                 attackStatusMessage.textContent = ''; // Clear message if no attack is active for this type
             }
         }

          /**
           * Updates the corresponding energy slider's visual style (gradient background)
           * and caps its current value based on the active attack state for the given energy type.
           * @param {string} type - The energy type key.
           */
          function updateSliderLimitAndStyle(type) {
              const els = getEnergyElements(type);
              if (!els?.energySlider) return; // Exit if slider element doesn't exist

              const slider = els.energySlider;
              const activeAttack = activeAttacks[type] || null; // Get attack state for this type
              let limitPercent = 100; // Default limit is 100%
              // Default gradient: full track color, no reserved area shown
              let gradientStyle = `linear-gradient(to right, ${SLIDER_TRACK_COLOR} 100%, ${ATTACK_RESERVE_COLOR} 100%)`;

              // Adjust limit and gradient style if an attack is active
              if (activeAttack === 'super') {
                  limitPercent = 95;
                  // Gradient: Track color up to 95%, reserved color from 95% onwards
                  gradientStyle = `linear-gradient(to right, ${SLIDER_TRACK_COLOR} ${limitPercent}%, ${ATTACK_RESERVE_COLOR} ${limitPercent}%)`;
              } else if (activeAttack === 'ultimate') {
                  limitPercent = 90;
                  // Gradient: Track color up to 90%, reserved color from 90% onwards
                  gradientStyle = `linear-gradient(to right, ${SLIDER_TRACK_COLOR} ${limitPercent}%, ${ATTACK_RESERVE_COLOR} ${limitPercent}%)`;
              }

              // Apply the calculated background gradient style directly to the slider element
              slider.style.background = gradientStyle;

              // Ensure the slider's current value doesn't exceed the calculated limit
              if (parseInt(slider.value) > limitPercent) {
                  slider.value = limitPercent; // Force the value back to the limit
              }

              // Refresh the slider's text display (E:, D:) to reflect potential value capping
              updateSingleSliderDisplay(type);
          }

          /**
           * Handles click events on the Super and Ultimate attack buttons.
           * Toggles the active attack state for the currently selected energy type.
           * Updates the UI (button states, slider limit/style).
           * @param {Event} event - The click event object.
           */
          function handleAttackButtonClick(event) {
              const button = event.currentTarget; // The button that was clicked
              const attackType = button.dataset.attackType; // 'super' or 'ultimate' from data attribute
              const selectedEnergyType = energyTypeSelect.value; // Get the currently selected energy type

              // Determine the new state:
              // - If clicking the button that's already active -> deactivate (set to null)
              // - Otherwise -> activate the clicked button's type
              const currentAttackForType = activeAttacks[selectedEnergyType] || null;
              const newAttackState = (currentAttackForType === attackType) ? null : attackType;

              // Update the global state object for this energy type
              activeAttacks[selectedEnergyType] = newAttackState;

              // Update the UI to reflect the new state for the *currently selected* type
              updateAttackButtonStates(selectedEnergyType); // Update button active classes and status message
              updateSliderLimitAndStyle(selectedEnergyType); // Update slider gradient and cap value

              // Provide visual feedback on the clicked button
              triggerAnimation(button, 'animate__pulse');
          }


        // --- Dynamic Modifiers Logic ---

        /**
         * Creates and adds a new dynamic modifier input box (for additive/multiplicative factors) to the UI.
         * Uses the #dynamic-modifier-template. Can be pre-populated with data (used during state loading).
         * @param {object|null} [modifierData=null] - Optional data { name, value, type } to pre-fill the box.
         */
        function addDynamicModifier(modifierData = null) {
            dynamicModifierCount++; // Increment unique ID counter
            const modifierId = `dynamic-modifier-${dynamicModifierCount}`;
            const newModifierDiv = document.createElement('div'); // Create container div

            // Determine initial values from provided data or defaults
            const initialType = modifierData?.type || 'additive'; // Default to additive
            const initialValue = modifierData?.value || '0';
            const initialName = modifierData?.name || '';
            const isActiveAdditive = initialType === 'additive';

            // Set classes for styling and entrance animation (Animate.css bounceIn)
            const boxClasses = `dynamic-box p-4 mt-3 border rounded-md border-l-4 relative transition-all duration-300 ease-in-out animate__animated animate__bounceIn ${isActiveAdditive ? 'additive bg-success-light border-success' : 'multiplicative bg-ki/10 border-ki'}`;
            newModifierDiv.className = boxClasses;
            newModifierDiv.id = modifierId; // Assign unique ID

            // Set the inner HTML structure of the modifier box
            newModifierDiv.innerHTML = `
                <div class="absolute top-2 right-2">
                    <button class="remove-dynamic-box bg-error text-white rounded-md shadow-sm w-6 h-6 flex items-center justify-center text-xs hover:bg-error-dark focus:outline-none focus:ring-2 focus:ring-error focus:ring-offset-1 transition-transform active:scale-95" aria-label="Remove this modifier" data-target="${modifierId}">×</button>
                </div>
                <div class="modifier-type-selector flex gap-2 mb-3 border-b pb-2">
                    <div class="modifier-type-option additive ${isActiveAdditive ? 'active' : ''} flex-1 p-2 text-center border rounded-md cursor-pointer transition-all duration-300 ease-in-out text-sm" data-value="additive" tabindex="0" role="radio" aria-checked="${isActiveAdditive}">
                        <input type="radio" name="modifier-type-${modifierId}" value="additive" class="sr-only" ${isActiveAdditive ? 'checked' : ''}> Additive (+)
                    </div>
                    <div class="modifier-type-option multiplicative ${!isActiveAdditive ? 'active' : ''} flex-1 p-2 text-center border rounded-md cursor-pointer transition-all duration-300 ease-in-out text-sm" data-value="multiplicative" tabindex="0" role="radio" aria-checked="${!isActiveAdditive}">
                        <input type="radio" name="modifier-type-${modifierId}" value="multiplicative" class="sr-only" ${!isActiveAdditive ? 'checked' : ''}> Multiplier (×)
                    </div>
                </div>
                <div class="grid grid-cols-1 sm:grid-cols-2 gap-3">
                    <div>
                        <label for="modifier-name-${modifierId}" class="lbl">Modifier Name:</label>
                        <input type="text" id="modifier-name-${modifierId}" placeholder="e.g., Buff" value="${escapeHtml(initialName)}" class="modifier-name-input w-full p-1.5 border border-gray-300 rounded-md focus:ring-1 focus:ring-success focus:border-transparent text-sm">
                    </div>
                    <div>
                        <label for="modifier-value-${modifierId}" class="lbl">Value:</label>
                        <input type="text" id="modifier-value-${modifierId}" placeholder="e.g., 50 or 1.2" value="${escapeHtml(initialValue)}" class="modifier-value-input w-full p-1.5 border border-gray-300 rounded-md focus:ring-1 focus:ring-success focus:border-transparent text-sm">
                    </div>
                </div>`;

            // Append the new box to the container
            dynamicModifiersContainer.appendChild(newModifierDiv);
            // Attach necessary event listeners to the new box's elements
            addListenersToModifierBox(newModifierDiv);

            // Remove the entrance animation class after it finishes
            newModifierDiv.addEventListener('animationend', () => {
                 newModifierDiv.classList.remove('animate__animated', 'animate__bounceIn');
            }, { once: true });
        }

        /**
         * Attaches event listeners to the elements within a newly created dynamic modifier box.
         * Handles remove button clicks, type selection changes, and input value changes.
         * @param {HTMLElement} modifierDiv - The modifier box element.
         */
        function addListenersToModifierBox(modifierDiv) {
            // Listener for the 'Remove' button
            modifierDiv.querySelector('.remove-dynamic-box')?.addEventListener('click', function() {
                const targetBox = document.getElementById(this.dataset.target); // Find the box to remove
                if (targetBox) {
                    // Apply exit animation (Animate.css bounceOut)
                    targetBox.classList.add('animate__animated', 'animate__bounceOut');
                    // Remove the element from the DOM after the animation completes
                    targetBox.addEventListener('animationend', () => {
                        targetBox.remove();
                        updateEquationDisplay(); // Update equation after removal
                    }, { once: true });
                } else {
                     updateEquationDisplay(); // Update equation even if box was already gone
                }
            });

            // Listeners for the Additive/Multiplicative type selectors
            modifierDiv.querySelectorAll('.modifier-type-option').forEach(option => {
                // Handle clicks
                option.addEventListener('click', function() {
                    const box = this.closest('.dynamic-box'); // Find the parent box
                    const value = this.dataset.value; // 'additive' or 'multiplicative'
                    // Update underlying radio buttons (for semantics/accessibility)
                    box.querySelectorAll('input[type="radio"]').forEach(radio => radio.checked = (radio.value === value));
                    // Update visual active state and ARIA attribute for all options in this box
                    box.querySelectorAll('.modifier-type-option').forEach(opt => {
                        const isActive = opt.dataset.value === value;
                        opt.classList.toggle('active', isActive);
                        opt.setAttribute('aria-checked', isActive);
                    });
                    // Update the box's border and background based on the selected type
                    box.classList.remove('additive', 'multiplicative', 'bg-success-light', 'border-success', 'bg-ki/10', 'border-ki');
                    box.classList.add(value === 'additive' ? 'additive' : 'multiplicative');
                    box.classList.add(value === 'additive' ? 'bg-success-light' : 'bg-ki/10');
                    box.classList.add(value === 'additive' ? 'border-success' : 'border-ki');
                    // Update the equation display when type changes
                    updateEquationDisplay();
                });
                // Allow selection using Enter or Space keys for accessibility
                option.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault(); // Prevent default spacebar scroll
                        this.click(); // Trigger the click handler
                    }
                });
            });

            // Listener for the value input field - update equation live
            const valueInput = modifierDiv.querySelector('.modifier-value-input');
            if (valueInput) {
                valueInput.addEventListener('input', updateEquationDisplay); // Live update
                valueInput.addEventListener('change', updateEquationDisplay); // Update on blur/commit
            }
             // Listener for the name input field - update equation title attributes
             const nameInput = modifierDiv.querySelector('.modifier-name-input');
             if (nameInput) {
                 nameInput.addEventListener('input', updateEquationDisplay);
                 nameInput.addEventListener('change', updateEquationDisplay);
             }
        }


        // --- Stats Update Logic ---

        /** Updates the text content of all display elements within the stats panel. */
        function updateStatsDisplay() {
            // Update cumulative stats using the stat formatter
            if (statTotalDamageEl) statTotalDamageEl.textContent = formatStatNumber(totalDamageDealt);
            if (statTotalEnergySpentEl) statTotalEnergySpentEl.textContent = formatStatNumber(totalEnergySpent);
            if (statHighestDamageEl) statHighestDamageEl.textContent = formatStatNumber(highestDamage);
            // Use simple locale string for attack count (no decimals)
            if (statAttackCountEl) statAttackCountEl.textContent = attackCount.toLocaleString();

            // Update the 'Selected Current Energy' display based on the currently active pool
            const selectedType = energyTypeSelect.value;
            const els = getEnergyElements(selectedType);
            if (statCurrentEnergyEl && els?.currentEnergyEl) {
                // Display the formatted current energy from the active pool's display span
                statCurrentEnergyEl.textContent = els.currentEnergyEl.textContent || '0';
            } else if (statCurrentEnergyEl) {
                // Fallback if elements aren't found
                statCurrentEnergyEl.textContent = 'N/A';
            }
        }

        // --- Calculation Logic ---

        /**
         * Updates the display text below a specific energy slider, showing the percentage,
         * the calculated energy amount used (respecting attack limits), and the resulting damage bonus.
         * @param {string} type - The energy type key.
         */
        function updateSingleSliderDisplay(type) {
            const els = getEnergyElements(type);
            // Ensure all necessary elements for this type exist
            if (!els?.energySlider || !els?.sliderValueDisplay || !els?.currentEnergyEl || !els?.damagePerPowerEl) {
                return; // Exit if any required element is missing
            }
            // Get the spans within the display container
            const percentSpan = els.sliderValueDisplay.querySelector('.slider-percent-value');
            const detailsSpan = els.sliderValueDisplay.querySelector('.slider-details-value');
            if (!percentSpan || !detailsSpan) {
                console.error("Slider display spans (.slider-percent-value, .slider-details-value) not found for", type);
                return;
            }

            // Get current values
            const sliderPercent = parseInt(els.energySlider.value); // Actual position of the slider thumb
            const currentEnergy = parseFormattedNumber(els.currentEnergyEl.textContent); // Current energy in the pool
            const damagePerPower = safeParseFloat(els.damagePerPowerEl.value, 1); // Damage per energy point

            // --- Determine the effective percentage based on active attack limit ---
            const activeAttack = activeAttacks[type] || null; // Get active attack for this type
            let limitPercent = 100; // Default limit
            if (activeAttack === 'super') limitPercent = 95;
            else if (activeAttack === 'ultimate') limitPercent = 90;
            // The percentage used for calculation is capped by the limit
            const effectivePercent = Math.min(sliderPercent, limitPercent);
            // --- End ---

            // Calculate potential energy usage based on the *effective* percentage
            const potentialEnergyUsed = currentEnergy * (effectivePercent / 100);
            // Actual energy used is further capped by the available current energy
            const actualEnergyUsed = Math.min(potentialEnergyUsed, currentEnergy);
            // Calculate the extra damage contributed by this energy usage
            const extraDamage = actualEnergyUsed * damagePerPower;

            // Update the display spans
            percentSpan.textContent = `${sliderPercent}%`; // Show the slider's actual percentage value
            // Show the calculated energy used and damage based on the *effective* percentage
            detailsSpan.textContent = `(E: ${formatStatNumber(actualEnergyUsed)}, D: ${formatStatNumber(extraDamage)})`;
        }

        /**
         * Performs the main damage calculation by gathering all inputs, applying multipliers,
         * calculating energy bonuses (respecting attack limits), applying dynamic factors,
         * handling Kaioken cost, updating stats, and displaying the results.
         */
        function performCalculation() {
            showLoading(true); // Show loading spinner, disable button
            // Use setTimeout to allow the UI to update (show loading) before potentially heavy calculations
            setTimeout(() => {
                let finalDamage = 0;
                let healthDepleted = false; // Flag for Kaioken health depletion
                try {
                    // --- Gather Base Values ---
                    const baseDamage = safeParseFloat(baseDamageInput.value, 0);
                    const compressionPoints = safeParseFloat(attackCompressionPointsInput.value, 0);
                    const baseMultiplier = safeParseFloat(baseMultiplierInput.value, 1);
                    const formMultiplier = safeParseFloat(formMultiplierInput.value, 1);
                    const energyType = energyTypeSelect.value; // Needed for Kaioken check

                    // --- Calculate Base Damage Part ---
                    // (Base Damage * Base Multiplier * Form Multiplier)
                    let baseDamagePart = baseDamage * baseMultiplier * formMultiplier;

                    // --- Apply Compression Multiplier ---
                    // Formula: (Points * 1.5) + (floor(Points / 10) * 3), minimum 1
                    let compressionMultiplierValue = 1;
                    if (compressionPoints > 0) {
                        compressionMultiplierValue = (compressionPoints * 1.5) + (Math.floor(compressionPoints / 10) * 3);
                        compressionMultiplierValue = Math.max(1, compressionMultiplierValue); // Ensure at least 1x
                    }
                    // Apply compression multiplier
                    finalDamage = baseDamagePart * compressionMultiplierValue;

                    // --- Apply Dynamic Multiplicative Modifiers ---
                    // Iterate through dynamic boxes, apply multipliers
                    document.querySelectorAll('#dynamic-modifiers-container .dynamic-box').forEach(modifierDiv => {
                        const valueInput = modifierDiv.querySelector('.modifier-value-input');
                        const typeOption = modifierDiv.querySelector('.modifier-type-option.active');
                        if (valueInput && typeOption && typeOption.dataset.value === 'multiplicative') {
                            const modifierValue = safeParseFloat(valueInput.value, 0);
                            // Multiply by the value, treating 0 as 1 (no change) to avoid zeroing out damage
                            finalDamage *= ((modifierValue === 0) ? 1 : modifierValue);
                        }
                    });

                    // --- Calculate and Apply Energy Damage Bonus & Deduct Energy ---
                    let totalEnergyUsedFromSliders = 0; // Track total energy spent this calculation
                    let totalExtraDamageFromEnergy = 0; // Track total damage bonus from energy
                    ALL_ENERGY_TYPES.forEach(type => {
                        const els = getEnergyElements(type);
                        if (els?.energySlider && els.currentEnergyEl && els.damagePerPowerEl) {
                            const sliderPercent = safeParseFloat(els.energySlider.value, 0); // Actual slider position

                             // --- Determine the effective percentage based on active attack limit ---
                             const activeAttack = activeAttacks[type] || null;
                             let limitPercent = 100;
                             if (activeAttack === 'super') limitPercent = 95;
                             else if (activeAttack === 'ultimate') limitPercent = 90;
                             // Use the capped percentage for calculation
                             const effectivePercent = Math.min(sliderPercent, limitPercent);
                             // --- End ---

                            if (effectivePercent > 0) { // Only process if effective slider use is > 0
                                const currentEnergy = parseFormattedNumber(els.currentEnergyEl.textContent);
                                const damagePerPower = safeParseFloat(els.damagePerPowerEl.value, 1);
                                // Calculate energy used based on *effective* percentage, capped by current energy
                                const energyUsedThisType = currentEnergy * (effectivePercent / 100);
                                const actualEnergyUsed = Math.min(energyUsedThisType, currentEnergy);
                                // Calculate damage bonus from this energy type
                                const extraDamageThisType = actualEnergyUsed * damagePerPower;

                                // Accumulate totals for this calculation
                                totalEnergyUsedFromSliders += actualEnergyUsed;
                                totalExtraDamageFromEnergy += extraDamageThisType;

                                // Deduct energy from the pool and update its display
                                let newCurrentEnergyThisType = Math.max(0, currentEnergy - actualEnergyUsed);
                                els.currentEnergyEl.textContent = formatStatNumber(newCurrentEnergyThisType);
                                // Flash red if energy decreased
                                if (newCurrentEnergyThisType < currentEnergy) {
                                    triggerAnimation(els.currentEnergyEl, 'animate-flash-red');
                                }
                                // Update the slider's text display (E:, D:) after deduction
                                updateSingleSliderDisplay(type);
                            }
                        }
                    });
                    // Add the total extra damage from all energy sources to the final damage
                    finalDamage += totalExtraDamageFromEnergy;

                    // --- Apply Dynamic Additive Modifiers ---
                    // Iterate through dynamic boxes again, apply additive values
                    document.querySelectorAll('#dynamic-modifiers-container .dynamic-box').forEach(modifierDiv => {
                        const valueInput = modifierDiv.querySelector('.modifier-value-input');
                        const typeOption = modifierDiv.querySelector('.modifier-type-option.active');
                        if (valueInput && typeOption && typeOption.dataset.value === 'additive') {
                            const modifierValue = safeParseFloat(valueInput.value, 0);
                            finalDamage += modifierValue; // Add the value
                        }
                    });

                    // --- Apply Kaioken Health Cost (if active for Ki energy) ---
                    healthDepleted = false; // Reset flag
                    if (energyType === 'ki' && kaiokenCheckbox.checked) {
                        const currentHealthVal = parseFormattedNumber(currentHealthEl.textContent);
                        if (currentHealthVal > 0) { // Only apply cost if health > 0
                            const maxHealth = safeParseFloat(maxHealthInput.value, 0);
                            const kaiokenStrainPercent = safeParseFloat(kaiokenStrainInput.value, 0);
                            if (maxHealth > 0 && kaiokenStrainPercent > 0) {
                                const strainCost = maxHealth * (kaiokenStrainPercent / 100);
                                // Calculate new health, ensuring it doesn't go below 0
                                let newHealth = Math.max(0, currentHealthVal - strainCost);
                                // Update health display
                                currentHealthEl.textContent = formatStatNumber(newHealth);
                                // Flash red if health decreased
                                if (newHealth < currentHealthVal) {
                                    triggerAnimation(currentHealthEl, 'animate-flash-red');
                                }
                                // Set flag if health reached zero
                                if (newHealth === 0) {
                                    healthDepleted = true;
                                }
                            }
                        }
                    }

                    // --- Update Global Stats ---
                    totalDamageDealt += finalDamage; // Add to cumulative damage
                    totalEnergySpent += totalEnergyUsedFromSliders; // Add to cumulative energy spent
                    attackCount++; // Increment attack counter
                    // Update highest damage if this attack was higher
                    if (finalDamage > highestDamage) {
                        highestDamage = finalDamage;
                    }
                    updateStatsDisplay(); // Refresh the stats panel display

                    // --- Display Results ---
                    // Update result area elements with formatted values
                    resultValueEl.textContent = formatSimpleNumber(finalDamage);
                    resultTotalEnergyUsedEl.textContent = formatStatNumber(totalEnergyUsedFromSliders);
                    resultTotalExtraDamageEl.textContent = formatStatNumber(totalExtraDamageFromEnergy);
                    displayAllFormats(finalDamage); // Update scientific notation and words
                    updateEquationDisplay(); // Update the equation visualization

                    // Style and show the result area (success state)
                    resultDiv.classList.remove('hidden', 'bg-error-light', 'border-error', 'text-error-dark');
                    resultDiv.classList.add('bg-success-light', 'border-success', 'text-success-dark');
                    // Trigger entrance animation for result area
                    resultDiv.classList.remove('animate__animated', 'animate__fadeInUp');
                    void resultDiv.offsetWidth; // Force reflow
                    resultDiv.classList.add('animate__animated', 'animate__fadeInUp');
                    // Ensure title color matches success state
                    resultDiv.querySelector('.result-title').className = 'result-title text-lg font-semibold mb-2 text-success-dark';

                    // Show success message (with warning if Kaioken depleted health)
                    let successMsg = 'Calculation successful!';
                    if (healthDepleted) {
                        successMsg += ' Warning: Health depleted by Kaioken strain!';
                    }
                    showMessage(successMsg, healthDepleted ? 'error' : 'success'); // Show error style if health depleted

                } catch (error) {
                    // --- Handle Calculation Errors ---
                    console.error("Calculation Error:", error);
                    // Display error state in result area
                    resultValueEl.textContent = 'Error';
                    resultTotalEnergyUsedEl.textContent = 'N/A';
                    resultTotalExtraDamageEl.textContent = 'N/A';
                    resultScientificEl.textContent = 'N/A';
                    resultWordsEl.textContent = 'Error';
                    equationDisplayEl.innerHTML = '<span class="text-error-dark">Error calculating equation.</span>';

                    // Style result area for error state
                    resultDiv.classList.remove('hidden', 'bg-success-light', 'border-success', 'text-success-dark');
                    resultDiv.classList.add('bg-error-light', 'border-error', 'text-error-dark');
                    resultDiv.querySelector('.result-title').className = 'result-title text-lg font-semibold mb-2 text-error-dark';
                    // Show error message to user
                    showMessage(`Calculation failed: ${error.message || 'Unknown error'}`, 'error');

                } finally {
                    // --- Cleanup ---
                    showLoading(false); // Hide loading indicator regardless of success/failure
                }
            }, 50); // Small delay allows loading indicator to render before calculation starts
        }


        // --- Number Formatting ---

        /**
         * Updates the display elements for scientific notation and number-to-words conversion
         * based on the final calculated damage.
         * @param {number} damage - The calculated damage value.
         */
        function displayAllFormats(damage) {
            // Scientific Notation (e.g., 1.23 x 10^9)
            try {
                // Format using toExponential and replace 'e+' with ' x 10^'
                resultScientificEl.textContent = damage.toExponential(2).replace(/e\+?(-?)/, ' x 10^$1');
            } catch (e) {
                resultScientificEl.textContent = "Invalid";
                console.error("Scientific notation error:", e);
            }
            // Number to Words
            try {
                resultWordsEl.textContent = convertNumberToWords(damage);
            } catch (e) {
                resultWordsEl.textContent = "Error: " + e.message;
                console.error("Number to words error:", e);
            }
        }

        /**
         * Converts a number into its English word representation.
         * Handles large integers using BigInt, decimals, negative numbers.
         * Uses scales up to Quindecillion (10^48). Returns scientific notation for larger numbers.
         * @param {number} number - The number to convert.
         * @returns {string} The number in words or an error/fallback string.
         */
        function convertNumberToWords(number) {
            // Word arrays for conversion logic
            const units = ['', 'One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Eleven', 'Twelve', 'Thirteen', 'Fourteen', 'Fifteen', 'Sixteen', 'Seventeen', 'Eighteen', 'Nineteen'];
            const tens = ['', '', 'Twenty', 'Thirty', 'Forty', 'Fifty', 'Sixty', 'Seventy', 'Eighty', 'Ninety'];
            // Scale names (Thousand, Million, ...) - Add more if needed for larger numbers
            const scales = ['', 'Thousand', 'Million', 'Billion', 'Trillion', 'Quadrillion', 'Quintillion', 'Sextillion', 'Septillion', 'Octillion', 'Nonillion', 'Decillion', 'Undecillion', 'Duodecillion', 'Tredecillion', 'Quattuordecillion', 'Quindecillion']; // Up to 10^48

            // Input validation
            if (typeof number !== 'number' || !isFinite(number)) {
                return 'Invalid Number';
            }
            if (number === 0) {
                return 'Zero';
            }

            // Check if number is too large for the defined scales using BigInt
            const MAX_SAFE_INTEGER_FOR_WORDS = BigInt("9".repeat((scales.length) * 3));
            let numForCheck = number < 0 ? BigInt(Math.abs(Math.trunc(number))) : BigInt(Math.trunc(number));
            if (numForCheck > MAX_SAFE_INTEGER_FOR_WORDS) {
                console.warn("Number too large for full word conversion, returning scientific.");
                // Fallback to scientific notation for extremely large numbers
                return number.toExponential(2) + " (Too large for words)";
            }

            // Handle negative numbers
            let isNegative = number < 0;
            if (isNegative) number = -number; // Work with the absolute value

            // Separate integer and fractional parts safely using BigInt for the integer part
            let integerPart;
            let fractionalPart = 0;
            try {
                // Use toLocaleString to avoid potential scientific notation conversion for large numbers
                const numStr = number.toLocaleString('en-US', { useGrouping: false, maximumFractionDigits: 20 });
                const parts = numStr.split('.');
                integerPart = BigInt(parts[0]); // Integer part as BigInt
                if (parts.length > 1) {
                    fractionalPart = parseFloat('0.' + parts[1]); // Fractional part as float
                }
            } catch (e) {
                 // Handle potential errors during BigInt conversion (should be rare with prior checks)
                 console.error("Error processing number for words:", number, e);
                 return "Number too large or invalid format";
            }

            // Start building the word string
            let words = isNegative ? 'Negative ' : '';

            // Helper function to convert a 3-digit chunk (0-999) to words
            function convertHundreds(num) {
                let word = '';
                const h = Math.floor(num / 100); // Hundreds digit
                const r = num % 100; // Remainder (tens and units)

                if (h > 0) {
                    word += units[h] + ' Hundred'; // Add "X Hundred"
                }

                if (r > 0) { // Process tens and units if remainder exists
                    if (word !== '') word += ' '; // Add space if hundreds part exists
                    if (r < 20) { // Numbers 1-19 use the units array directly
                        word += units[r];
                    } else { // Numbers 20-99
                        const t = Math.floor(r / 10); // Tens digit
                        const o = r % 10; // Units digit
                        word += tens[t]; // Add "Twenty", "Thirty", etc.
                        if (o > 0) {
                            word += '-' + units[o]; // Add hyphen and unit (e.g., "Twenty-One")
                        }
                    }
                }
                return word;
            }

            // Process the integer part
            if (integerPart === 0n) {
                // If the original number was fractional (e.g., 0.5), integer part is 0
                // We handle the "Zero" case at the beginning if the entire number is 0.
                // If only the integer part is zero, we might just add "Point..." later.
                // If the whole number is zero, we return 'Zero' earlier.
                // If it's like 0.5, we don't add 'Zero' here, just proceed to fractional part.
                 if (fractionalPart === 0) words += 'Zero'; // Add Zero only if fractional is also 0
            } else {
                let scaleIndex = 0; // Index for scales array (0: none, 1: Thousand, 2: Million, ...)
                let tempWords = []; // Array to hold word chunks for each scale
                let currentInt = integerPart; // Work with BigInt
                // Process the integer part in chunks of 3 digits (thousands)
                while (currentInt > 0n) {
                     // Safety check against exceeding defined scales (shouldn't happen with MAX_SAFE check)
                     if (scaleIndex >= scales.length) {
                         console.error("Number exceeds defined scales during conversion:", number);
                         return number.toExponential(2) + " (Too large for words)";
                     }
                    // Get the last 3 digits as a standard number for convertHundreds
                    const chunk = Number(currentInt % 1000n);
                    if (chunk !== 0) { // Only process non-zero chunks
                        const chunkWords = convertHundreds(chunk); // Convert the 3-digit chunk
                        // Add the scale name (Thousand, Million, etc.) if applicable (scaleIndex > 0)
                        tempWords.push(chunkWords + (scaleIndex > 0 ? ' ' + scales[scaleIndex] : ''));
                    }
                    currentInt /= 1000n; // Move to the next chunk (integer division with BigInt)
                    scaleIndex++; // Increment scale index
                }
                // Join the chunks in reverse order (e.g., "One Million", "Two Hundred Thousand", "Three Hundred")
                words += tempWords.reverse().filter(w => w.trim()).join(', ');
            }

            // Process the fractional part (if it exists and is significant)
            if (fractionalPart > 1e-9) { // Use a small epsilon to avoid floating point noise
                words += ' Point'; // Add " Point " separator
                // Convert fractional part digits to words, limiting precision and removing trailing zeros
                // Limit to 6 decimal places for word conversion practicality
                let fractionalStr = fractionalPart.toFixed(6).substring(2).replace(/0+$/, '');
                if (fractionalStr.length > 0) {
                    // Convert each digit after the decimal point to its word representation
                    for (const digit of fractionalStr) {
                        words += ' ' + (units[parseInt(digit)] || 'Zero'); // Use 'Zero' for '0' digit
                    }
                } else {
                    // If fractional part was effectively zero after rounding/trimming, remove " Point"
                    words = words.replace(/ Point$/, '');
                }
            }

            return words.trim(); // Return the final word string, removing any leading/trailing spaces
        }


        // --- State Management ---

        /** Gathers the current state of all inputs, sliders, stats, and attack states into an object for saving. */
        function gatherState() {
            const state = {
                // Base inputs
                baseDamage: baseDamageInput.value,
                baseMultiplier: baseMultiplierInput.value,
                formMultiplier: formMultiplierInput.value,
                attackCompressionPoints: attackCompressionPointsInput.value,
                // Selected energy type
                selectedEnergyType: energyTypeSelect.value,
                // Placeholders for pool data, sliders, and modifiers
                sliderPercentages: {},
                energyPools: {},
                dynamicModifiers: [],
                // *** ADDED: Active attacks state ***
                activeAttacks: activeAttacks,
                // Kaioken state
                kaiokenActive: kaiokenCheckbox.checked,
                maxHealth: maxHealthInput.value,
                kaiokenStrain: kaiokenStrainInput.value,
                currentHealth: currentHealthEl?.textContent || '0', // Get text from span
                // Cumulative stats
                totalDamageDealt: totalDamageDealt,
                totalEnergySpent: totalEnergySpent,
                attackCount: attackCount,
                highestDamage: highestDamage
            };

            // Gather data for each energy pool and its slider
            ALL_ENERGY_TYPES.forEach(type => {
                const els = getEnergyElements(type);
                if (els) {
                    // Store pool input values and displayed current/total energy
                    state.energyPools[type] = {
                        maxEnergy: els.maxEnergyEl?.value || '0',
                        maxMultiplier: els.maxMultiplierEl?.value || '1',
                        currentEnergy: els.currentEnergyEl?.textContent || '0', // Get from display span
                        totalEnergy: els.totalEnergyEl?.textContent || '0', // Get from display span
                        damagePerPower: els.damagePerPowerEl?.value || '1',
                        regenPercent: els.regenPercentEl?.value || ''
                    };
                    // Store slider percentage
                    state.sliderPercentages[type] = els.energySlider?.value || '0';
                }
            });

            // Gather dynamic modifiers data
            dynamicModifiersContainer.querySelectorAll('.dynamic-box').forEach(box => {
                const nameInput = box.querySelector('.modifier-name-input');
                const valueInput = box.querySelector('.modifier-value-input');
                const typeOption = box.querySelector('.modifier-type-option.active');
                if (nameInput && valueInput && typeOption) {
                    state.dynamicModifiers.push({
                        name: nameInput.value,
                        value: valueInput.value,
                        type: typeOption.dataset.value // 'additive' or 'multiplicative'
                    });
                }
            });

            return state; // Return the complete state object
        }

        /** Applies a previously saved state object to restore the UI and internal state. */
        function applyState(state) {
            if (!state) return; // Do nothing if state is null/undefined

            // Restore base input values
            baseDamageInput.value = state.baseDamage || '';
            baseMultiplierInput.value = state.baseMultiplier || '1';
            formMultiplierInput.value = state.formMultiplier || '1';
            attackCompressionPointsInput.value = state.attackCompressionPoints || '0';

            // Restore selected energy type dropdown
            energyTypeSelect.value = state.selectedEnergyType || 'ki';

            // Restore energy pool data
            if (state.energyPools) {
                ALL_ENERGY_TYPES.forEach(type => {
                    const els = getEnergyElements(type);
                    const poolData = state.energyPools[type];
                    // Ensure elements and data exist before applying
                    if (els && poolData && els.maxEnergyEl && els.totalEnergyEl && els.currentEnergyEl) {
                        // Restore input values
                        els.maxEnergyEl.value = poolData.maxEnergy || '';
                        els.maxMultiplierEl.value = poolData.maxMultiplier || '1';
                        els.damagePerPowerEl.value = poolData.damagePerPower || '1';
                        els.regenPercentEl.value = poolData.regenPercent || '';

                        // Recalculate total based on loaded max/multiplier
                        const loadedTotalNum = (safeParseFloat(poolData.maxEnergy, 0) * safeParseFloat(poolData.maxMultiplier, 1));
                        els.totalEnergyEl.textContent = formatStatNumber(loadedTotalNum); // Update total display

                        // Parse saved current energy and cap it at the recalculated total
                        const savedCurrentNum = parseFormattedNumber(poolData.currentEnergy || '0');
                        // Ensure current energy doesn't exceed the (potentially changed) total
                        els.currentEnergyEl.textContent = formatStatNumber(Math.min(savedCurrentNum, loadedTotalNum));
                    }
                });
            }

            // Restore slider percentages
            if (state.sliderPercentages) {
                ALL_ENERGY_TYPES.forEach(type => {
                    const els = getEnergyElements(type);
                    if (els?.energySlider) {
                        els.energySlider.value = state.sliderPercentages[type] || '0';
                    }
                });
            }

            // Restore dynamic modifiers
            // Clear existing modifiers first
            dynamicModifiersContainer.innerHTML = '<h4 class="text-md font-semibold mb-2 text-gray-700">Additional Factors:</h4>'; // Reset container HTML
            dynamicModifierCount = 0; // Reset counter
            // Add modifiers based on saved data
            if (state.dynamicModifiers && Array.isArray(state.dynamicModifiers)) {
                state.dynamicModifiers.forEach(modData => {
                    addDynamicModifier(modData); // Recreate each modifier box
                });
            }

            // Restore Kaioken state
            kaiokenCheckbox.checked = state.kaiokenActive || false;
            maxHealthInput.value = state.maxHealth || '1000';
            kaiokenStrainInput.value = state.kaiokenStrain || '10';
            // Restore current health display
            if(currentHealthEl) {
                const savedHealthNum = parseFormattedNumber(state.currentHealth || '0');
                 currentHealthEl.textContent = formatStatNumber(savedHealthNum);
            }

            // Restore cumulative stats
            totalDamageDealt = state.totalDamageDealt || 0;
            totalEnergySpent = state.totalEnergySpent || 0;
            attackCount = state.attackCount || 0;
            highestDamage = state.highestDamage || 0;

            // *** Restore active attacks state ***
            activeAttacks = state.activeAttacks || {}; // Restore the object, default to empty if missing

            // --- Final UI Updates After Applying State ---
            // Update slider visibility, limits, and styles for ALL types based on loaded data
            ALL_ENERGY_TYPES.forEach(type => {
                 updateSliderVisibility(type);
                 updateSliderLimitAndStyle(type); // Apply loaded limits/styles
             });

            // Update attack button states specifically for the *currently selected* pool
            updateAttackButtonStates(energyTypeSelect.value);

            // Update the equation display based on the loaded values
            updateEquationDisplay();
            // Ensure the correct energy pool is shown (this also updates stats display)
            showSelectedEnergyPool();

        }

        /** Saves the current UI state to localStorage. */
        function saveState() {
            try {
                const state = gatherState(); // Get the current state object
                const stateString = JSON.stringify(state); // Convert to JSON string
                localStorage.setItem(LOCAL_STORAGE_KEY, stateString); // Save to localStorage
                showMessage('State saved successfully!', 'success'); // User feedback
            } catch (error) {
                // Handle potential errors (e.g., localStorage full)
                console.error("Error saving state:", error);
                showMessage(`Failed to save state. ${error.message}`, 'error');
            }
        }

        /** Loads state from localStorage and applies it to the UI. Returns true if successful. */
        function loadState() {
            const stateString = localStorage.getItem(LOCAL_STORAGE_KEY); // Retrieve saved state string
            if (stateString) { // Check if state exists
                try {
                    const state = JSON.parse(stateString); // Parse JSON string
                    applyState(state); // Apply the loaded state to the UI
                    showMessage('State loaded successfully!', 'success');
                    return true; // Indicate success
                } catch (error) {
                    // Handle errors during parsing (e.g., corrupted data)
                    console.error("Error loading state:", error);
                    showMessage(`Failed to load saved state. Data might be corrupted. ${error.message}`, 'error');
                    // Clear potentially corrupted data to prevent repeated errors on reload
                    localStorage.removeItem(LOCAL_STORAGE_KEY);
                }
            }
            return false; // Indicate state was not loaded
        }

        /** Clears the saved state from localStorage after user confirmation. */
        function clearState() {
            // Confirm with the user before clearing
            if (confirm('Are you sure you want to clear the saved state? This cannot be undone.')) {
                localStorage.removeItem(LOCAL_STORAGE_KEY); // Remove item from localStorage
                showMessage('Saved state cleared. Reloading.', 'success');
                // Reload the page to reset the UI to defaults after clearing
                setTimeout(() => window.location.reload(), 1000);
            }
        }


        // --- Generate Elements from Templates ---

        /** Generates the HTML structure for all energy pools and sliders using the defined templates. */
        function generateEnergySections() {
            // Ensure templates and containers exist in the DOM
            if (!energyPoolTemplate || !energySliderTemplate || !energyPoolsContainer || !slidersGrid) {
                console.error("Required templates or containers not found! Cannot generate energy sections.");
                return;
            }

            // Clear any existing generated content
            energyPoolsContainer.innerHTML = '';
            slidersGrid.innerHTML = '';

            // Iterate through each defined energy type
            ALL_ENERGY_TYPES.forEach(type => {
                const details = ENERGY_TYPE_DETAILS[type]; // Get details for this type
                if (!details) return; // Skip if details are missing

                // --- Generate Energy Pool Section ---
                const poolClone = energyPoolTemplate.content.cloneNode(true); // Clone template content
                const poolDiv = poolClone.querySelector('.energy-pool'); // Get the main div from clone

                if (poolDiv) {
                    poolDiv.id = `${type}-pool`; // Set unique ID for the pool section
                    poolDiv.style.display = 'none'; // Hide initially
                    // Apply type-specific styling (border color, gradient)
                    poolDiv.classList.add(details.border, details.gradientTo);

                    // Set the pool title dynamically
                    const titleEl = poolDiv.querySelector('.pool-title');
                    if (titleEl) titleEl.textContent = `${details.name} Energy Pool`;

                    // Helper function to set up elements (inputs/spans) within the pool
                    const setupElement = (selectorSuffix, isInput = true, focusClass = '') => {
                        const el = poolDiv.querySelector(`.${selectorSuffix}`); // Find element by class
                        const labelEl = poolDiv.querySelector(`.${selectorSuffix}-label`); // Find associated label
                        if (el) {
                            el.id = `${type}-${selectorSuffix}`; // Set unique ID
                            // Link label to input for accessibility, or remove 'for' if it's a span
                            if(labelEl && isInput) labelEl.htmlFor = el.id;
                            else if (labelEl) labelEl.removeAttribute('for');
                            // Add type-specific focus ring class to inputs
                            if (isInput && focusClass) el.classList.add(focusClass);
                        }
                    };

                    // Set up all elements within the pool using the helper
                    setupElement('max-energy', true, details.focusRing);
                    setupElement('max-multiplier', true, details.focusRing);
                    setupElement('total-energy', false); // Span, not input
                    setupElement('current-energy', false); // Span, not input
                    setupElement('damage-per-power', true, details.focusRing);
                    setupElement('regen-percent', true, details.focusRing);

                    // Set data attribute on regen button for easy type identification in event listener
                    const regenBtn = poolDiv.querySelector('.regen-btn');
                    if (regenBtn) { regenBtn.dataset.type = type; }

                    // Append the generated pool section to the container
                    energyPoolsContainer.appendChild(poolClone);
                } else {
                    console.error(`Could not find .energy-pool in template clone for ${type}`);
                }

                // --- Generate Energy Slider Section ---
                const sliderClone = energySliderTemplate.content.cloneNode(true); // Clone slider template
                const sliderSection = sliderClone.querySelector('.energy-slider-section'); // Get main section div

                if (sliderSection) {
                    sliderSection.id = `${type}-slider-section`; // Set unique ID
                    sliderSection.dataset.type = type; // Store type for reference

                    // Set up slider label (text and 'for' attribute)
                    const sliderLabel = sliderSection.querySelector('.slider-label');
                    if (sliderLabel) {
                        sliderLabel.htmlFor = `${type}-energy-slider`;
                        sliderLabel.textContent = `${details.name} Energy Used (%):`;
                    }
                    // Set up slider input (ID and data attribute)
                    const energySlider = sliderSection.querySelector('.energy-slider');
                    if (energySlider) {
                        energySlider.id = `${type}-energy-slider`;
                        energySlider.dataset.type = type; // Store type on slider itself
                        // Note: Slider thumb color is handled by CSS using the ID selector
                    }
                    // Set up value display container ID
                    const valueDisplay = sliderSection.querySelector('.energy-slider-value-display');
                    if (valueDisplay) {
                        valueDisplay.id = `${type}-slider-value-display`;
                    }

                    // Append the generated slider section to its grid container
                    slidersGrid.appendChild(sliderClone);
                } else {
                     console.error(`Could not find .energy-slider-section in template clone for ${type}`);
                }
            });
            console.log("Energy sections generated from templates.");
        }


        // --- Equation Display Function ---

        /**
         * Updates the HTML representation of the damage calculation formula in the results area.
         * Makes numbers clickable, linking them to their corresponding input elements.
         * Uses current input values to build the formula string.
         */
        function updateEquationDisplay() {
            if (!equationDisplayEl) return; // Exit if the display element doesn't exist

            let equationHTML = ''; // String to build the HTML equation

            // Helper functions for formatting equation parts
            const op = (operator) => `<span class="equation-operator">${operator}</span>`; // Operator symbol (e.g., +, *)
            const group = (content) => `<span class="equation-group">(</span>${content}<span class="equation-group">)</span>`; // Parentheses
            // Clickable number linked to a source element ID, with optional tooltip title
            const num = (value, targetId, title = '') => {
                 const titleAttr = title ? ` title="${escapeHtml(title)}"` : ''; // Add tooltip if title provided
                 // Use data-target-id to link the number span to its source element
                 return `<span class="equation-number" data-target-id="${targetId}"${titleAttr}>${formatSimpleNumber(value)}</span>`;
            };

            try {
                // --- Build the equation step-by-step ---

                // 1. Group: (Base Damage * Base Multiplier * Form Multiplier)
                const baseDamage = safeParseFloat(baseDamageInput.value, 0);
                const baseMultiplier = safeParseFloat(baseMultiplierInput.value, 1);
                const formMultiplier = safeParseFloat(formMultiplierInput.value, 1);

                let basePart = num(baseDamage, 'base-damage', 'Base Damage'); // Start with base damage
                // Add base multiplier term if it's not the default value (1)
                if (baseMultiplier !== 1 || baseMultiplierInput.value.trim() !== '1') {
                    basePart += op('*') + num(baseMultiplier, 'base-multiplier', 'Base Multiplier');
                }
                // Add form multiplier term if it's not the default value (1)
                if (formMultiplier !== 1 || formMultiplierInput.value.trim() !== '1') {
                    basePart += op('*') + num(formMultiplier, 'form-multiplier', 'Form Multiplier');
                }
                // Wrap the base calculation in parentheses only if it involves more than just base damage
                let baseCalculationHTML = (basePart !== num(baseDamage, 'base-damage', 'Base Damage')) ? group(basePart) : basePart;


                // 2. Compression Multiplier (Applied after the base group)
                const compressionPoints = safeParseFloat(attackCompressionPointsInput.value, 0);
                let compressionMultiplierValue = 1;
                if (compressionPoints > 0) {
                    // Calculate the multiplier value based on the formula
                    compressionMultiplierValue = Math.max(1, (compressionPoints * 1.5) + (Math.floor(compressionPoints / 10) * 3));
                    // Add the compression multiplier term to the equation, linking to the input
                    // Title attribute shows the points and resulting multiplier for clarity
                    baseCalculationHTML += op('*') + `<span class="equation-number" data-target-id="attack-compression-points" title="${compressionPoints} Compression Points -> x${formatSimpleNumber(compressionMultiplierValue)} Multiplier">${formatSimpleNumber(compressionMultiplierValue)}</span>`;
                }
                equationHTML = baseCalculationHTML; // Start the main equation string


                // 3. Dynamic Multiplicative Modifiers
                let multiplicativeTerms = []; // Array to hold multiplicative factor terms
                document.querySelectorAll('#dynamic-modifiers-container .dynamic-box').forEach((modifierDiv) => {
                    const valueInput = modifierDiv.querySelector('.modifier-value-input');
                    const typeOption = modifierDiv.querySelector('.modifier-type-option.active');
                    const nameInput = modifierDiv.querySelector('.modifier-name-input'); // Get name input
                    const modifierId = valueInput?.id; // Get ID for linking
                    const factorName = nameInput?.value.trim() || 'Unnamed Multiplier'; // Get name for tooltip

                    // Check if it's a multiplicative modifier
                    if (valueInput && typeOption && modifierId && typeOption.dataset.value === 'multiplicative') {
                        const modifierValue = safeParseFloat(valueInput.value, 0);
                        const multiplier = (modifierValue === 0) ? 1 : modifierValue; // Treat 0 as 1x
                        // Add the term if it's not the default (1)
                        if (multiplier !== 1 || valueInput.value.trim() !== '1') {
                             multiplicativeTerms.push(num(multiplier, modifierId, factorName)); // Pass name as title
                        }
                    }
                });
                // If there are multiplicative terms, add them grouped together
                if (multiplicativeTerms.length > 0) {
                    // Wrap the existing calculation in parentheses if needed before multiplying
                    if (multiplicativeTerms.length > 1 || equationHTML.includes(op('*')) || equationHTML.includes(op('+'))) {
                         equationHTML = group(equationHTML);
                    }
                    // Add the group of multiplicative terms
                    equationHTML += op('*') + group(multiplicativeTerms.join(op('*')));
                }


                // 4. Energy Damage Bonus (Sum of (EnergyUsed * DamagePerPoint) for each type)
                let energyTerms = []; // Array to hold energy damage terms
                ALL_ENERGY_TYPES.forEach(type => {
                    const els = getEnergyElements(type);
                    if (els?.energySlider && els.currentEnergyEl && els.damagePerPowerEl) {
                        const sliderPercent = safeParseFloat(els.energySlider.value, 0); // Actual slider position

                        // *** Get effective percent based on attack limit ***
                        const activeAttack = activeAttacks[type] || null;
                        let limitPercent = 100;
                        if (activeAttack === 'super') limitPercent = 95;
                        else if (activeAttack === 'ultimate') limitPercent = 90;
                        const effectivePercent = Math.min(sliderPercent, limitPercent); // Use the capped percentage
                        // *** End effective percent ***

                        if (effectivePercent > 0) { // Only include if effective slider use > 0
                            const currentEnergy = parseFormattedNumber(els.currentEnergyEl.textContent);
                            const damagePerPower = safeParseFloat(els.damagePerPowerEl.value, 1);
                            // Calculate actual energy used based on effective percent, capped by current energy
                            const energyUsed = Math.min(currentEnergy * (effectivePercent / 100), currentEnergy);
                            // Calculate damage bonus from this energy type
                            const energyDamage = energyUsed * damagePerPower;
                            // Add the term if it contributes damage
                            if (energyDamage !== 0) {
                                const energyTitle = `${ENERGY_TYPE_DETAILS[type]?.name || type} Energy Used (${sliderPercent}%)`; // Tooltip shows actual slider %
                                const dppTitle = `${ENERGY_TYPE_DETAILS[type]?.name || type} Damage/Point`;
                                // Group the (Energy * DPP) calculation for clarity, link to slider and DPP input
                                energyTerms.push(group(num(energyUsed, `${type}-energy-slider`, energyTitle) + op('*') + num(damagePerPower, `${type}-damage-per-power`, dppTitle)));
                            }
                        }
                    }
                });
                 // If there's energy damage, add it to the main equation
                 if (energyTerms.length > 0) {
                     // Group the preceding multiplicative part if it exists, before adding energy bonus
                     if (equationHTML.includes(op('*')) || equationHTML.includes(op('+'))) {
                          equationHTML = group(equationHTML);
                     }
                     // Add the sum of energy damages, grouped
                     equationHTML += op('+') + group(energyTerms.join(op('+')));
                 }


                // 5. Dynamic Additive Modifiers (Applied last)
                let additiveTerms = []; // Array to hold additive factor terms
                 document.querySelectorAll('#dynamic-modifiers-container .dynamic-box').forEach((modifierDiv) => {
                      const valueInput = modifierDiv.querySelector('.modifier-value-input');
                      const typeOption = modifierDiv.querySelector('.modifier-type-option.active');
                      const nameInput = modifierDiv.querySelector('.modifier-name-input'); // Get name
                      const modifierId = valueInput?.id; // Get ID
                      const factorName = nameInput?.value.trim() || 'Unnamed Additive'; // Get name for tooltip

                      // Check if it's an additive modifier
                      if (valueInput && typeOption && modifierId && typeOption.dataset.value === 'additive') {
                          const modifierValue = safeParseFloat(valueInput.value, 0);
                          // Add the term if it's not zero
                          if (modifierValue !== 0 || valueInput.value.trim() !== '0') {
                               additiveTerms.push(num(modifierValue, modifierId, factorName)); // Pass name as title
                          }
                      }
                 });
                 // If there are additive terms, add them grouped together at the end
                 if (additiveTerms.length > 0) {
                     // Group the previous calculation if it's complex, before adding additive terms
                     if (equationHTML.includes(op('*')) || equationHTML.includes(op('+'))) {
                          equationHTML = group(equationHTML);
                     }
                     // Add the group of additive terms
                     equationHTML += op('+') + group(additiveTerms.join(op('+')));
                 }

                // Set the final generated HTML to the display element
                equationDisplayEl.innerHTML = equationHTML;

            } catch (error) {
                // Handle errors during equation generation
                console.error("Error updating equation:", error);
                equationDisplayEl.innerHTML = '<span class="text-error-dark">Could not generate equation.</span>';
            }
        }

        // --- Click Handler for Equation Numbers ---

        /**
         * Handles clicks on the clickable numbers within the equation display.
         * Scrolls to and highlights the corresponding input/source element.
         * Switches the energy pool view if a value from an inactive pool is clicked.
         * @param {Event} event - The click event object.
         */
        function handleEquationClick(event) {
            const target = event.target; // The clicked element
            // Check if the clicked element is a number span with a target ID
            if (target.classList.contains('equation-number') && target.dataset.targetId) {
                const targetId = target.dataset.targetId; // Get the ID of the source element
                const sourceElement = document.getElementById(targetId); // Find the source element

                if (sourceElement) {
                    // --- Scroll & Pulse Logic ---
                    // Scroll the source element into view smoothly, centered vertically
                    sourceElement.scrollIntoView({ behavior: 'smooth', block: 'center' });

                    // Determine the best element to apply the pulse animation to for visual feedback
                    let elementToPulse = sourceElement;
                    // If it's a read-only span (like current energy), pulse the parent pool section
                    if (sourceElement.tagName === 'SPAN' && sourceElement.classList.contains('readonly-display')) {
                        elementToPulse = sourceElement.closest('.energy-pool') || sourceElement;
                    }
                    // If it's a range slider, pulse the whole slider section container
                    else if (sourceElement.type === 'range') {
                        elementToPulse = sourceElement.closest('.energy-slider-section') || sourceElement;
                    }
                    // If it's a dynamic modifier input, pulse the parent modifier box
                    else if (sourceElement.classList.contains('modifier-value-input')) {
                        elementToPulse = sourceElement.closest('.dynamic-box') || sourceElement;
                    }
                    // Trigger the pulse animation on the determined element
                    triggerAnimation(elementToPulse, 'animate-pulse-source', 800);

                    // Focus the input element if it's an editable input field (not range sliders)
                    if (sourceElement.tagName === 'INPUT' && !sourceElement.readOnly && sourceElement.type !== 'range') {
                        sourceElement.focus();
                    }
                    // --- End Scroll & Pulse ---


                    // --- Switch Tab Logic for Energy-Specific Inputs ---
                    // Check if the clicked element is related to a specific energy type
                    // (e.g., damage-per-power or the energy slider itself) using regex
                    const energyTypeMatch = targetId.match(/^([a-z]+)-(damage-per-power|energy-slider)/);
                    if (energyTypeMatch) {
                        const energyType = energyTypeMatch[1]; // Extract the energy type (ki, nen, etc.)
                        // If the clicked element belongs to an energy type that is NOT currently selected
                        if (ALL_ENERGY_TYPES.includes(energyType) && energyTypeSelect.value !== energyType) {
                            console.log(`Switching view to ${energyType} pool triggered by equation click...`);
                            energyTypeSelect.value = energyType; // Change the dropdown selection
                            // Update the visible pool and related UI elements (attack buttons, slider limits)
                            showSelectedEnergyPool();
                        }
                    }
                    // --- End Switch Tab ---

                } else {
                    // Log a warning if the linked element wasn't found
                    console.warn(`Equation link target element not found: #${targetId}`);
                }
            }
        }


        // --- Event Listeners Setup ---

        /** Sets up all initial event listeners for the calculator UI elements upon page load. */
        function setupEventListeners() {
            // Energy type dropdown change: Show selected pool, update equation context
            energyTypeSelect.addEventListener('change', () => {
                showSelectedEnergyPool(); // Handles showing pool, Kaioken, attack states, slider limits
                updateEquationDisplay(); // Update equation as context might change
            });

            // Calculate button click: Trigger animation, perform calculation
            calculateBtn.addEventListener('click', () => {
                 triggerAnimation(calculateBtn, 'animate__pulse'); // Button feedback
                 performCalculation(); // Run the main calculation logic
            });

            // Add dynamic modifier button click: Trigger animation, add new box, update equation
            addDynamicBoxBtn.addEventListener('click', () => {
                 triggerAnimation(addDynamicBoxBtn, 'animate__pulse'); // Button feedback
                 addDynamicModifier(); // Add a new modifier input box
                 updateEquationDisplay(); // Update equation immediately
            });

            // Listeners for base damage/multiplier inputs: Update equation display on input/change
            [baseDamageInput, attackCompressionPointsInput, baseMultiplierInput, formMultiplierInput].forEach(input => {
                if(input) {
                    input.addEventListener('input', updateEquationDisplay); // Live update
                    input.addEventListener('change', updateEquationDisplay); // Update on blur/commit
                }
            });

            // Attach listeners to dynamically generated energy pool inputs and sliders
            // Note: Listeners for dynamic modifier boxes are added in addListenersToModifierBox
            ALL_ENERGY_TYPES.forEach(type => {
                const els = getEnergyElements(type);
                if (els) {
                    // Max Energy / Multiplier inputs: Recalculate pool, update stats/equation
                    if (els.maxEnergyEl) els.maxEnergyEl.addEventListener('input', () => { calculateAndResetEnergy(type); updateStatsDisplay(); updateEquationDisplay(); });
                    if (els.maxMultiplierEl) els.maxMultiplierEl.addEventListener('input', () => { calculateAndResetEnergy(type); updateStatsDisplay(); updateEquationDisplay(); });
                    // Damage Per Power input: Update slider display text and equation
                    if (els.damagePerPowerEl) els.damagePerPowerEl.addEventListener('input', () => { updateSingleSliderDisplay(type); updateEquationDisplay(); });

                    // Energy Slider input event: Update display, equation, AND enforce attack limits
                    if (els.energySlider) {
                        els.energySlider.addEventListener('input', (event) => {
                            const slider = event.target;
                            const currentType = slider.dataset.type; // Get type from slider's data attribute

                            // --- Enforce Attack Limit ---
                            // Get the active attack and corresponding limit for this slider's type
                            const activeAttack = activeAttacks[currentType] || null;
                            let limitPercent = 100;
                             if (activeAttack === 'super') limitPercent = 95;
                             else if (activeAttack === 'ultimate') limitPercent = 90;
                             // If the slider's value exceeds the limit, force it back down
                             if (parseInt(slider.value) > limitPercent) {
                                 slider.value = limitPercent;
                             }
                            // --- End Enforce Limit ---

                            // Update the text display below the slider (E:, D:)
                            updateSingleSliderDisplay(currentType);
                            // Update the main equation visualization
                            updateEquationDisplay();
                        });
                    }

                    // Regen button listener (identifies type using data attribute)
                    const regenBtn = els.poolDiv?.querySelector('.regen-btn');
                     if (regenBtn) {
                         regenBtn.addEventListener('click', function() {
                             triggerAnimation(this, 'animate__pulse'); // Button feedback
                             regenerateEnergy(this.dataset.type); // Regenerate for the correct type
                         });
                     }
                } else {
                    // Log warning if elements for a type couldn't be found (shouldn't happen normally)
                    console.warn(`Could not find elements for type ${type} to attach listeners.`);
                }
            });

            // Kaioken section listeners
            if (kaiokenCheckbox) {
                kaiokenCheckbox.addEventListener('change', () => {
                    const isChecked = kaiokenCheckbox.checked;
                    kaiokenDetails.classList.toggle('hidden', !isChecked); // Show/hide details
                    if (isChecked) {
                        applyKaiokenStyle(); // Apply red styling
                        updateCurrentHealthDisplay(); // Ensure health is updated/reset
                    } else {
                        removeKaiokenStyle(); // Remove red styling
                    }
                    updateEquationDisplay(); // Update equation (though Kaioken isn't directly shown)
                });
            }
            // Max Health input: Update current health display and equation on change
            if (maxHealthInput) {
                maxHealthInput.addEventListener('input', () => { updateCurrentHealthDisplay(); updateEquationDisplay(); });
                maxHealthInput.addEventListener('change', () => { updateCurrentHealthDisplay(); updateEquationDisplay(); });
            }
            // Kaioken Strain input: Update equation on change (for consistency)
            if (kaiokenStrainInput) {
                kaiokenStrainInput.addEventListener('input', updateEquationDisplay);
            }
            // Regen Health button click: Trigger animation, regenerate health
            if (regenHealthBtn) {
                 regenHealthBtn.addEventListener('click', () => {
                     triggerAnimation(regenHealthBtn, 'animate__pulse'); // Button feedback
                     regenerateHealth(); // Call health regeneration function
                 });
            }

            // Save/Load/Clear Button Listeners with animation feedback
            if (saveBtn) saveBtn.addEventListener('click', () => { triggerAnimation(saveBtn, 'animate__pulse'); saveState(); });
            if (loadBtn) loadBtn.addEventListener('click', () => { triggerAnimation(loadBtn, 'animate__pulse'); loadState(); });
            if (clearBtn) clearBtn.addEventListener('click', () => { triggerAnimation(clearBtn, 'animate__pulse'); clearState(); });

            // Add the single, delegated event listener for clicks within the equation display area
            if (equationDisplayEl) {
                 equationDisplayEl.addEventListener('click', handleEquationClick);
            }

            // Reset Attack Count button listener
            if (resetAttackCountBtn) {
                 resetAttackCountBtn.addEventListener('click', () => {
                     triggerAnimation(resetAttackCountBtn, 'animate__pulse'); // Button feedback
                     attackCount = 0; // Reset the counter variable
                     updateStatsDisplay(); // Update the stats panel display
                     showMessage('Attack count reset.', 'info'); // Optional feedback message
                 });
            }

            // *** NEW: Attack Button Listeners ***
            if (superAttackBtn) superAttackBtn.addEventListener('click', handleAttackButtonClick);
            if (ultimateAttackBtn) ultimateAttackBtn.addEventListener('click', handleAttackButtonClick);

            console.log("Event listeners set up.");
        }


        // --- Initial Setup on Page Load ---
        // This runs once the basic HTML structure is loaded.
        document.addEventListener('DOMContentLoaded', () => {
            // Log initialization start with updated version number
            console.log("DOM Loaded. Initializing Energy Calculator v9.7 (Attack Reservation)...");

            // 0. Initialize attack state storage object
            activeAttacks = {}; // Start with an empty object
            // Explicitly set all known energy types to have no active attack initially
            ALL_ENERGY_TYPES.forEach(type => { activeAttacks[type] = null; });

            // 1. Generate the HTML structure for energy pools and sliders from templates
            generateEnergySections();

            // 2. Initialize energy values based on default inputs (e.g., max energy=1000, multiplier=1)
            // This calculates total/current energy for each pool *before* attempting to load state.
            ALL_ENERGY_TYPES.forEach(type => { calculateAndResetEnergy(type); });

            // 3. Try to load any previously saved state from localStorage
            const stateLoaded = loadState(); // applyState is called within loadState if successful

            // 4. Set up all event listeners for user interactions
            setupEventListeners();

            // 5. Set the initial UI state based on defaults or loaded state
            // Show the correct energy pool (this calls updateAttackButtonStates and updateSliderLimitAndStyle internally)
            showSelectedEnergyPool();
            // Update the stats panel display
            updateStatsDisplay();
            // If no state was loaded, ensure the equation display is updated based on default values
            if (!stateLoaded) {
                updateEquationDisplay();
            }

            // Log completion status
            console.log(`Initialization complete. ${stateLoaded ? '(Saved state loaded)' : '(Using default state)'}`);
        });

    </script>

</body>
</html>
