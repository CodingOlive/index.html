<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Energy Calculator - v12.0 (Multi-Form, Buffs, Speed)</title> <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/12.4.1/math.min.js"></script>
    <link
        rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css"
    />
    <script>
        // Tailwind CSS Configuration
        tailwind.config = {
            theme: {
                extend: {

                    colors: {
                        // Energy types
                        ki: '#FF9800', nen: '#2196F3', chakra: '#9C27B0', magic: '#26a69a', cursed: '#dc2626',
                        reiatsu: '#475569', haki: '#1f2937', alchemy: '#f59e0b', nature: '#84cc16',
                        force: '#d946ef',
                        // NEW Energy Types
                        origin: '#4f46e5',      // Indigo 600
                        fundamental: '#9ca3af', // Gray 400
                        other: '#78350f',      // Amber 900

                        // Darker variants
                        'ki-dark': '#e65100', 'nen-dark': '#0d47a1', 'chakra-dark': '#4a148c', 'magic-dark': '#00796b', 'cursed-dark': '#b91c1c',
                        'reiatsu-dark': '#1e293b', 'haki-dark': '#000000', 'alchemy-dark': '#b45309', 'nature-dark': '#4d7c0f',
                        'force-dark': '#a21caf',
                        // NEW Darker variants
                        'origin-dark': '#3730a3',      // Indigo 800
                        'fundamental-dark': '#6b7280', // Gray 500
                        'other-dark': '#451a03',      // Amber 950

                        // UI feedback colors
                        'success-light': '#e8f5e9', 'success': '#4CAF50', 'success-dark': '#2e7d32',
                        'error-light': '#ffebee', 'error': '#f44336', 'error-dark': '#c62828',
                        // Stats panel specific colors
                        'stats-border': '#60a5fa', 'stats-header': '#1e3a8a',
                        // Kaioken active state colors
                        'kaioken-border': '#f87171', 'kaioken-header': '#b91c1c', 'kaioken-focus': '#ef4444',
                        // Focus Rings
                        'magic-focus': '#26a69a', 'cursed-focus': '#dc2626', 'reiatsu-focus': '#475569',
                        'haki-focus': '#1f2937', 'alchemy-focus': '#f59e0b', 'nature-focus': '#84cc16',
                        'ki-focus': '#FF9800', 'nen-focus': '#2196F3', 'chakra-focus': '#9C27B0',
                        'force-focus': '#d946ef',
                        // NEW Focus Rings
                        'origin-focus': '#4f46e5',
                        'fundamental-focus': '#9ca3af',
                        'other-focus': '#78350f',

                        'teal-focus': '#2dd4bf', // Teal focus for character stats
                        'form-creator-focus': '#a78bfa', // Violet focus for form creator
                        'speed-focus': '#38bdf8', // Speed focus ring
                    },
                    sky: { // Speed colors
                        100: '#e0f2fe',
                        500: '#0ea5e9',
                        600: '#0284c7',
                        700: '#0369a1'
                    },
                    // Animations
                    animation: {
                        spin: 'spin 1s linear infinite', shake: 'shake 0.5s ease-in-out', fadeIn: 'fadeIn 0.3s ease-in', pulse: 'pulse 1.5s infinite',
                        'pulse-additive': 'pulse-additive 0.5s', 'pulse-multiplicative': 'pulse-multiplicative 0.5s', 'pulse-result': 'pulse-result 0.3s ease-in-out',
                        'flash-red': 'flash-red-bg 0.5s ease-out', 'flash-green': 'flash-green-bg 0.5s ease-out', 'kaioken-glow': 'kaioken-glow 1.5s infinite ease-in-out',
                        'animate-pulse-glow-ki': 'pulse-glow-ki 1.5s infinite ease-in-out',
                        'animate-pulse-glow-nen': 'pulse-glow-nen 1.5s infinite ease-in-out',
                        'animate-pulse-glow-chakra': 'pulse-glow-chakra 1.5s infinite ease-in-out',
                        'animate-pulse-glow-magic': 'pulse-glow-magic 1.5s infinite ease-in-out',
                        'animate-pulse-glow-cursed': 'pulse-glow-cursed 1.5s infinite ease-in-out',
                        'animate-pulse-glow-reiatsu': 'pulse-glow-reiatsu 1.5s infinite ease-in-out',
                        'animate-pulse-glow-haki': 'pulse-glow-haki 1.5s infinite ease-in-out',
                        'animate-pulse-glow-alchemy': 'pulse-glow-alchemy 1.5s infinite ease-in-out',
                        'animate-pulse-glow-nature': 'pulse-glow-nature 1.5s infinite ease-in-out',
                        'animate-pulse-glow-force': 'pulse-glow-force 1.5s infinite ease-in-out',
                        'animate-pulse-glow-origin': 'pulse-glow-origin 1.5s infinite ease-in-out',
                        'animate-pulse-glow-fundamental': 'pulse-glow-fundamental 1.5s infinite ease-in-out',
                        'animate-pulse-glow-other': 'pulse-glow-other 1.5s infinite ease-in-out',
                        'animate-pulse-glow-speed': 'pulse-glow-speed 1.5s infinite ease-in-out', // Speed glow anim

                        'animate-pulse-source': 'pulse-source-input 0.8s ease-out',
                        'bounceIn': 'bounceIn 0.75s', 'bounceOut': 'bounceOut 0.75s', 'fadeInUp': 'fadeInUp 0.5s',
                    },
                    // Keyframes
                    keyframes: {
                        spin: { '0%': { transform: 'rotate(0deg)' }, '100%': { transform: 'rotate(360deg)' }, },
                        shake: { '0%, 100%': { transform: 'translateX(0)' }, '25%, 75%': { transform: 'translateX(-5px)' }, '50%': { transform: 'translateX(5px)' }, },
                        fadeIn: { from: { opacity: 0, transform: 'translateY(10px)' }, to: { opacity: 1, transform: 'translateY(0)' }, },
                        pulse: { '0%, 100%': { transform: 'scale(1)' }, '50%': { transform: 'scale(1.05)' }, },
                        'pulse-additive': { '0%, 100%': { color: '#558b2f' }, '50%': { color: '#8BC34A' }, },
                        'pulse-multiplicative': { '0%, 100%': { color: '#e65100' }, '50%': { color: '#FF9800' }, },
                        'pulse-result': { '0%, 100%': { transform: 'scale(1)' }, '50%': { transform: 'scale(1.05)' }, },
                        'flash-red-bg': { '50%': { backgroundColor: '#ffebee', borderColor: '#f44336' } },
                        'flash-green-bg': { '50%': { backgroundColor: '#e8f5e9', borderColor: '#4CAF50' } },
                        'kaioken-glow': { '0%, 100%': { boxShadow: `0 0 10px #f8717180` }, '50%': { boxShadow: `0 0 20px #f87171CC` } },
                         'pulse-glow-ki': { '0%, 100%': { boxShadow: `0 0 8px #FF980066` }, '50%': { boxShadow: `0 0 16px #FF9800B3` } },
                         'pulse-glow-nen': { '0%, 100%': { boxShadow: `0 0 8px #2196F366` }, '50%': { boxShadow: `0 0 16px #2196F3B3` } },
                         'pulse-glow-chakra': { '0%, 100%': { boxShadow: `0 0 8px #9C27B066` }, '50%': { boxShadow: `0 0 16px #9C27B0B3` } },
                         'pulse-glow-magic': { '0%, 100%': { boxShadow: `0 0 8px #26a69a66` }, '50%': { boxShadow: `0 0 16px #26a69aB3` } },
                         'pulse-glow-cursed': { '0%, 100%': { boxShadow: `0 0 8px #dc262666` }, '50%': { boxShadow: `0 0 16px #dc2626B3` } },
                         'pulse-glow-reiatsu': { '0%, 100%': { boxShadow: `0 0 8px #47556966` }, '50%': { boxShadow: `0 0 16px #475569B3` } },
                         'pulse-glow-haki': { '0%, 100%': { boxShadow: `0 0 8px #1f293766` }, '50%': { boxShadow: `0 0 16px #1f2937B3` } },
                         'pulse-glow-alchemy': { '0%, 100%': { boxShadow: `0 0 8px #f59e0b66` }, '50%': { boxShadow: `0 0 16px #f59e0bB3` } },
                         'pulse-glow-nature': { '0%, 100%': { boxShadow: `0 0 8px #84cc1666` }, '50%': { boxShadow: `0 0 16px #84cc16B3` } },
                         'pulse-glow-force': { '0%, 100%': { boxShadow: `0 0 8px #d946ef66` }, '50%': { boxShadow: `0 0 16px #d946efB3` } },
                         'pulse-glow-origin': { '0%, 100%': { boxShadow: `0 0 8px #4f46e566` }, '50%': { boxShadow: `0 0 16px #4f46e5B3` } }, // Indigo
                         'pulse-glow-fundamental': { '0%, 100%': { boxShadow: `0 0 8px #9ca3af66` }, '50%': { boxShadow: `0 0 16px #9ca3afB3` } }, // Gray
                         'pulse-glow-other': { '0%, 100%': { boxShadow: `0 0 8px #78350f66` }, '50%': { boxShadow: `0 0 16px #78350fB3` } }, // Amber
                         'pulse-glow-speed': { '0%, 100%': { boxShadow: `0 0 8px #0ea5e966` }, '50%': { boxShadow: `0 0 16px #0ea5e9B3` } }, // Speed glow

                         'pulse-source-input': { '0%, 100%': { boxShadow: 'none' }, '50%': { boxShadow: '0 0 12px theme("colors.blue.400")' } },
                         'shakeX': { /* Uses animate.css definition */ },
                         'bounceIn': { /* Uses animate.css definition */ },
                         'bounceOut': { /* Uses animate.css definition */ },
                         'fadeInUp': { /* Uses animate.css definition */ },
                    }
                }
            }
        }
    </script>
    <link rel="preconnect" href="https://rsms.me/">
    <link rel="stylesheet" href="https://rsms.me/inter/inter.css">
    <style>
        /* Base Styles */
        body { font-family: 'Inter', sans-serif; background-color: #f9f9f9; color: #333; }
        /* Base style for energy pool sections */
        .energy-pool { @apply p-5 mb-5 rounded-lg shadow-sm border-l-4; transition: box-shadow 0.3s ease-in-out, opacity 0.3s ease-in-out; }

        /* Dynamic Pool Styles */
        .energy-pool-ki { border-left-color: #FF9800; } .energy-pool-ki h3 { color: #e65100; }
        .energy-pool-nen { border-left-color: #2196F3; } .energy-pool-nen h3 { color: #0d47a1; }
        .energy-pool-chakra { border-left-color: #9C27B0; } .energy-pool-chakra h3 { color: #4a148c; }
        .energy-pool-magic { border-left-color: #26a69a; } .energy-pool-magic h3 { color: #00796b; }
        .energy-pool-cursed { border-left-color: #dc2626; } .energy-pool-cursed h3 { color: #b91c1c; }
        .energy-pool-reiatsu { border-left-color: #475569; } .energy-pool-reiatsu h3 { color: #1e293b; }
        .energy-pool-haki { border-left-color: #1f2937; } .energy-pool-haki h3 { color: #000000; }
        .energy-pool-alchemy { border-left-color: #f59e0b; } .energy-pool-alchemy h3 { color: #b45309; }
        .energy-pool-nature { border-left-color: #84cc16; } .energy-pool-nature h3 { color: #4d7c0f; }
        .energy-pool-force { border-left-color: #d946ef; } .energy-pool-force h3 { color: #a21caf; }
        /* NEW Pool Styles */
        .energy-pool-origin { border-left-color: #4f46e5; } .energy-pool-origin h3 { color: #3730a3; } /* Indigo */
        .energy-pool-fundamental { border-left-color: #9ca3af; } .energy-pool-fundamental h3 { color: #6b7280; } /* Gray */
        .energy-pool-other { border-left-color: #78350f; } .energy-pool-other h3 { color: #451a03; } /* Amber */

        /* Base Slider Track Style */
        .energy-slider {
            @apply w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer;
            transition: background 0.2s ease-in-out;
            }
        /* Base Slider Thumb Style */
        .energy-slider::-webkit-slider-thumb { appearance: none; width: 20px; height: 20px; border-radius: 50%; cursor: pointer; box-shadow: 0 1px 3px rgba(0,0,0,0.2); transition: background 0.3s; border: none; background: #9ca3af; }
        .energy-slider::-moz-range-thumb { width: 20px; height: 20px; border-radius: 50%; cursor: pointer; box-shadow: 0 1px 3px rgba(0,0,0,0.2); transition: background 0.3s; border: none; background: #9ca3af; }

        /* Slider Thumb Colors */
        #ki-energy-slider::-webkit-slider-thumb { background: #FF9800; } #ki-energy-slider::-moz-range-thumb { background: #FF9800; }
        #nen-energy-slider::-webkit-slider-thumb { background: #2196F3; } #nen-energy-slider::-moz-range-thumb { background: #2196F3; }
        #chakra-energy-slider::-webkit-slider-thumb { background: #9C27B0; } #chakra-energy-slider::-moz-range-thumb { background: #9C27B0; }
        #magic-energy-slider::-webkit-slider-thumb { background: #26a69a; } #magic-energy-slider::-moz-range-thumb { background: #26a69a; }
        #cursed-energy-slider::-webkit-slider-thumb { background: #dc2626; } #cursed-energy-slider::-moz-range-thumb { background: #dc2626; }
        #reiatsu-energy-slider::-webkit-slider-thumb { background: #475569; } #reiatsu-energy-slider::-moz-range-thumb { background: #475569; }
        #haki-energy-slider::-webkit-slider-thumb { background: #1f2937; } #haki-energy-slider::-moz-range-thumb { background: #1f2937; }
        #alchemy-energy-slider::-webkit-slider-thumb { background: #f59e0b; } #alchemy-energy-slider::-moz-range-thumb { background: #f59e0b; }
        #nature-energy-slider::-webkit-slider-thumb { background: #84cc16; } #nature-energy-slider::-moz-range-thumb { background: #84cc16; }
        #force-energy-slider::-webkit-slider-thumb { background: #d946ef; } #force-energy-slider::-moz-range-thumb { background: #d946ef; }
        /* NEW Slider Thumb Colors */
        #origin-energy-slider::-webkit-slider-thumb { background: #4f46e5; } #origin-energy-slider::-moz-range-thumb { background: #4f46e5; } /* Indigo */
        #fundamental-energy-slider::-webkit-slider-thumb { background: #9ca3af; } #fundamental-energy-slider::-moz-range-thumb { background: #9ca3af; } /* Gray */
        #other-energy-slider::-webkit-slider-thumb { background: #78350f; } #other-energy-slider::-moz-range-thumb { background: #78350f; } /* Amber */
        /* Speed Slider Thumb Color */
        #speed-slider::-webkit-slider-thumb { background: theme('colors.sky.500'); } #speed-slider::-moz-range-thumb { background: theme('colors.sky.500'); }

        /* Slider Thumb Hover Colors */
        #ki-energy-slider:hover::-webkit-slider-thumb { background: #e65100; } #ki-energy-slider:hover::-moz-range-thumb { background: #e65100; }
        #nen-energy-slider:hover::-webkit-slider-thumb { background: #0d47a1; } #nen-energy-slider:hover::-moz-range-thumb { background: #0d47a1; }
        #chakra-energy-slider:hover::-webkit-slider-thumb { background: #4a148c; } #chakra-energy-slider:hover::-moz-range-thumb { background: #4a148c; }
        #magic-energy-slider:hover::-webkit-slider-thumb { background: #00796b; } #magic-energy-slider:hover::-moz-range-thumb { background: #00796b; }
        #cursed-energy-slider:hover::-webkit-slider-thumb { background: #b91c1c; } #cursed-energy-slider:hover::-moz-range-thumb { background: #b91c1c; }
        #reiatsu-energy-slider:hover::-webkit-slider-thumb { background: #1e293b; } #reiatsu-energy-slider:hover::-moz-range-thumb { background: #1e293b; }
        #haki-energy-slider:hover::-webkit-slider-thumb { background: #000000; } #haki-energy-slider:hover::-moz-range-thumb { background: #000000; }
        #alchemy-energy-slider:hover::-webkit-slider-thumb { background: #b45309; } #alchemy-energy-slider:hover::-moz-range-thumb { background: #b45309; }
        #nature-energy-slider:hover::-webkit-slider-thumb { background: #4d7c0f; } #nature-energy-slider:hover::-moz-range-thumb { background: #4d7c0f; }
        #force-energy-slider:hover::-webkit-slider-thumb { background: #a21caf; } #force-energy-slider:hover::-moz-range-thumb { background: #a21caf; }
        /* NEW Slider Thumb Hover Colors */
        #origin-energy-slider:hover::-webkit-slider-thumb { background: #3730a3; } #origin-energy-slider:hover::-moz-range-thumb { background: #3730a3; } /* Indigo Dark */
        #fundamental-energy-slider:hover::-webkit-slider-thumb { background: #6b7280; } #fundamental-energy-slider:hover::-moz-range-thumb { background: #6b7280; } /* Gray Dark */
        #other-energy-slider:hover::-webkit-slider-thumb { background: #451a03; } #other-energy-slider:hover::-moz-range-thumb { background: #451a03; } /* Amber Dark */
        /* Speed Slider Thumb Hover Color */
        #speed-slider:hover::-webkit-slider-thumb { background: theme('colors.sky.600'); } #speed-slider:hover::-moz-range-thumb { background: theme('colors.sky.600'); }

        /* Dynamic Modifier Box Styles */
        .modifier-type-option.additive { border-color: theme('colors.success'); color: theme('colors.success-dark'); }
        .modifier-type-option.additive.active { background-color: theme('colors.success-light'); box-shadow: 0 1px 5px rgba(76, 175, 80, 0.3); animation: pulse-additive 0.5s; color: theme('colors.success'); }
        .modifier-type-option.multiplicative { border-color: theme('colors.ki'); color: theme('colors.ki-dark'); }
        .modifier-type-option.multiplicative.active { background-color: theme('colors.ki / 0.1'); box-shadow: 0 1px 5px rgba(255, 152, 0, 0.3); animation: pulse-multiplicative 0.5s; color: theme('colors.ki'); }

        /* Custom Animation Classes */
        .animate-pulse-result { animation: pulse-result 0.3s ease-in-out; }
        .animate-flash-red { animation: flash-red-bg 0.5s ease-out; }
        .animate-flash-green { animation: flash-green-bg 0.5s ease-out; }
        .animate-kaioken-glow { animation: kaioken-glow 1.5s infinite ease-in-out; }

        /* Static Glow classes for energy pools */
        .static-glow-ki { box-shadow: 0 0 10px #FF980080; } .static-glow-nen { box-shadow: 0 0 10px #2196F380; } .static-glow-chakra { box-shadow: 0 0 10px #9C27B080; } .static-glow-magic { box-shadow: 0 0 10px #26a69a80; } .static-glow-cursed { box-shadow: 0 0 10px #dc262680; } .static-glow-reiatsu { box-shadow: 0 0 10px #47556980; } .static-glow-haki { box-shadow: 0 0 10px #1f293780; } .static-glow-alchemy { box-shadow: 0 0 10px #f59e0b80; } .static-glow-nature { box-shadow: 0 0 10px #84cc1680; }
        .static-glow-force { box-shadow: 0 0 10px #d946ef80; }
        /* NEW Static Glow Classes */
        .static-glow-origin { box-shadow: 0 0 10px #4f46e580; }
        .static-glow-fundamental { box-shadow: 0 0 10px #9ca3af80; }
        .static-glow-other { box-shadow: 0 0 10px #78350f80; }

        /* Accessibility utility class */
        .sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 0, 0); white-space: nowrap; border-width: 0; }
        /* Stats Panel Styling */
        .stats-panel { border-left-width: 4px; transition: border-color 0.3s ease-in-out, box-shadow 1.5s ease-in-out; }
        .stats-panel-header { transition: color 0.3s ease-in-out; }
        /* Common Label Style */
        .lbl { @apply block mb-1 font-medium text-sm text-gray-600; }
        /* Common Input Style */
        .inpt { @apply w-full p-2 border border-gray-300 rounded-md focus:ring-2 focus:border-transparent text-sm transition-colors duration-300; }
        /* Common Select Style */
        .slct { @apply w-full p-2 border border-gray-300 rounded-md focus:ring-2 focus:border-transparent text-sm bg-white; }

        /* Input Readonly Style */
        .inpt:read-only, .slct:disabled { @apply bg-gray-100 cursor-not-allowed opacity-70; }
        /* Common Regen Button Style */
        .regen-btn { @apply px-3 py-2 text-white rounded-md focus:outline-none focus:ring-2 focus:ring-offset-2 transition-all duration-150 ease-in-out text-sm font-semibold shadow-sm active:scale-95; }
        /* Save/Load Button Style */
        .save-load-btn { @apply px-3 py-1 text-sm text-white rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-offset-1 transition-all duration-150 ease-in-out active:scale-95; }

        /* Style for span elements used as read-only displays */
        .readonly-display {
            @apply inline-block font-medium text-gray-800 min-h-[42px] px-2 py-2 w-full bg-gray-50 rounded-md border border-gray-200;
            line-height: 1.5; /* Vertically center text */
            word-break: break-all; /* Prevent layout breaks */
        }

        /* Equation Display Styles */
        .equation-number {
            @apply font-semibold text-blue-600 hover:text-blue-800 underline transition-colors duration-150;
            cursor: pointer;
        }
        .equation-number:hover {
             text-shadow: 0 0 8px rgba(147, 197, 253, 0.8); /* blue-300 with alpha */
        }
        .equation-operator { @apply text-gray-600 mx-1; }
        .equation-group { @apply mx-0.5; }

        /* Animation for pulsing the source input linked from equation */
        .animate-pulse-source {
            animation: pulse-source-input 0.8s ease-out;
        }

        /* Attack Button Active State */
        .attack-btn.active {
            @apply ring-2 ring-offset-2 scale-105 brightness-110; /* Add ring, slightly enlarge, and brighten */
        }
        #super-attack-btn.active {
            @apply ring-blue-600 bg-blue-700; /* Specific active style for super */
        }
        #ultimate-attack-btn.active {
            @apply ring-purple-600 bg-purple-700; /* Specific active style for ultimate */
        }

        /* Form Creator Specific Styles */
        .form-creator-input { @apply focus:ring-form-creator-focus; }
        .form-creator-button { @apply px-4 py-2 bg-purple-600 text-white rounded-md hover:bg-purple-700 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-offset-2 transition-all duration-150 ease-in-out text-sm font-semibold shadow-sm active:scale-95; }

        /* Form List Styles (Stats Panel) */
        .form-list-group h4 { @apply text-sm font-semibold text-gray-600 mt-2 mb-1 border-b border-gray-200 pb-1; }
        .form-list-item {
             @apply inline-block text-xs bg-gray-100 text-gray-700 border border-gray-300 rounded px-1.5 py-0.5 mr-1 mb-1;
        }

        /* Active Forms Section Styling (Main Area) */
        #active-forms-section {
            @apply border-l-purple-400 bg-purple-50/50; /* Match color with form creator, add slight bg */
        }
        #active-forms-list label:hover {
             @apply text-purple-700 cursor-pointer; /* Indicate interactivity */
        }
        #active-forms-list {
             @apply grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-x-4 gap-y-1; /* Responsive grid layout */
        }
        #active-forms-list > div {
             @apply min-w-0; /* Prevent grid blowout */
        }
         #active-forms-list label {
             @apply truncate; /* Truncate long form names */
         }


    </style>
</head>
<body class="p-4 md:p-6">

    <div class="mb-4 flex flex-wrap gap-2">
       <button id="google-signin-btn" class="save-load-btn bg-red-600 hover:bg-red-700 focus:ring-red-500">Sign in with Google</button>
        <button id="sign-out-btn" class="save-load-btn bg-gray-700 hover:bg-gray-800 focus:ring-gray-600 hidden">Sign Out</button>
        <span id="user-info" class="text-sm text-gray-600 self-center ml-2">Not signed in.</span>
        <button id="save-state-btn" class="save-load-btn bg-blue-500 hover:bg-blue-600 focus:ring-blue-400">Save State</button>
        <button id="load-state-btn" class="save-load-btn bg-gray-500 hover:bg-gray-600 focus:ring-gray-400">Load State</button>
        <button id="clear-state-btn" class="save-load-btn bg-red-500 hover:bg-red-600 focus:ring-red-400">Clear Saved</button>
        <button id="show-character-stats-btn" class="save-load-btn bg-teal-500 hover:bg-teal-600 focus:ring-teal-400">Character Stats</button>
    </div>
    <h1 class="text-3xl font-bold mb-6 text-center text-gray-800">Energy Calculator</h1>
    <div id="main-calculator-content">
        <div class="flex flex-col md:flex-row gap-6 max-w-7xl mx-auto">

            <div class="flex-grow md:w-3/4">

                <div id="message-area" class="mb-4 p-3 rounded-md text-sm hidden" role="alert"></div>

                <div class="energy-pool bg-white p-5 mb-5 rounded-lg shadow-sm border-l-4 border-gray-400"> <h3 class="text-xl font-semibold mb-4 flex items-center">
                        Damage Modifiers
                        <span class="flex-grow h-px bg-gray-200 ml-3"></span> </h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                        <div><label for="base-damage" class="lbl">Base Damage:</label><input type="text" id="base-damage" placeholder="e.g., 100" aria-required="true" class="inpt focus:ring-success"></div>
                        <div><label for="attack-compression-points" class="lbl">Attack Compression Points:</label><input type="text" id="attack-compression-points" placeholder="e.g., 10" value="0" class="inpt focus:ring-red-500"></div>
                        <div><label for="base-multiplier" class="lbl">Base Multiplier:</label><input type="text" id="base-multiplier" placeholder="e.g., 1.5" value="1" class="inpt focus:ring-success"></div>
                        <div><label for="form-multiplier" class="lbl">Form Multiplier:</label><input type="text" id="form-multiplier" placeholder="From Active Form(s)" value="1" class="inpt focus:ring-success bg-gray-100" readonly title="Combined multiplier from active forms"></div> </div>
                    <div id="dynamic-modifiers-container" class="mb-4"><h4 class="text-md font-semibold mb-2 text-gray-700">Additional Factors:</h4></div>
                    <button id="add-dynamic-box" aria-label="Add modifier factor" class="px-4 py-2 bg-chakra text-white rounded-md hover:bg-chakra-dark focus:outline-none focus:ring-2 focus:ring-chakra focus:ring-offset-2 transition-all duration-150 ease-in-out text-sm font-semibold shadow-sm active:scale-95">
                        Add Factor
                    </button>
                </div>
                <div id="active-forms-section" class="bg-purple-50/50 p-5 mb-5 rounded-lg shadow-sm border-l-4 border-purple-400"> <h3 class="text-xl font-semibold mb-4 flex items-center text-purple-800">
                    Active Forms
                    <span class="flex-grow h-px bg-gray-200 ml-3"></span>
                </h3>
                <div id="active-forms-list" class="space-y-2 max-h-48 overflow-y-auto grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-x-4 gap-y-1"> <p class="text-gray-500 text-sm col-span-full">No forms created yet.</p> </div>
            </div>
            <div class="form-group mb-5">
                <label for="energy-type" class="lbl">Energy Type Focus:</label> <select id="energy-type" aria-label="Select focused energy type" class="slct focus:ring-success">
                    <option value="ki">Ki Energy</option>
                    <option value="nen">Nen Energy</option>
                    <option value="chakra">Chakra Energy</option>
                    <option value="magic">Magic Energy</option>
                    <option value="cursed">Cursed Energy</option>
                    <option value="reiatsu">Reiatsu</option>
                    <option value="haki">Haki</option>
                    <option value="alchemy">Alchemy</option>
                    <option value="nature">Nature Energy</option>
                    <option value="force">Force Energy</option>
                    <option value="origin">Origin Energy</option>
                    <option value="fundamental">Fundamental Energy</option>
                    <option value="other">Other Energy</option>
                </select>
            </div>

            <div id="energy-pools-container" class="mb-5">
                </div>
                <div id="attacks-section" class="bg-white p-5 mb-5 rounded-lg shadow-sm">
               <h3 class="text-xl font-semibold mb-4 text-gray-700 border-b pb-2">Attacks</h3>
               <div class="flex flex-col sm:flex-row gap-3">
                   <button id="super-attack-btn" data-attack-type="super" data-reserve-percent="5" class="attack-btn flex-1 px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-400 focus:ring-offset-2 transition-all duration-150 ease-in-out text-sm font-semibold shadow-sm active:scale-95">
                       Super Attack (Reserves 5%)
                      </button>
                      <button id="ultimate-attack-btn" data-attack-type="ultimate" data-reserve-percent="10" class="attack-btn flex-1 px-4 py-2 bg-purple-500 text-white rounded-md hover:bg-purple-600 focus:outline-none focus:ring-2 focus:ring-purple-400 focus:ring-offset-2 transition-all duration-150 ease-in-out text-sm font-semibold shadow-sm active:scale-95">
                       Ultimate Attack (Reserves 10%)
                      </button>
               </div>
               <p id="attack-status-message" class="text-xs text-gray-500 mt-2 min-h-[1.25rem]"></p>
              </div>
              <div id="all-sliders-container" class="bg-white p-5 mb-5 rounded-lg shadow-sm">
                 <h3 class="text-xl font-semibold mb-4 text-gray-700 border-b pb-2">Usage Sliders</h3>
                 <div id="sliders-grid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-x-6 gap-y-4">
                     </div>
              </div>
              <button id="calculate-btn" aria-label="Calculate final damage value" class="w-full px-4 py-3 bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 transition-all duration-150 ease-in-out text-lg font-semibold shadow-md mb-5 active:scale-95">
               Calculate Damage
              </button>

              <div id="loading" class="loading text-center p-5 hidden">
               <div class="loading-spinner inline-block w-8 h-8 border-4 border-t-success border-gray-200 rounded-full animate-spin" aria-hidden="true"></div>
               <div class="loading-text mt-2 text-gray-600">Calculating...</div><span class="sr-only">Loading, please wait</span>
              </div>

              <div id="result" class="result bg-success-light p-5 rounded-lg border-l-4 border-success shadow-sm hidden" aria-live="polite">
               <div class="result-title text-lg font-semibold mb-2 text-success-dark">Calculated Damage:</div>
               <div id="result-value" class="result-value text-3xl font-bold mb-3 break-words">0</div>
               <div id="result-details" class="result-details text-sm text-gray-700 mt-3 border-t border-success/30 pt-3">
                   <p><strong>Total Energy Used:</strong> <span id="result-total-energy-used">0</span></p>
                   <p><strong>Total Extra Damage (Energy + Speed):</strong> <span id="result-total-extra-damage">0.00</span></p> <div class="mt-3 pt-3 border-t border-success/20">
                       <p class="font-semibold mb-1">Calculation:</p>
                       <div id="equation-display" class="text-sm bg-gray-50 p-2 rounded border border-gray-200 break-words leading-relaxed">
                           Equation not yet calculated.
                          </div>
                   </div>
                   <hr class="my-2 border-success/20"> <p><strong>Scientific Notation:</strong> <span id="result-scientific">0</span></p>
                   <p><strong>In Words:</strong> <span id="result-words">Zero</span></p>
               </div>
              </div>

          </div>
            <div id="stats-panel" class="stats-panel md:w-1/4 lg:w-1/5 p-5 bg-white rounded-lg shadow-sm self-start sticky top-6 border-stats-border">
              <h3 id="stats-panel-header" class="stats-panel-header text-xl font-semibold mb-4 flex items-center text-stats-header">
                  Stats
                  <span class="flex-grow h-px bg-gray-200 ml-3"></span> </h3>
              <div class="space-y-3">
                  <p class="text-sm text-gray-600">Selected Current Energy: <span id="stat-current-energy" class="font-medium text-gray-800 break-words">0</span></p>
                  <hr class="border-gray-200">
                  <p class="text-sm text-gray-600">Total Damage Dealt: <span id="stat-total-damage" class="font-medium text-gray-800 break-words">0</span></p>
                  <p class="text-sm text-gray-600">Total Energy Spent: <span id="stat-total-energy-spent" class="font-medium text-gray-800 break-words">0</span></p>
                  <p class="text-sm text-gray-600">Highest Damage: <span id="stat-highest-damage" class="font-medium text-gray-800 break-words">0</span></p>
                  <div class="flex items-center justify-between text-sm text-gray-600">
                      <span>Number of Attacks: <span id="stat-attack-count" class="font-medium text-gray-800 break-words">0</span></span>
                      <button id="reset-attack-count-btn" title="Reset Attack Count" class="px-2 py-0.5 text-xs bg-gray-200 hover:bg-red-200 text-gray-600 hover:text-red-700 rounded focus:outline-none focus:ring-1 focus:ring-red-400 focus:ring-offset-1 transition-colors duration-150 active:scale-95">
                          Reset?
                      </button>
                  </div>
                  <hr class="border-gray-200">
                   <p class="text-sm text-gray-600">Form AC Bonus: <span id="stat-form-ac-bonus" class="font-medium text-gray-800 break-words">0</span></p>
                   <p class="text-sm text-gray-600">Form TR Bonus: <span id="stat-form-tr-bonus" class="font-medium text-gray-800 break-words">0</span></p>
                   <p class="text-sm text-gray-600">Total AC: <span id="stat-total-ac" class="font-medium text-gray-800 break-words">0</span></p>
                   <p class="text-sm text-gray-600">Total TR: <span id="stat-total-tr" class="font-medium text-gray-800 break-words">0</span></p>
                   <p class="text-sm text-gray-600">Speed: <span id="stat-speed" class="font-medium text-gray-800 break-words">0</span></p> <hr class="border-gray-200">
                  <div id="kaioken-section" class="hidden pt-3 border-t border-gray-200">
                      <div class="flex items-center gap-2 mb-3">
                          <input type="checkbox" id="kaioken-checkbox" class="rounded border-gray-300 text-red-600 shadow-sm focus:ring-kaioken-focus">
                          <label for="kaioken-checkbox" class="text-sm font-medium text-kaioken-header">Kaioken?</label>
                      </div>
                      <div id="kaioken-details" class="hidden space-y-2">
                          <div class="flex items-center gap-2">
                              <div class="flex-grow">
                                  <label for="max-health" class="lbl">Max Health:</label>
                                  <input type="text" id="max-health" placeholder="e.g., 1000" value="1000" class="inpt focus:ring-kaioken-focus">
                              </div>
                              <button id="regen-health-btn" title="Regenerate Health to Max" class="px-2 py-1 text-xs bg-success hover:bg-success-dark text-white rounded-md focus:outline-none focus:ring-2 focus:ring-success focus:ring-offset-1 self-end mb-1 transition-transform active:scale-95">Regen Health</button>
                          </div>
                          <div><label for="kaioken-strain" class="lbl">Kaioken Strain (% Max HP):</label><input type="text" id="kaioken-strain" placeholder="e.g., 10" value="10" class="inpt focus:ring-kaioken-focus"></div>
                          <div>
                              <label class="lbl">Current Health:</label>
                              <span id="current-health" class="readonly-display current-health">1000</span>
                          </div>
                      </div>
                  </div>

               <div id="formListSection" class="pt-3 border-t border-gray-200">
                   <h4 class="text-md font-semibold mb-2 text-gray-700">Saved Forms</h4>
                   <div id="formListContainer" class="max-h-48 overflow-y-auto text-xs">
                       <p class="text-gray-500">No forms created yet.</p>
                      </div>
               </div>
              </div>
          </div> </div> </div> 
<div id="character-stats-screen" class="hidden bg-white p-6 rounded-lg shadow-md max-w-7xl mx-auto mt-6 border border-gray-200">
      <div class="flex justify-between items-center mb-4 border-b pb-2">
          <h2 class="text-2xl font-bold text-gray-700">Character Stats</h2>
      </div>
      <div class="flex justify-center items-center flex-col mt-8">
          <label for="character-name" class="lbl text-lg mb-2">Character Name:</label>
          <input type="text" id="character-name" placeholder="Enter character name" class="inpt w-full md:w-1/2 lg:w-1/3 p-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-teal-focus focus:border-transparent text-center">
      </div>
      <div id="character-stats-inputs" class="mt-6 grid grid-cols-1 md:grid-cols-2 gap-x-6 gap-y-4">
          <div>
              <label for="char-base-health" class="lbl">Base Health:</label>
              <input type="text" id="char-base-health" placeholder="e.g., 1000" class="inpt focus:ring-teal-focus">
          </div>
           <div>
              <label for="char-base-multiplier" class="lbl">Base Multiplier:</label>
              <input type="text" id="char-base-multiplier" placeholder="e.g., 1" value="1" class="inpt focus:ring-teal-focus">
          </div>
          <div class="md:col-span-2 flex items-center gap-2 mt-1 -mb-2"> <input type="checkbox" id="ryoko-checkbox" class="h-4 w-4 rounded border-gray-300 text-teal-600 focus:ring-teal-500">
              <label for="ryoko-checkbox" class="text-sm text-gray-700 select-none">Are you Ryoko?</label>
          </div>
           <div id="ryoko-equation-input-container" class="hidden md:col-span-2 mt-2"> <label for="ryoko-equation-input" class="lbl text-red-600">Type out your shit equation:</label> <input type="text" id="ryoko-equation-input" placeholder="Enter equation value..." class="inpt focus:ring-red-500 border-red-300"> </div>
          <div>
              <label for="char-vitality" class="lbl">Vitality:</label>
              <input type="text" id="char-vitality" placeholder="e.g., 50" class="inpt focus:ring-teal-focus">
          </div>
          <div>
              <label for="char-soul-power" class="lbl">Soul Power:</label>
              <input type="text" id="char-soul-power" placeholder="e.g., 100" class="inpt focus:ring-teal-focus">
          </div>
          <div>
              <label for="char-soul-hp" class="lbl">Soul HP:</label>
              <input type="text" id="char-soul-hp" placeholder="e.g., 200" class="inpt focus:ring-teal-focus">
          </div>
          <div>
              <label for="char-base-ac" class="lbl">Base AC:</label>
              <input type="text" id="char-base-ac" placeholder="e.g., 10" value="10" class="inpt focus:ring-teal-focus">
          </div>
           <div>
              <label for="char-base-tr" class="lbl">Base True Resistance:</label>
              <input type="text" id="char-base-tr" placeholder="e.g., 5" value="5" class="inpt focus:ring-teal-focus">
          </div>
           <div>
               <label for="char-speed" class="lbl">Speed:</label>
               <input type="text" id="char-speed" placeholder="e.g., 100" class="inpt focus:ring-teal-focus">
           </div>
      </div>

      <div id="formCreatorSection" class="mt-8 pt-6 border-t border-gray-200">
          <h3 class="text-xl font-semibold mb-4 text-gray-700">Form Creator</h3>
          <div class="grid grid-cols-1 md:grid-cols-2 gap-x-6 gap-y-4 bg-gray-50 p-4 rounded-md border border-gray-200">
              <div>
                  <label for="formNameInput" class="lbl">Form Name:</label>
                  <input type="text" id="formNameInput" placeholder="e.g., Super Saiyan 1" class="inpt form-creator-input">
              </div>
              <div>
                  <label for="formEnergyTypeSelect" class="lbl">Form Energy Type:</label>
                  <select id="formEnergyTypeSelect" class="slct form-creator-input">
                      <option value="None">None (Applies to All)</option>
                      <option value="ki">Ki</option>
                      <option value="nen">Nen</option>
                      <option value="chakra">Chakra</option>
                      <option value="magic">Magic</option>
                      <option value="cursed">Cursed</option>
                      <option value="reiatsu">Reiatsu</option>
                      <option value="haki">Haki</option>
                      <option value="alchemy">Alchemy</option>
                      <option value="nature">Nature</option>
                      <option value="force">Force</option>
                      <option value="origin">Origin</option>
                      <option value="fundamental">Fundamental</option>
                      <option value="other">Other</option>
                  </select>
              </div>
              <div>
                  <label for="formFormMultiplierInput" class="lbl">Form Multiplier (Main):</label>
                  <input type="number" id="formFormMultiplierInput" value="1" step="0.1" class="inpt form-creator-input">
              </div>
              <div>
                  <label for="formPoolMaxMultiplierInput" class="lbl">Pool Max Multiplier:</label>
                  <input type="number" id="formPoolMaxMultiplierInput" value="1" step="0.1" class="inpt form-creator-input">
              </div>

              <div class="md:col-span-2">
                  <label for="formAffectsResistancesCheckbox" class="flex items-center gap-2">
                      <input type="checkbox" id="formAffectsResistancesCheckbox" class="h-4 w-4 rounded border-gray-300 text-purple-600 focus:ring-purple-500">
                      <span class="lbl mb-0">Affects Resistances?</span>
                  </label>
              </div>
              <div id="formResistanceBonusInputs" class="hidden md:col-span-2 grid grid-cols-1 md:grid-cols-2 gap-x-6 gap-y-4 pl-6 border-l-2 border-purple-200">
                  <div>
                      <label for="formAcBonusInput" class="lbl">AC Bonus:</label>
                      <input type="number" id="formAcBonusInput" value="0" class="inpt form-creator-input">
                  </div>
                  <div>
                      <label for="formTrueResistanceBonusInput" class="lbl">True Resistance Bonus:</label>
                      <input type="number" id="formTrueResistanceBonusInput" value="0" class="inpt form-creator-input">
                  </div>
              </div>

              <div class="md:col-span-2 mt-4 pt-4 border-t border-purple-200">
                   <h4 class="text-md font-semibold mb-3 text-purple-700">Form Buff Per Turn (On Calculate)</h4>
                   <div class="grid grid-cols-1 md:grid-cols-2 gap-x-6 gap-y-4">
                       <div class="space-y-2 p-3 border border-purple-100 rounded-md bg-white">
                            <label class="flex items-center gap-2">
                                <input type="checkbox" id="formEnableFormBuff" class="h-4 w-4 rounded border-gray-300 text-purple-600 focus:ring-purple-500">
                                <span class="lbl mb-0 font-medium">Buff Form Multiplier?</span>
                            </label>
                            <div class="pl-6 space-y-2">
                                <div>
                                     <label for="formFormBuffValue" class="lbl text-xs">Buff Value:</label>
                                     <input type="number" id="formFormBuffValue" value="0" step="0.01" class="inpt form-creator-input text-xs p-1">
                                </div>
                                <div>
                                     <label for="formFormBuffType" class="lbl text-xs">Buff Type:</label>
                                     <select id="formFormBuffType" class="slct form-creator-input text-xs p-1">
                                          <option value="add">Add (+)</option>
                                          <option value="multiply">Multiply (x)</option>
                                     </select>
                                </div>
                           </div>
                       </div>
                       <div class="space-y-2 p-3 border border-purple-100 rounded-md bg-white">
                            <label class="flex items-center gap-2">
                                <input type="checkbox" id="formEnablePoolBuff" class="h-4 w-4 rounded border-gray-300 text-purple-600 focus:ring-purple-500">
                                <span class="lbl mb-0 font-medium">Buff Pool Max Multiplier?</span>
                            </label>
                             <div class="pl-6 space-y-2">
                                <div>
                                     <label for="formPoolBuffValue" class="lbl text-xs">Buff Value:</label>
                                     <input type="number" id="formPoolBuffValue" value="0" step="0.01" class="inpt form-creator-input text-xs p-1">
                                </div>
                                <div>
                                     <label for="formPoolBuffType" class="lbl text-xs">Buff Type:</label>
                                     <select id="formPoolBuffType" class="slct form-creator-input text-xs p-1">
                                          <option value="add">Add (+)</option>
                                          <option value="multiply">Multiply (x)</option>
                                     </select>
                                </div>
                           </div>
                       </div>
                   </div>
              </div>
              <div class="md:col-span-2 mt-4">
                  <button id="addFormButton" class="form-creator-button w-full md:w-auto">Add This Form</button>
              </div>
          </div>
      </div>
  </div> 
    <template id="energy-pool-template">
        <div class="energy-pool bg-gradient-to-br from-white p-5 mb-5 rounded-lg shadow-sm border-l-4" style="display: none;">
            <h3 class="text-xl font-semibold mb-4 flex items-center">
                <span class="pool-title">Energy Pool Title</span>
                <span class="flex-grow h-px bg-gray-200 ml-3"></span>
            </h3>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div>
                    <label class="lbl base-max-energy-label">Base Max Energy (Calculated):</label>
                    <span class="readonly-display base-max-energy">0</span> </div>
                <div><label class="lbl max-multiplier-label" for="">Pool Max Multiplier:</label><input type="text" value="1" class="inpt max-multiplier"></div>
                <div>
                    <label class="lbl total-energy-label">Total Energy (Calculated):</label>
                    <span class="readonly-display total-energy">0</span> </div>
                <div>
                    <label class="lbl current-energy-label">Current Energy:</label>
                    <span class="readonly-display current-energy">0</span> </div>
                <div><label class="lbl damage-per-power-label" for="">Damage per Energy Point:</label><input type="text" value="1" class="inpt damage-per-power"></div>
                <div>
                    <label class="lbl regen-percent-label" for="">Regeneration Rate (% of Total):</label>
                    <div class="flex items-center gap-2">
                        <input type="text" placeholder="e.g., 10" class="flex-grow p-2 border border-gray-300 rounded-md focus:ring-2 focus:border-transparent text-sm regen-percent">
                        <button class="regen-btn bg-success hover:bg-success-dark focus:ring-success px-3 py-2 text-white rounded-md focus:outline-none focus:ring-2 focus:ring-offset-2 transition-all duration-150 ease-in-out text-sm font-semibold shadow-sm active:scale-95">Regen</button>
                    </div>
                </div>
            </div>
        </div>
    </template>

    <template id="energy-slider-template">
        <div class="energy-slider-section hidden"> <label class="lbl text-sm slider-label" for="">Energy Used (%):</label>
            <input type="range" class="energy-slider w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer" min="0" max="100" value="0">
            <div class="flex justify-between text-xs text-gray-500 px-1"><span>0%</span><span>50%</span><span>100%</span></div>
            <div class="energy-slider-value-display flex justify-between items-center text-xs bg-gray-100 text-gray-700 p-1 rounded-md min-h-[2.5rem]">
                <span class="slider-percent-value">0%</span>
                <span class="slider-details-value text-right">(E: 0, D: 0.00)</span>
            </div>
        </div>
    </template>
    <script type="module">
        // Import the functions you need from the SDKs you need
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.0/firebase-app.js";
        import { getDatabase, ref, set, get, remove } from "https://www.gstatic.com/firebasejs/11.6.0/firebase-database.js";
        // *** Import Auth functions ***
        import {
            getAuth,
            onAuthStateChanged,
            GoogleAuthProvider,
            signInWithPopup,
            signOut
        } from "https://www.gstatic.com/firebasejs/11.6.0/firebase-auth.js";

        // === Your Specific Firebase Configuration ===
        // IMPORTANT: Replace "YOUR_API_KEY" with your actual Firebase API key!
        const firebaseConfig = {
            apiKey: "AIzaSyAbYQWbMQBHOdT-PxwIXeDFvLgEXlX7PhY", // Replace with your actual API key
            authDomain: "dndfortheboys-d88d9.firebaseapp.com",
            databaseURL: "https://dndfortheboys-d88d9-default-rtdb.firebaseio.com",
            projectId: "dndfortheboys-d88d9",
            storageBucket: "dndfortheboys-d88d9.appspot.com",
            messagingSenderId: "721075269380",
            appId: "1:721075269380:web:197009bf7ded05903faa51",
            measurementId: "G-H4HSEM39X5"
       };


        // Initialize Firebase App
        const app = initializeApp(firebaseConfig);
        const database = getDatabase(app);
        const auth = getAuth(app);

        // --- Make Firebase functions globally accessible ---
        window.firebaseDb = database;
        window.firebaseDbRef = ref;
        window.firebaseDbSet = set;
        window.firebaseDbGet = get;
        window.firebaseDbRemove = remove;
        window.firebaseAuth = auth;
        window.firebaseOnAuthStateChanged = onAuthStateChanged;
        window.firebaseGoogleAuthProvider = GoogleAuthProvider;
        window.firebaseSignInWithPopup = signInWithPopup;
        window.firebaseSignOut = signOut;

        // Signal that Firebase is ready for the main script
        console.log("Firebase Initialized (v9+ Modular with Auth)");
        document.dispatchEvent(new Event('firebaseReady'));
    </script>
<script>
document.addEventListener('firebaseReady', async () => {
    // --- DOM Element References ---
    const energyTypeSelect = document.getElementById('energy-type');
    const energyPoolsContainer = document.getElementById('energy-pools-container');
    const slidersGrid = document.getElementById('sliders-grid');
    const energyPoolTemplate = document.getElementById('energy-pool-template');
    const energySliderTemplate = document.getElementById('energy-slider-template');
    const calculateBtn = document.getElementById('calculate-btn');
    const resultDiv = document.getElementById('result');
    const resultValueEl = document.getElementById('result-value');
    const resultTotalEnergyUsedEl = document.getElementById('result-total-energy-used');
    const resultTotalExtraDamageEl = document.getElementById('result-total-extra-damage');
    const resultScientificEl = document.getElementById('result-scientific');
    const resultWordsEl = document.getElementById('result-words');
    const equationDisplayEl = document.getElementById('equation-display');
    const loadingDiv = document.getElementById('loading');
    const messageArea = document.getElementById('message-area');
    const dynamicModifiersContainer = document.getElementById('dynamic-modifiers-container');
    const addDynamicBoxBtn = document.getElementById('add-dynamic-box');
    const baseDamageInput = document.getElementById('base-damage');
    const baseMultiplierInput = document.getElementById('base-multiplier');
    const formMultiplierInput = document.getElementById('form-multiplier'); // Main display, read-only
    const attackCompressionPointsInput = document.getElementById('attack-compression-points');
    const statsPanel = document.getElementById('stats-panel');
    const statsPanelHeader = document.getElementById('stats-panel-header');
    const statCurrentEnergyEl = document.getElementById('stat-current-energy');
    const statTotalDamageEl = document.getElementById('stat-total-damage');
    const statTotalEnergySpentEl = document.getElementById('stat-total-energy-spent');
    const statAttackCountEl = document.getElementById('stat-attack-count');
    const statHighestDamageEl = document.getElementById('stat-highest-damage');
    const resetAttackCountBtn = document.getElementById('reset-attack-count-btn');
    const kaiokenSection = document.getElementById('kaioken-section');
    const kaiokenCheckbox = document.getElementById('kaioken-checkbox');
    const kaiokenDetails = document.getElementById('kaioken-details');
    const maxHealthInput = document.getElementById('max-health');
    const kaiokenStrainInput = document.getElementById('kaioken-strain');
    const currentHealthEl = document.getElementById('current-health');
    const regenHealthBtn = document.getElementById('regen-health-btn');
    const saveBtn = document.getElementById('save-state-btn');
    const loadBtn = document.getElementById('load-state-btn');
    const clearBtn = document.getElementById('clear-state-btn');
    const superAttackBtn = document.getElementById('super-attack-btn');
    const ultimateAttackBtn = document.getElementById('ultimate-attack-btn');
    const attackStatusMessage = document.getElementById('attack-status-message');
    const showCharacterStatsBtn = document.getElementById('show-character-stats-btn');
    const characterStatsScreen = document.getElementById('character-stats-screen');
    const mainCalculatorContent = document.getElementById('main-calculator-content');
    const mainTitle = document.querySelector('h1.text-3xl');
    // Character Stats Input References
    const characterNameInput = document.getElementById('character-name');
    const charBaseHealthInput = document.getElementById('char-base-health');
    const charBaseMultiplierInput = document.getElementById('char-base-multiplier');
    const charVitalityInput = document.getElementById('char-vitality');
    const charSoulPowerInput = document.getElementById('char-soul-power');
    const charSoulHpInput = document.getElementById('char-soul-hp');
    const charBaseAcInput = document.getElementById('char-base-ac');
    const charBaseTrInput = document.getElementById('char-base-tr');
    const charSpeedInput = document.getElementById('char-speed'); // <<< Speed Ref
    // Ryoko Mode References
    const ryokoCheckbox = document.getElementById('ryoko-checkbox');
    const ryokoEquationContainer = document.getElementById('ryoko-equation-input-container');
    const ryokoEquationInput = document.getElementById('ryoko-equation-input');
    // Form Creator References
    const formCreatorSection = document.getElementById('formCreatorSection'); // Parent div for buff inputs
    const formNameInput = document.getElementById('formNameInput');
    const formEnergyTypeSelect = document.getElementById('formEnergyTypeSelect');
    const formFormMultiplierInput = document.getElementById('formFormMultiplierInput');
    const formPoolMaxMultiplierInput = document.getElementById('formPoolMaxMultiplierInput');
    const formAffectsResistancesCheckbox = document.getElementById('formAffectsResistancesCheckbox');
    const formResistanceBonusInputsDiv = document.getElementById('formResistanceBonusInputs');
    const formAcBonusInput = document.getElementById('formAcBonusInput');
    const formTrueResistanceBonusInput = document.getElementById('formTrueResistanceBonusInput');
    const addFormButton = document.getElementById('addFormButton');
    // Form Buff Inputs (NEW)
    const formEnableFormBuffCheckbox = document.getElementById('formEnableFormBuff');
    const formFormBuffValueInput = document.getElementById('formFormBuffValue');
    const formFormBuffTypeSelect = document.getElementById('formFormBuffType');
    const formEnablePoolBuffCheckbox = document.getElementById('formEnablePoolBuff');
    const formPoolBuffValueInput = document.getElementById('formPoolBuffValue');
    const formPoolBuffTypeSelect = document.getElementById('formPoolBuffType');
    // Form List Container (Stats Panel)
    const formListContainer = document.getElementById('formListContainer');
    // Active Forms Section (NEW - Main Area)
    const activeFormsListContainer = document.getElementById('active-forms-list'); // <<< New Ref
    // Stats Panel AC/TR/Speed Displays
    const statFormAcBonusEl = document.getElementById('stat-form-ac-bonus');
    const statFormTrBonusEl = document.getElementById('stat-form-tr-bonus');
    const statTotalAcEl = document.getElementById('stat-total-ac');
    const statTotalTrEl = document.getElementById('stat-total-tr');
    const statSpeedEl = document.getElementById('stat-speed'); // <<< Speed Ref

    // --- Global State & Constants ---
    const FIREBASE_SAVE_PATH_BASE = 'calculatorStates';
    let currentUser = null;
    let totalDamageDealt = 0, totalEnergySpent = 0, attackCount = 0, highestDamage = 0;
    const LOCAL_STORAGE_KEY = 'energyCalculatorState_v12.0_multiform'; // Incremented version
    let poolAnimationTimeoutId = null;
    const ALL_ENERGY_TYPES = ['ki', 'nen', 'chakra', 'magic', 'cursed', 'reiatsu', 'haki', 'alchemy', 'nature', 'force', 'origin', 'fundamental', 'other'];
    const ALL_FORM_ENERGY_TYPES = ["None", ...ALL_ENERGY_TYPES];
    let dynamicModifierCount = 0;
    let activeAttacks = {};
    const ATTACK_RESERVE_COLOR = '#fed7aa';
    const SLIDER_TRACK_COLOR = '#e5e7eb';
    const DEFAULT_RYOKO_EQUATION = '((11250000 * 19 * 10 * 25 * 5 * 10 * 5 * 470) / 2) * 110';

    // Holds all defined form objects: { id, name, formMultiplier, poolMaxMultiplier, energyType, affectsResistances, acBonus, trBonus, enableFormBuff, formBuffValue, formBuffType, enablePoolBuff, poolBuffValue, poolBuffType }
    let characterForms = [];

    // State for active forms and combined bonuses derived from them
    let calculatorState = {
        activeFormIds: [], // Array of IDs for checked forms
        appliedAcBonus: 0,      // Combined AC from active forms, updated by applyActiveFormEffects
        appliedTrueResistanceBonus: 0, // Combined TR from active forms, updated by applyActiveFormEffects
        activeView: 'calculator' // Track current view ('calculator' or 'stats')
        // Selected Energy Type Focus is read directly from dropdown
        // Slider percentages are read directly or saved separately in gatherState/applyState
    };

    const ENERGY_TYPE_DETAILS = { /* ... Unchanged ... */
        ki:{ name: 'Ki',color: 'ki',colorDark: 'ki-dark',gradientTo: 'to-orange-100',focusRing: 'focus:ring-ki-focus',staticGlow: 'static-glow-ki',pulseGlow: 'animate-pulse-glow-ki',border: 'border-l-ki' },nen:{ name: 'Nen',color: 'nen',colorDark: 'nen-dark',gradientTo: 'to-blue-100',focusRing: 'focus:ring-nen-focus',staticGlow: 'static-glow-nen',pulseGlow: 'animate-pulse-glow-nen',border: 'border-l-nen' },chakra:{ name: 'Chakra',color: 'chakra',colorDark: 'chakra-dark',gradientTo: 'to-purple-100',focusRing: 'focus:ring-chakra-focus',staticGlow: 'static-glow-chakra',pulseGlow: 'animate-pulse-glow-chakra',border: 'border-l-chakra' },magic:{ name: 'Magic',color: 'magic',colorDark: 'magic-dark',gradientTo: 'to-teal-100',focusRing: 'focus:ring-magic-focus',staticGlow: 'static-glow-magic',pulseGlow: 'animate-pulse-glow-magic',border: 'border-l-magic' },cursed:{ name: 'Cursed',color: 'cursed',colorDark: 'cursed-dark',gradientTo: 'to-red-100',focusRing: 'focus:ring-cursed-focus',staticGlow: 'static-glow-cursed',pulseGlow: 'animate-pulse-glow-cursed',border: 'border-l-cursed' },reiatsu:{ name: 'Reiatsu',color: 'reiatsu',colorDark: 'reiatsu-dark',gradientTo: 'to-slate-100',focusRing: 'focus:ring-reiatsu-focus',staticGlow: 'static-glow-reiatsu',pulseGlow: 'animate-pulse-glow-reiatsu',border: 'border-l-reiatsu' },haki:{ name: 'Haki',color: 'haki',colorDark: 'haki-dark',gradientTo: 'to-gray-100',focusRing: 'focus:ring-haki-focus',staticGlow: 'static-glow-haki',pulseGlow: 'animate-pulse-glow-haki',border: 'border-l-haki' },alchemy:{ name: 'Alchemy',color: 'alchemy',colorDark: 'alchemy-dark',gradientTo: 'to-amber-100',focusRing: 'focus:ring-alchemy-focus',staticGlow: 'static-glow-alchemy',pulseGlow: 'animate-pulse-glow-alchemy',border: 'border-l-alchemy' },nature:{ name: 'Nature',color: 'nature',colorDark: 'nature-dark',gradientTo: 'to-lime-100',focusRing: 'focus:ring-nature-focus',staticGlow: 'static-glow-nature',pulseGlow: 'animate-pulse-glow-nature',border: 'border-l-nature' },force:{ name: 'Force',color: 'force',colorDark: 'force-dark',gradientTo: 'to-fuchsia-100',focusRing: 'focus:ring-force-focus',staticGlow: 'static-glow-force',pulseGlow: 'animate-pulse-glow-force',border: 'border-l-force' },origin:{ name: 'Origin',color: 'origin',colorDark: 'origin-dark',gradientTo: 'to-indigo-100',focusRing: 'focus:ring-origin-focus',staticGlow: 'static-glow-origin',pulseGlow: 'animate-pulse-glow-origin',border: 'border-l-origin' },fundamental:{ name: 'Fundamental',color: 'fundamental',colorDark: 'fundamental-dark',gradientTo: 'to-gray-100',focusRing: 'focus:ring-fundamental-focus',staticGlow: 'static-glow-fundamental',pulseGlow: 'animate-pulse-glow-fundamental',border: 'border-l-fundamental' },other:{ name: 'Other',color: 'other',colorDark: 'other-dark',gradientTo: 'to-amber-100',focusRing: 'focus:ring-other-focus',staticGlow: 'static-glow-other',pulseGlow: 'animate-pulse-glow-other',border: 'border-l-other' },
    };

    const SPEED_DETAILS = {
        name: 'Speed',
        color: 'sky-500',
        colorDark: 'sky-600',
        focusRing: 'focus:ring-speed-focus',
    };
    // --- Utility Functions ---
    function safeParseFloat(value, defaultValue = 0) { if (typeof value !== 'string' && typeof value !== 'number') return defaultValue; const num = parseFloat(String(value).replace(/,/g, '')); return isNaN(num) ? defaultValue : num; }
    function formatSimpleNumber(num) { if (typeof num !== 'number' || isNaN(num)) return '0'; try { const options = { maximumFractionDigits: 2 }; return num.toLocaleString('en-US', options); } catch (e) { return num.toString(); } }
    function showMessage(text, type = 'info') { messageArea.textContent = text; messageArea.className = 'mb-4 p-3 rounded-md text-sm border animate__animated'; messageArea.classList.remove('hidden', 'animate__fadeIn', 'animate__shakeX'); let animationClass = 'animate__fadeIn'; switch (type) { case 'error': messageArea.classList.add('bg-error-light', 'text-error-dark', 'border-error'); animationClass = 'animate__shakeX'; break; case 'success': messageArea.classList.add('bg-success-light', 'text-success-dark', 'border-success'); break; default: messageArea.classList.add('bg-blue-100', 'text-blue-800', 'border-blue-300'); break; } messageArea.classList.add(animationClass); messageArea.addEventListener('animationend', () => { messageArea.classList.remove('animate__animated', animationClass); }, { once: true }); setTimeout(() => { messageArea.classList.add('hidden'); }, 5000); }
    function showLoading(isLoading) { loadingDiv.classList.toggle('hidden', !isLoading); if(isLoading) resultDiv.classList.add('hidden'); calculateBtn.disabled = isLoading; calculateBtn.classList.toggle('opacity-50', isLoading); calculateBtn.classList.toggle('cursor-not-allowed', isLoading); }
    function triggerAnimation(element, animationName, duration = 800) { if (!element || !animationName) return; const animateCSSBase = 'animate__animated'; const animationClass = animationName.startsWith('animate__') ? animationName : `animate__${animationName}`; const classesToAdd = [animateCSSBase, animationClass]; element.classList.remove(...classesToAdd); void element.offsetWidth; element.classList.add(...classesToAdd); element.addEventListener('animationend', () => { element.classList.remove(...classesToAdd); }, { once: true });}
    function formatStatNumber(num) { if (typeof num !== 'number' || isNaN(num)) return '0'; const absNum = Math.abs(num); if (absNum >= 1e9) { return num.toExponential(2); } if (absNum >= 1e6) { let shortNum = num / 1e6; let formatted = shortNum.toLocaleString('en-US', { minimumFractionDigits: absNum < 10e6 ? 2 : 1, maximumFractionDigits: absNum < 10e6 ? 2 : 1 }); formatted = formatted.replace(/\.0$/, ''); return formatted + 'M'; } if (absNum >= 1e3) { let shortNum = num / 1e3; let formatted = shortNum.toLocaleString('en-US', { minimumFractionDigits: absNum < 10e3 ? 2 : 1, maximumFractionDigits: absNum < 10e3 ? 2 : 1 }); formatted = formatted.replace(/\.0$/, ''); return formatted + 'K'; } if (absNum < 1000) { return num.toLocaleString('en-US', { maximumFractionDigits: 2 }); } return num.toLocaleString('en-US'); }
    function parseFormattedNumber(str) { if (typeof str !== 'string' && typeof str !== 'number') return 0; if (typeof str === 'number') return isNaN(str) ? 0 : str; str = str.trim().toUpperCase().replace(/,/g, ''); if (str.includes('E')) { const num = parseFloat(str); return isNaN(num) ? 0 : num; } const lastChar = str.slice(-1); const numPart = parseFloat(str.slice(0, -1)); const fullNum = parseFloat(str); if (!isNaN(fullNum) && !['K', 'M', 'B', 'T', 'Q'].includes(lastChar)) { return fullNum; } if (isNaN(numPart) && ['K', 'M', 'B', 'T', 'Q'].includes(lastChar)) return 0; switch (lastChar) { case 'K': return numPart * 1e3; case 'M': return numPart * 1e6; case 'B': return numPart * 1e9; case 'T': return numPart * 1e12; case 'Q': return numPart * 1e15; default: return isNaN(fullNum) ? 0 : fullNum; } }
    function escapeHtml(unsafe) { if (typeof unsafe !== 'string') return ''; return unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;"); }
    // --- Energy Pool Logic ---
    function getEnergyElements(type) {
        if (!ALL_ENERGY_TYPES.includes(type)) {
            // console.error("Invalid energy type requested:", type); // Reduced console noise
            return null;
        }
        const poolDiv = document.getElementById(`${type}-pool`);
        if (!poolDiv) {
            return null;
        }
        // Note: Removed formSelectContainer and formSelect from returned object
        return {
            poolDiv: poolDiv,
            baseMaxEnergyEl: poolDiv.querySelector(`#${type}-base-max-energy`),
            maxMultiplierEl: poolDiv.querySelector(`#${type}-max-multiplier`), // This is the POOL Max Multiplier
            totalEnergyEl: poolDiv.querySelector(`#${type}-total-energy`),
            currentEnergyEl: poolDiv.querySelector(`#${type}-current-energy`),
            damagePerPowerEl: poolDiv.querySelector(`#${type}-damage-per-power`),
            regenPercentEl: poolDiv.querySelector(`#${type}-regen-percent`),
            sliderSection: document.getElementById(`${type}-slider-section`), // In sliders container
            energySlider: document.getElementById(`${type}-energy-slider`),     // In sliders container
            sliderValueDisplay: document.getElementById(`${type}-slider-value-display`), // In sliders container
        };
    }
    function calculateBaseMaxEnergy(type) {
        const baseHp = safeParseFloat(charBaseHealthInput?.value, 0);
        const vitality = safeParseFloat(charVitalityInput?.value, 0);
        const soulPower = safeParseFloat(charSoulPowerInput?.value, 0);
        const soulHp = safeParseFloat(charSoulHpInput?.value, 0);
        let baseMax = 0;
        switch (type) {
            case 'nen': baseMax = vitality * soulHp; break;
            case 'chakra': baseMax = vitality * (0.5 * soulHp + 0.5 * soulPower); break;
            case 'reiatsu': baseMax = soulHp * vitality * soulPower; break;
            case 'cursed': baseMax = soulPower * soulHp; break;
            case 'ki': case 'haki': baseMax = vitality * (soulPower + soulHp); break;
            case 'alchemy': baseMax = soulPower * baseHp; break;
            case 'nature': baseMax = vitality * (soulHp + baseHp + soulPower); break;
            case 'magic': baseMax = soulPower * (soulHp + baseHp + vitality); break;
            case 'force': baseMax = soulHp + vitality; break;
            case 'origin': baseMax = vitality * soulPower * soulHp; break;
            case 'fundamental': baseMax = vitality * (soulPower + soulHp); break; // Same as Ki/Haki
            case 'other': baseMax = vitality + soulPower + soulHp; break;
            default: console.warn(`Unknown energy type for base max calculation: ${type}`); baseMax = 0;
        }
        return Math.max(0, baseMax);
    }
    function updateSliderVisibility(type) { // For Energy Sliders
        const els = getEnergyElements(type);
        if (els?.totalEnergyEl && els.sliderSection) {
            const totalEnergy = parseFormattedNumber(els.totalEnergyEl.textContent);
            const shouldShow = totalEnergy > 0;
            els.sliderSection.classList.toggle('hidden', !shouldShow);
            if (!shouldShow && els.energySlider) {
                els.energySlider.value = 0;
                updateSingleSliderDisplay(type);
            }
        }
    }
    function calculateAndResetEnergy(type) { // For Energy Pools - Called by showSelectedEnergyPool and handleStatChange
        const els = getEnergyElements(type);
        if (!els?.baseMaxEnergyEl || !els?.maxMultiplierEl || !els?.totalEnergyEl || !els?.currentEnergyEl) {
             // console.warn(`Elements missing for energy calc/reset: ${type}`); // Reduce noise
            return 0; // Return 0 if elements not ready
        }

        const baseMaxEnergy = calculateBaseMaxEnergy(type);
        if (els.baseMaxEnergyEl) els.baseMaxEnergyEl.textContent = formatStatNumber(baseMaxEnergy);

        // Read Character Base Multiplier (potentially overridden by Ryoko)
        const characterBaseMultiplier = safeParseFloat(charBaseMultiplierInput.value, 1);

        // Pool Max Multiplier is now set externally by applyActiveFormEffects into the input.
        // We just read the input's current value here for calculation.
        const poolMaxMultiplier = safeParseFloat(els.maxMultiplierEl.value, 1);

        const totalEnergy = baseMaxEnergy * characterBaseMultiplier * poolMaxMultiplier;
        if (els.totalEnergyEl) els.totalEnergyEl.textContent = formatStatNumber(totalEnergy);

        // Adjust current energy: Cap it at the new total, or set to 0 if total is 0.
        if (els.currentEnergyEl) {
             const currentEnergy = parseFormattedNumber(els.currentEnergyEl.textContent);
             const newTotal = totalEnergy; // Use the calculated total
             // Set current to the minimum of its previous value and the new total, but not less than 0.
             els.currentEnergyEl.textContent = formatStatNumber(Math.max(0, Math.min(currentEnergy, newTotal)));
             // If you always want to reset to max when recalculating (e.g., after form change):
             // els.currentEnergyEl.textContent = formatStatNumber(newTotal);
        }

        updateSliderVisibility(type); // Ensure slider visibility matches if total energy became 0
        updateSingleSliderDisplay(type); // Update slider text based on potentially changed current energy
        return totalEnergy;
    }
    function regenerateEnergy(type) { const els = getEnergyElements(type); if (!els?.totalEnergyEl || !els?.currentEnergyEl || !els?.regenPercentEl) { console.error(`Elements missing for energy regeneration: ${type}`); return; } const totalEnergy = parseFormattedNumber(els.totalEnergyEl.textContent); let currentEnergy = parseFormattedNumber(els.currentEnergyEl.textContent); const regenPercent = safeParseFloat(els.regenPercentEl.value, 0); if (totalEnergy <= 0) { showMessage('Total Energy must be positive (check character stats and multiplier) to regenerate.', 'error'); return; } if (regenPercent <= 0) { showMessage('Regen Rate must be positive.', 'error'); return; } const regenAmount = totalEnergy * (regenPercent / 100); let newEnergy = Math.min(currentEnergy + regenAmount, totalEnergy); els.currentEnergyEl.textContent = formatStatNumber(newEnergy); showMessage(`${formatStatNumber(regenAmount)} ${type} regenerated. Current: ${formatStatNumber(newEnergy)}`, 'success'); triggerAnimation(els.currentEnergyEl, 'flash-green'); updateSingleSliderDisplay(type); updateStatsDisplay(); }
    // --- Kaioken Styling --- / --- Health Update ---
    function applyKaiokenStyle() { if (!statsPanel || !statsPanelHeader) return; statsPanel.classList.remove('border-stats-border'); statsPanel.classList.add('border-kaioken-border', 'animate-kaioken-glow'); statsPanelHeader.classList.remove('text-stats-header'); statsPanelHeader.classList.add('text-kaioken-header'); }
    function removeKaiokenStyle() { if (!statsPanel || !statsPanelHeader) return; statsPanel.classList.add('border-stats-border'); statsPanel.classList.remove('border-kaioken-border', 'animate-kaioken-glow'); statsPanelHeader.classList.add('text-stats-header'); statsPanelHeader.classList.remove('text-kaioken-header'); }
    function updateCurrentHealthDisplay() { if (!currentHealthEl || !maxHealthInput) return; const maxHealth = safeParseFloat(maxHealthInput.value, 0); let currentHealth = parseFormattedNumber(currentHealthEl.textContent); if ((energyTypeSelect.value === 'ki' && kaiokenCheckbox.checked) || currentHealth === -1 || currentHealth > maxHealth || currentHealthEl.textContent.trim() === '' || currentHealthEl.textContent === '0') { currentHealthEl.textContent = formatStatNumber(maxHealth); } }
    function regenerateHealth() { if (!maxHealthInput || !currentHealthEl) { console.error("Health elements missing for regeneration."); return; } const maxHealth = safeParseFloat(maxHealthInput.value, 0); currentHealthEl.textContent = formatStatNumber(maxHealth); showMessage('Health fully regenerated!', 'success'); triggerAnimation(currentHealthEl, 'flash-green'); }
// --- Show/Hide Logic & Pool Animation ---
    function showSelectedEnergyPool() {
        console.log("--- Running showSelectedEnergyPool ---"); // Debug log
        const selectedType = energyTypeSelect.value;
        const details = ENERGY_TYPE_DETAILS[selectedType];
        let newlyVisiblePool = null;

        if (poolAnimationTimeoutId) {
            clearTimeout(poolAnimationTimeoutId);
            poolAnimationTimeoutId = null;
        }

        // Hide all energy pools first, remove glows
        ALL_ENERGY_TYPES.forEach(type => {
            const els = getEnergyElements(type);
            const typeDetails = ENERGY_TYPE_DETAILS[type];
            if (els?.poolDiv && typeDetails) {
                els.poolDiv.classList.remove(typeDetails.pulseGlow, typeDetails.staticGlow, 'animate__animated', 'animate__fadeIn');
                els.poolDiv.style.display = 'none';
                // Removed logic for hiding per-pool form select container
            }
        });

        // Apply active form effects BEFORE calculating energy for the selected type
        // This ensures the correct pool multipliers are considered by calculateAndResetEnergy
        applyActiveFormEffects(); // This now reads global state and sets relevant multipliers

        // Calculate and reset energy for the selected type (uses multipliers set by applyActiveFormEffects)
        calculateAndResetEnergy(selectedType);

        // Show the selected pool
        const poolToShowEls = getEnergyElements(selectedType);
        if (poolToShowEls?.poolDiv && details) {
            console.log("   Attempting to show pool div:", poolToShowEls.poolDiv.id); // Debug log
            poolToShowEls.poolDiv.style.display = 'block';
            newlyVisiblePool = poolToShowEls.poolDiv;
            poolToShowEls.poolDiv.classList.add('animate__animated', 'animate__fadeIn');
            poolToShowEls.poolDiv.classList.add(details.pulseGlow); // Start with pulse
            poolToShowEls.poolDiv.addEventListener('animationend', (e) => {
                if (e.animationName === 'fadeIn') {
                    poolToShowEls.poolDiv.classList.remove('animate__animated', 'animate__fadeIn');
                }
            } , { once: true });

            // Animation timeout for glow transition
            poolAnimationTimeoutId = setTimeout(() => {
                const currentSelectedType = energyTypeSelect.value; // Check again in case user changed selection quickly
                const stillSelectedPoolEls = getEnergyElements(currentSelectedType);
                const stillSelectedDetails = ENERGY_TYPE_DETAILS[currentSelectedType];
                // Only transition to static glow if this pool is STILL the selected one
                if (stillSelectedPoolEls?.poolDiv && stillSelectedDetails && currentSelectedType === selectedType) {
                    stillSelectedPoolEls.poolDiv.classList.remove(stillSelectedDetails.pulseGlow);
                    stillSelectedPoolEls.poolDiv.classList.add(stillSelectedDetails.staticGlow);
                }
                poolAnimationTimeoutId = null;
            }, 5000); // 5 second pulse duration
        } else {
            console.error("   Could not find pool elements or details for:", selectedType); // Debug log
        }

        // Kaioken visibility (unchanged)
        if (kaiokenSection) {
            if (selectedType === 'ki') {
                kaiokenSection.classList.remove('hidden');
                if (kaiokenCheckbox.checked) {
                    kaiokenDetails.classList.remove('hidden');
                    updateCurrentHealthDisplay();
                }
            } else {
                kaiokenSection.classList.add('hidden');
                if (kaiokenCheckbox.checked) {
                    kaiokenCheckbox.checked = false;
                    kaiokenDetails.classList.add('hidden');
                    removeKaiokenStyle();
                }
            }
        }

        // Update other UI elements that depend on the selected energy type
        updateAttackButtonStates(selectedType);
        updateSliderLimitAndStyle(selectedType); // Handles reserve gradients on energy sliders
        updateStatsDisplay(); // Update general stats display (like current energy)
        updateEquationDisplay(); // Update equation display
        console.log("--- Finished showSelectedEnergyPool ---"); // Debug log
    }
    // --- Attack Logic ---
    function updateAttackButtonStates(type) { const currentAttack = activeAttacks[type] || null; superAttackBtn.classList.toggle('active', currentAttack === 'super'); ultimateAttackBtn.classList.toggle('active', currentAttack === 'ultimate'); let statusClasses = 'text-xs mt-2 min-h-[1.25rem]'; if (currentAttack === 'super') { attackStatusMessage.textContent = `Super Attack active for ${ENERGY_TYPE_DETAILS[type]?.name || type}. Slider limited to 95%.`; attackStatusMessage.className = `${statusClasses} text-blue-600`; } else if (currentAttack === 'ultimate') { attackStatusMessage.textContent = `Ultimate Attack active for ${ENERGY_TYPE_DETAILS[type]?.name || type}. Slider limited to 90%.`; attackStatusMessage.className = `${statusClasses} text-purple-600`; } else { attackStatusMessage.textContent = ''; attackStatusMessage.className = `${statusClasses} text-gray-500`; } }
    function updateSliderLimitAndStyle(type) { const els = getEnergyElements(type); if (!els?.energySlider) return; const slider = els.energySlider; const activeAttack = activeAttacks[type] || null; let limitPercent = 100; let gradientStyle = `linear-gradient(to right, ${SLIDER_TRACK_COLOR} 100%, ${ATTACK_RESERVE_COLOR} 100%)`; if (activeAttack === 'super') { limitPercent = 95; gradientStyle = `linear-gradient(to right, ${SLIDER_TRACK_COLOR} ${limitPercent}%, ${ATTACK_RESERVE_COLOR} ${limitPercent}%)`; } else if (activeAttack === 'ultimate') { limitPercent = 90; gradientStyle = `linear-gradient(to right, ${SLIDER_TRACK_COLOR} ${limitPercent}%, ${ATTACK_RESERVE_COLOR} ${limitPercent}%)`; } slider.style.background = gradientStyle; if (parseInt(slider.value) > limitPercent) { slider.value = limitPercent; } updateSingleSliderDisplay(type); }
    function handleAttackButtonClick(event) { const button = event.currentTarget; const attackType = button.dataset.attackType; const selectedEnergyType = energyTypeSelect.value; const currentAttackForType = activeAttacks[selectedEnergyType] || null; const newAttackState = (currentAttackForType === attackType) ? null : attackType; activeAttacks[selectedEnergyType] = newAttackState; updateAttackButtonStates(selectedEnergyType); updateSliderLimitAndStyle(selectedEnergyType); triggerAnimation(button, 'pulse'); }
    // --- Dynamic Modifiers Logic ---
    function addDynamicModifier(modifierData = null) { dynamicModifierCount++; const modifierId = `dynamic-modifier-${dynamicModifierCount}`; const newModifierDiv = document.createElement('div'); const initialType = modifierData?.type || 'additive'; const initialValue = modifierData?.value || '0'; const initialName = modifierData?.name || ''; const isActiveAdditive = initialType === 'additive'; const boxClasses = `dynamic-box p-4 mt-3 border rounded-md border-l-4 relative transition-all duration-300 ease-in-out animate__animated animate__bounceIn ${isActiveAdditive ? 'additive bg-success-light border-success' : 'multiplicative bg-ki/10 border-ki'}`; newModifierDiv.className = boxClasses; newModifierDiv.id = modifierId; newModifierDiv.innerHTML = ` <div class="absolute top-2 right-2"> <button class="remove-dynamic-box bg-error text-white rounded-md shadow-sm w-6 h-6 flex items-center justify-center text-xs hover:bg-error-dark focus:outline-none focus:ring-2 focus:ring-error focus:ring-offset-1 transition-transform active:scale-95" aria-label="Remove this modifier" data-target="${modifierId}">×</button> </div> <div class="modifier-type-selector flex gap-2 mb-3 border-b pb-2"> <div class="modifier-type-option additive ${isActiveAdditive ? 'active' : ''} flex-1 p-2 text-center border rounded-md cursor-pointer transition-all duration-300 ease-in-out text-sm" data-value="additive" tabindex="0" role="radio" aria-checked="${isActiveAdditive}"> <input type="radio" name="modifier-type-${modifierId}" value="additive" class="sr-only" ${isActiveAdditive ? 'checked' : ''}> Additive (+) </div> <div class="modifier-type-option multiplicative ${!isActiveAdditive ? 'active' : ''} flex-1 p-2 text-center border rounded-md cursor-pointer transition-all duration-300 ease-in-out text-sm" data-value="multiplicative" tabindex="0" role="radio" aria-checked="${!isActiveAdditive}"> <input type="radio" name="modifier-type-${modifierId}" value="multiplicative" class="sr-only" ${!isActiveAdditive ? 'checked' : ''}> Multiplier (×) </div> </div> <div class="grid grid-cols-1 sm:grid-cols-2 gap-3"> <div> <label for="modifier-name-${modifierId}" class="lbl">Modifier Name:</label> <input type="text" id="modifier-name-${modifierId}" placeholder="e.g., Buff" value="${escapeHtml(initialName)}" class="modifier-name-input w-full p-1.5 border border-gray-300 rounded-md focus:ring-1 focus:ring-success focus:border-transparent text-sm"> </div> <div> <label for="modifier-value-${modifierId}" class="lbl">Value:</label> <input type="text" id="modifier-value-${modifierId}" placeholder="e.g., 50 or 1.2" value="${escapeHtml(initialValue)}" class="modifier-value-input w-full p-1.5 border border-gray-300 rounded-md focus:ring-1 focus:ring-success focus:border-transparent text-sm"> </div> </div>`; dynamicModifiersContainer.appendChild(newModifierDiv); addListenersToModifierBox(newModifierDiv); newModifierDiv.addEventListener('animationend', () => { newModifierDiv.classList.remove('animate__animated', 'animate__bounceIn'); }, { once: true }); }
    function addListenersToModifierBox(modifierDiv) { modifierDiv.querySelector('.remove-dynamic-box')?.addEventListener('click', function() { const targetBox = document.getElementById(this.dataset.target); if (targetBox) { targetBox.classList.add('animate__animated', 'animate__bounceOut'); targetBox.addEventListener('animationend', () => { targetBox.remove(); updateEquationDisplay(); }, { once: true }); } else { updateEquationDisplay(); } }); modifierDiv.querySelectorAll('.modifier-type-option').forEach(option => { option.addEventListener('click', function() { const box = this.closest('.dynamic-box'); const value = this.dataset.value; box.querySelectorAll('input[type="radio"]').forEach(radio => radio.checked = (radio.value === value)); box.querySelectorAll('.modifier-type-option').forEach(opt => { const isActive = opt.dataset.value === value; opt.classList.toggle('active', isActive); opt.setAttribute('aria-checked', isActive); }); box.classList.remove('additive', 'multiplicative', 'bg-success-light', 'border-success', 'bg-ki/10', 'border-ki'); box.classList.add(value === 'additive' ? 'additive' : 'multiplicative'); box.classList.add(value === 'additive' ? 'bg-success-light' : 'bg-ki/10'); box.classList.add(value === 'additive' ? 'border-success' : 'border-ki'); updateEquationDisplay(); }); option.addEventListener('keydown', function(e) { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); this.click(); } }); }); const valueInput = modifierDiv.querySelector('.modifier-value-input'); if (valueInput) { valueInput.addEventListener('input', updateEquationDisplay); valueInput.addEventListener('change', updateEquationDisplay); } const nameInput = modifierDiv.querySelector('.modifier-name-input'); if (nameInput) { nameInput.addEventListener('input', updateEquationDisplay); nameInput.addEventListener('change', updateEquationDisplay); } }
    // --- Stats Update Logic ---
    function updateStatsDisplay() {
        // Standard stats
        if (statTotalDamageEl) statTotalDamageEl.textContent = formatStatNumber(totalDamageDealt);
        if (statTotalEnergySpentEl) statTotalEnergySpentEl.textContent = formatStatNumber(totalEnergySpent);
        if (statHighestDamageEl) statHighestDamageEl.textContent = formatStatNumber(highestDamage);
        if (statAttackCountEl) statAttackCountEl.textContent = attackCount.toLocaleString();

        // Current Energy (Focused Type)
        const selectedType = energyTypeSelect.value;
        const els = getEnergyElements(selectedType);
        if (statCurrentEnergyEl && els?.currentEnergyEl) {
            statCurrentEnergyEl.textContent = els.currentEnergyEl.textContent || '0';
        } else if (statCurrentEnergyEl) {
            statCurrentEnergyEl.textContent = 'N/A';
        }

        // AC / TR - Read base from inputs, apply form bonuses from state, calculate total
        const baseAC = safeParseFloat(charBaseAcInput?.value, 0);
        const baseTR = safeParseFloat(charBaseTrInput?.value, 0);

        // Get form bonuses (these are now stored directly in calculatorState by applyActiveFormEffects)
        let formAcBonus = calculatorState.appliedAcBonus || 0;
        let formTrBonus = calculatorState.appliedTrueResistanceBonus || 0;

        // Display bonuses and totals
        if (statFormAcBonusEl) statFormAcBonusEl.textContent = formatSimpleNumber(formAcBonus);
        if (statFormTrBonusEl) statFormTrBonusEl.textContent = formatSimpleNumber(formTrBonus);
        if (statTotalAcEl) statTotalAcEl.textContent = formatSimpleNumber(baseAC + formAcBonus);
        if (statTotalTrEl) statTotalTrEl.textContent = formatSimpleNumber(baseTR + formTrBonus);

        // Speed Stat Display
        if (statSpeedEl && charSpeedInput) {
             statSpeedEl.textContent = formatStatNumber(safeParseFloat(charSpeedInput.value, 0));
        }
    }
    // <<< NEW Speed Slider Logic Functions >>>
    // --- Speed Slider Logic ---
    function generateSpeedSlider() {
        if (!energySliderTemplate || !slidersGrid) {
            console.error("Slider template or grid container not found! Cannot generate speed slider.");
            return;
        }

        // Check if speed slider already exists to prevent duplicates
        if (document.getElementById('speed-slider-section')) {
            // console.log("Speed slider section already exists."); // Optional debug log
            return;
        }

        console.log("Attempting to generate speed slider DOM..."); // Debug log

        const sliderClone = energySliderTemplate.content.cloneNode(true);
        const sliderSection = sliderClone.querySelector('.energy-slider-section');
        if (sliderSection) {
            sliderSection.id = `speed-slider-section`;
            sliderSection.dataset.type = 'speed'; // Identify type
            // Keep initial 'hidden' class from template, visibility handled by updateSpeedSliderVisibility

            const sliderLabel = sliderSection.querySelector('.slider-label');
            if (sliderLabel) {
                sliderLabel.htmlFor = `speed-slider`;
                sliderLabel.textContent = `${SPEED_DETAILS.name} Usage (%):`;
            }
            const energySlider = sliderSection.querySelector('.energy-slider');
            if (energySlider) {
                energySlider.id = `speed-slider`; // Use specific ID for CSS
                energySlider.dataset.type = 'speed';
                // Apply specific speed styling if needed beyond thumb color (already handled by CSS ID)
            }
            const valueDisplay = sliderSection.querySelector('.energy-slider-value-display');
            if (valueDisplay) {
                valueDisplay.id = `speed-slider-value-display`;
                 // Modify the details span label for clarity (S for Speed)
                const detailsSpan = valueDisplay.querySelector('.slider-details-value');
                if (detailsSpan) detailsSpan.textContent = '(S: 0, D: 0.00)'; // Initial text
            }
            slidersGrid.appendChild(sliderClone);
            console.log("Speed slider DOM structure generated (initially hidden).");
            updateSpeedSliderDisplay(); // Initialize display text
        } else {
            console.error(`Could not find .energy-slider-section in template clone for speed`);
        }
    }

    function updateSpeedSliderVisibility() {
        const baseSpeed = safeParseFloat(charSpeedInput?.value, 0);
        let speedSliderSection = document.getElementById('speed-slider-section'); // Try to find it

        if (baseSpeed > 0) {
            // If speed > 0, ensure slider exists
            if (!speedSliderSection) {
                console.log("Speed > 0 and slider section not found. Generating..."); // Debug log
                generateSpeedSlider(); // Generate it if it doesn't exist yet
                speedSliderSection = document.getElementById('speed-slider-section'); // Re-select after attempting generation
            }
            // If it exists (or was just generated), ensure it's visible
            if (speedSliderSection) {
                 speedSliderSection.classList.remove('hidden');
                 console.log("Speed slider section made visible."); // Debug log
            } else {
                 console.error("Failed to find or generate speed slider section even though baseSpeed > 0."); // Debug log
            }
        } else {
            // If speed is 0 or less, hide the slider if it exists
            if (speedSliderSection) {
                speedSliderSection.classList.add('hidden');
                console.log("Speed <= 0. Speed slider section hidden."); // Debug log
                 // Optionally reset slider value when hiding
                 const speedSlider = document.getElementById('speed-slider');
                 if(speedSlider) speedSlider.value = 0;
                 updateSpeedSliderDisplay(); // Update display to show 0
            } else {
                 // console.log("Speed <= 0 and slider section doesn't exist. Nothing to hide."); // Debug log (Optional)
            }
        }
    }

    function updateSpeedSliderDisplay() {
        const sliderSection = document.getElementById('speed-slider-section');
        // Update only if section exists, visibility doesn't matter for updating text content
        if (!sliderSection) return;

        const slider = document.getElementById('speed-slider');
        const valueDisplay = document.getElementById('speed-slider-value-display');
        const baseSpeed = safeParseFloat(charSpeedInput?.value, 0);

        if (!slider || !valueDisplay || !charSpeedInput) {
            // Don't spam console if slider just hasn't been generated yet
            // console.warn("Speed slider elements not found for display update.");
            return; // Exit if elements aren't ready
        }

        const percentSpan = valueDisplay.querySelector('.slider-percent-value');
        const detailsSpan = valueDisplay.querySelector('.slider-details-value');

        if (!percentSpan || !detailsSpan) {
            console.error("Speed slider display spans not found.");
            return;
        }

        const sliderPercent = parseInt(slider.value);
        // No attack reserve for speed, use full percentage
        const speedUsed = baseSpeed * (sliderPercent / 100);
        const extraDamage = speedUsed * 1; // 1:1 conversion

        percentSpan.textContent = `${sliderPercent}%`;
        detailsSpan.textContent = `(S: ${formatStatNumber(speedUsed)}, D: ${formatStatNumber(extraDamage)})`; // Use S: for Speed used
    }
    // --- Form System Logic ---

    // NEW: Renders the checkboxes in the main "Active Forms" section
    function renderActiveFormsSection() {
        const container = document.getElementById('active-forms-list');
        if (!container) {
             console.error("Active forms container not found (#active-forms-list).");
             return;
        }
        container.innerHTML = ''; // Clear previous checkboxes

        if (!characterForms || characterForms.length === 0) {
            container.innerHTML = '<p class="text-gray-500 text-sm col-span-full">No forms created yet.</p>'; // Ensure message spans grid
            return;
        }

        // Ensure activeFormIds exists and is an array in the state
        if (!Array.isArray(calculatorState.activeFormIds)) {
            calculatorState.activeFormIds = [];
        }

        characterForms.forEach(form => {
            const isChecked = calculatorState.activeFormIds.includes(form.id);
            const div = document.createElement('div');
            // Ensure each item doesn't force wrapping unduly within the grid cell
            div.className = 'flex items-center gap-2 min-w-0'; // Prevent stretching

            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = `active-form-${form.id}`;
            checkbox.value = form.id;
            checkbox.checked = isChecked;
            checkbox.className = 'h-4 w-4 rounded border-gray-300 text-purple-600 focus:ring-purple-500 flex-shrink-0'; // Prevent checkbox shrinking
            checkbox.addEventListener('change', handleActiveFormChange); // Add listener directly

            const label = document.createElement('label');
            label.htmlFor = checkbox.id;
            label.textContent = form.name;
            // Allow label to truncate if needed
            label.className = 'text-sm text-gray-700 select-none truncate hover:text-purple-700 cursor-pointer';
            // Add tooltip showing form details (important now with buffs)
             let tooltip = `Form Mult: ${formatSimpleNumber(form.formMultiplier)}, Pool Mult: ${formatSimpleNumber(form.poolMaxMultiplier)}${form.energyType !== 'None' ? ` (${form.energyType})` : ''}${form.affectsResistances ? `, AC: ${formatSimpleNumber(form.acBonus)}, TR: ${formatSimpleNumber(form.trueResistanceBonus)}` : ''}`;
             if (form.enableFormBuff) tooltip += ` | FM Buff: ${form.formBuffType === 'add' ? '+' : 'x'}${form.formBuffValue}/calc`;
             if (form.enablePoolBuff) tooltip += ` | PM Buff: ${form.poolBuffType === 'add' ? '+' : 'x'}${form.poolBuffValue}/calc`;
             label.title = tooltip;


            div.appendChild(checkbox);
            div.appendChild(label);
            container.appendChild(div);
        });
    }

    // NEW: Handles checkbox changes in the "Active Forms" section
    function handleActiveFormChange(event) {
        const checkbox = event.target;
        const formId = checkbox.value;
        const isChecked = checkbox.checked;

        // Ensure activeFormIds exists and is an array
         if (!Array.isArray(calculatorState.activeFormIds)) {
            calculatorState.activeFormIds = [];
        }

        if (isChecked) {
            // Add formId if it's not already there
            if (!calculatorState.activeFormIds.includes(formId)) {
                calculatorState.activeFormIds.push(formId);
            }
        } else {
            // Remove formId
            calculatorState.activeFormIds = calculatorState.activeFormIds.filter(id => id !== formId);
        }
        console.log("Active Form IDs:", calculatorState.activeFormIds); // Debug log
        // Re-apply combined effects whenever selection changes
        applyActiveFormEffects();
        // Also update equation display when active forms change
        updateEquationDisplay();
    }
    // REWRITTEN: Applies combined effects from globally selected forms
    function applyActiveFormEffects() {
        console.log("Applying active form effects...");
        let combinedFormMultiplier = 1;
        let combinedPoolMultipliers = {}; // Tracks highest multiplier PER energy type { ki: 1, nen: 1, ... }
        let combinedAcBonus = 0;
        let combinedTrBonus = 0;

        // Initialize pool multipliers to 1 for all types
        ALL_ENERGY_TYPES.forEach(type => { combinedPoolMultipliers[type] = 1; });

        // Ensure activeFormIds exists
        const activeIds = calculatorState.activeFormIds || [];
        console.log("Processing active form IDs:", activeIds);

        activeIds.forEach(formId => {
            const form = characterForms.find(f => f.id === formId);
            if (form) {
                // console.log(`Processing form: ${form.name}`); // Optional log
                // Combine Form Multiplier (Multiplicative)
                combinedFormMultiplier *= form.formMultiplier;

                // Combine AC/TR Bonuses (Additive)
                if (form.affectsResistances) {
                    combinedAcBonus += form.acBonus;
                    combinedTrBonus += form.trueResistanceBonus;
                }

                // Combine Pool Max Multiplier (Highest Wins per type, 'None' applies to all)
                const targetType = form.energyType; // Could be 'None' or a specific type

                 if (targetType === 'None') {
                     // Apply 'None' type form pool multiplier to ALL energy types (unless a specific type has higher)
                     ALL_ENERGY_TYPES.forEach(energyType => {
                         combinedPoolMultipliers[energyType] = Math.max(combinedPoolMultipliers[energyType] || 1, form.poolMaxMultiplier);
                     });
                 } else if (ALL_ENERGY_TYPES.includes(targetType)) {
                     // Apply specific type form pool multiplier only to its type
                      combinedPoolMultipliers[targetType] = Math.max(combinedPoolMultipliers[targetType] || 1, form.poolMaxMultiplier);
                 }
            } else {
                 console.warn(`Could not find form object for active ID: ${formId}`);
            }
        });

        // --- Apply Combined Effects to UI and State ---

        // Apply combined Form Multiplier to the main input
        if (formMultiplierInput) {
            const currentVal = safeParseFloat(formMultiplierInput.value);
            const newVal = safeParseFloat(combinedFormMultiplier);
            if (currentVal !== newVal) {
                 formMultiplierInput.value = formatSimpleNumber(newVal);
                 triggerAnimation(formMultiplierInput, 'pulse-source'); // Pulse effect on change
                 console.log("Applied combined Form Multiplier:", newVal);
            }
        }

        // Apply combined Pool Max Multipliers to respective energy pool inputs & Recalculate Energy
        ALL_ENERGY_TYPES.forEach(type => {
             const els = getEnergyElements(type);
             if (els && els.maxMultiplierEl) {
                  // Use the specific combined multiplier for this type, or default to 1 if none applied
                  const applicableMultiplier = combinedPoolMultipliers[type] || 1;
                  const currentPoolMultVal = safeParseFloat(els.maxMultiplierEl.value);
                  const newPoolMultVal = safeParseFloat(applicableMultiplier);

                  if (currentPoolMultVal !== newPoolMultVal) {
                       els.maxMultiplierEl.value = formatSimpleNumber(newPoolMultVal);
                       console.log(`Applied Pool Max Multiplier ${newPoolMultVal} to ${type}`);
                       // Recalculate energy for this pool AFTER setting the multiplier
                       calculateAndResetEnergy(type);
                       triggerAnimation(els.maxMultiplierEl, 'pulse-source'); // Pulse effect on change
                  } else {
                      // Even if multiplier didn't change, ensure energy calculation uses latest base stats
                      // This is important if base stats changed but forms didn't
                      calculateAndResetEnergy(type);
                  }
             }
        });


         // Store applied resistance bonuses in state for the stats display function to use
         calculatorState.appliedAcBonus = combinedAcBonus;
         calculatorState.appliedTrueResistanceBonus = combinedTrBonus;

         // Update stats display AFTER applying all effects and recalculating pools
         updateStatsDisplay();
         // Equation display is updated separately when forms change via handleActiveFormChange or other triggers
         console.log("Finished applying active form effects.");
    }
    // Renders the list in the Stats Panel (UPDATED tooltip for buffs)
    function renderFormList() {
        if (!formListContainer) return;
        formListContainer.innerHTML = ''; // Clear current list

        if (!characterForms || characterForms.length === 0) {
            formListContainer.innerHTML = '<p class="text-gray-500">No forms created yet.</p>';
            return;
        }

        // Group forms by energy type
        const formsByEnergyType = characterForms.reduce((acc, form) => {
            const type = form.energyType || 'None';
            if (!acc[type]) acc[type] = [];
            acc[type].push(form);
            return acc;
        }, {});

        const sortedEnergyTypes = Object.keys(formsByEnergyType).sort((a, b) => {
             if (a === 'None') return 1; if (b === 'None') return -1;
             const aIndex = ALL_ENERGY_TYPES.indexOf(a);
             const bIndex = ALL_ENERGY_TYPES.indexOf(b);
             if (aIndex !== -1 && bIndex !== -1) return aIndex - bIndex;
             return a.localeCompare(b);
        });


        for (const type of sortedEnergyTypes) {
            const groupDiv = document.createElement('div');
            groupDiv.className = 'form-list-group';
            groupDiv.innerHTML = `<h4>${ENERGY_TYPE_DETAILS[type]?.name || 'None'} Forms</h4>`; // Handle None type name
            formListContainer.appendChild(groupDiv);

            const listDiv = document.createElement('div');
            listDiv.className = 'flex flex-col items-start gap-0.5';

            formsByEnergyType[type].forEach(form => {
                const formItemContainer = document.createElement('div');
                formItemContainer.className = 'flex items-center gap-1 w-full';

                const formElement = document.createElement('span');
                formElement.className = 'form-list-item flex-grow';
                formElement.textContent = form.name;
                formElement.setAttribute('data-form-id', form.id);
                // Update tooltip to show buff info if enabled
                let tooltip = `Form Mult: ${formatSimpleNumber(form.formMultiplier)}, Pool Mult: ${formatSimpleNumber(form.poolMaxMultiplier)}${form.energyType !== 'None' ? ` (${form.energyType})` : ''}${form.affectsResistances ? `, AC: ${formatSimpleNumber(form.acBonus)}, TR: ${formatSimpleNumber(form.trueResistanceBonus)}` : ''}`;
                if (form.enableFormBuff) tooltip += ` | FM Buff: ${form.formBuffType === 'add' ? '+' : 'x'}${form.formBuffValue}/calc`;
                if (form.enablePoolBuff) tooltip += ` | PM Buff: ${form.poolBuffType === 'add' ? '+' : 'x'}${form.poolBuffValue}/calc`;
                formElement.title = tooltip;


                const deleteButton = document.createElement('button');
                deleteButton.textContent = '×';
                deleteButton.className = 'delete-form-btn text-red-500 hover:text-red-700 focus:outline-none focus:ring-1 focus:ring-red-300 rounded px-1 py-0 text-xs font-bold transition-colors duration-150 active:scale-95 flex-shrink-0'; // Added flex-shrink-0
                deleteButton.title = `Delete form "${form.name}"`;
                deleteButton.setAttribute('aria-label', `Delete form ${form.name}`);
                deleteButton.dataset.formId = form.id;

                formItemContainer.appendChild(formElement);
                formItemContainer.appendChild(deleteButton);
                listDiv.appendChild(formItemContainer);
            });
             formListContainer.appendChild(listDiv);
        }
    }

    // // OLD FUNCTION - No longer needed with global checkbox section
    // function populateFormDropdowns() { /* ... Commented out or Deleted ... */ }

    // // OLD FUNCTION - No longer needed with global checkbox section
    // function handleFormSelectChange(event) { /* ... Commented out or Deleted ... */ }

    // MODIFIED: Needs to update the new active forms section too
    function handleDeleteFormClick(event) {
        const deleteButton = event.target.closest('.delete-form-btn');
        if (deleteButton && deleteButton.dataset.formId) {
            const formIdToDelete = deleteButton.dataset.formId;
            const formToDelete = characterForms.find(form => form.id === formIdToDelete);
            if (!formToDelete) { console.error("Could not find form to delete with ID:", formIdToDelete); return; }

            if (confirm(`Are you sure you want to delete the form "${formToDelete.name}"? This cannot be undone.`)) {
                const formIndex = characterForms.findIndex(form => form.id === formIdToDelete);
                if (formIndex > -1) {
                    characterForms.splice(formIndex, 1); // Remove from main array
                    console.log(`Form "${formToDelete.name}" removed from characterForms.`);

                    // Remove from activeFormIds if it was active
                    if (Array.isArray(calculatorState.activeFormIds)) {
                        calculatorState.activeFormIds = calculatorState.activeFormIds.filter(id => id !== formIdToDelete);
                    }

                    // Update UI
                    renderFormList();           // Refresh the list in the stats panel
                    renderActiveFormsSection(); // <<< Refresh the checkboxes in the main section
                    applyActiveFormEffects();   // Re-apply effects based on potentially changed active forms
                    updateEquationDisplay();    // Update equation based on new effects

                    showMessage(`Form "${formToDelete.name}" deleted successfully.`, 'success');
                } else { console.error("Form index not found after finding the form object."); }
            }
        }
    }
    // --- Calculation Logic ---

    // Updates the text display below an energy slider (e.g., E: 100, D: 100.00)
    // This is also used by the speed slider display update function.
    function updateSingleSliderDisplay(type) {
        function updateSingleSliderDisplay(type) {
    console.log(`--- Running updateSingleSliderDisplay for: ${type}`); // <<< ADD THIS LOG
    const els = getEnergyElements(type);
    if (!els?.energySlider || !els?.sliderValueDisplay || !els?.currentEnergyEl || !els?.damagePerPowerEl) {
         console.error(`Missing elements for updateSingleSliderDisplay(${type})`); // <<< ADD LOG
         return;
    }
    const percentSpan = els.sliderValueDisplay.querySelector('.slider-percent-value');
    const detailsSpan = els.sliderValueDisplay.querySelector('.slider-details-value');
    if (!percentSpan || !detailsSpan) { console.error(`Slider display spans not found for ${type}`); return; }

    const sliderPercent = parseInt(els.energySlider.value);
    const currentEnergy = parseFormattedNumber(els.currentEnergyEl.textContent);
    const damagePerPower = safeParseFloat(els.damagePerPowerEl.value, 1);
    console.log(`   Values read for ${type} -> %: ${sliderPercent}, CurrentE: ${currentEnergy}, DPP: ${damagePerPower}`); // <<< ADD THIS LOG

    const activeAttack = activeAttacks[type] || null;
    let limitPercent = 100;
    if (activeAttack === 'super') limitPercent = 95;
    else if (activeAttack === 'ultimate') limitPercent = 90;
    const effectivePercent = Math.min(sliderPercent, limitPercent);
    const potentialEnergyUsed = currentEnergy * (effectivePercent / 100);
    const actualEnergyUsed = Math.min(potentialEnergyUsed, currentEnergy);
    const extraDamage = actualEnergyUsed * damagePerPower;
     console.log(`   Calculated for ${type} -> UsedE: ${actualEnergyUsed}, ExtraD: ${extraDamage}`); // <<< ADD THIS LOG

    percentSpan.textContent = `${sliderPercent}%`;
    detailsSpan.textContent = `(E: ${formatStatNumber(actualEnergyUsed)}, D: ${formatStatNumber(extraDamage)})`;
     console.log(`   Updated text for ${type} to: ${detailsSpan.textContent}`); // <<< ADD THIS LOG
}
    // Main calculation function
    function performCalculation() {
        showLoading(true);
        setTimeout(() => {
            let finalDamage = 0;
            let healthDepleted = false;
            let speedDamage = 0; // Initialize speedDamage for this calculation
            // We'll apply buffs at the end, no need to track specific forms here initially

            try {
                // --- 1. Base Damage Calculation ---
                const baseDamage = safeParseFloat(baseDamageInput.value, 0);
                const compressionPoints = safeParseFloat(attackCompressionPointsInput.value, 0);
                const baseMultiplier = safeParseFloat(baseMultiplierInput.value, 1);
                // Form multiplier is now applied globally based on active forms, read its current combined value
                const formMultiplierVal = safeParseFloat(formMultiplierInput.value, 1); // Already combined by applyActiveFormEffects
                const energyType = energyTypeSelect.value; // Focused energy type (mainly for Kaioken check)

                let baseDamagePart = baseDamage * baseMultiplier * formMultiplierVal;

                let compressionMultiplierValue = 1;
                if (compressionPoints > 0) {
                    compressionMultiplierValue = Math.max(1, (compressionPoints * 1.5) + (Math.floor(compressionPoints / 10) * 3));
                }
                finalDamage = baseDamagePart * compressionMultiplierValue;
                console.log(`After Base/Form/Compression: ${finalDamage}`); // Debug Log

                // --- 2. Apply Dynamic Multiplicative Factors ---
                document.querySelectorAll('#dynamic-modifiers-container .dynamic-box').forEach(modifierDiv => {
                    const valueInput = modifierDiv.querySelector('.modifier-value-input');
                    const typeOption = modifierDiv.querySelector('.modifier-type-option.active');
                    if (valueInput && typeOption && typeOption.dataset.value === 'multiplicative') {
                        const modifierValue = safeParseFloat(valueInput.value, 1);
                         if (modifierValue !== 1) { // Only log if it changes something
                            console.log(`Applying Multiplicative Modifier: x${modifierValue}`); // Debug Log
                            finalDamage *= modifierValue;
                         }
                    }
                });
                console.log(`After Multiplicative Mods: ${finalDamage}`); // Debug Log

                // --- 3. Calculate and Add Energy Damage (and deplete energy) ---
                let totalEnergyUsedFromSliders = 0;
                let totalExtraDamageFromEnergy = 0;
                ALL_ENERGY_TYPES.forEach(type => {
                    const els = getEnergyElements(type);
                    if (els?.energySlider && els.currentEnergyEl && els.damagePerPowerEl) {
                        const sliderPercent = safeParseFloat(els.energySlider.value, 0);
                        const activeAttack = activeAttacks[type] || null;
                        let limitPercent = 100;
                        if (activeAttack === 'super') limitPercent = 95;
                        else if (activeAttack === 'ultimate') limitPercent = 90;
                        const effectivePercent = Math.min(sliderPercent, limitPercent);

                        if (effectivePercent > 0) {
                            const currentEnergy = parseFormattedNumber(els.currentEnergyEl.textContent);
                            if (currentEnergy > 0) { // Only calculate if there's energy to use
                                const damagePerPower = safeParseFloat(els.damagePerPowerEl.value, 1);
                                const energyUsedThisType = currentEnergy * (effectivePercent / 100);
                                const actualEnergyUsed = Math.min(energyUsedThisType, currentEnergy);
                                const extraDamageThisType = actualEnergyUsed * damagePerPower;

                                totalEnergyUsedFromSliders += actualEnergyUsed;
                                totalExtraDamageFromEnergy += extraDamageThisType;
                                console.log(`Energy Damage (${type}): Used ${actualEnergyUsed}, Added ${extraDamageThisType}`); // Debug Log

                                // Deplete energy
                                let newCurrentEnergyThisType = Math.max(0, currentEnergy - actualEnergyUsed);
                                els.currentEnergyEl.textContent = formatStatNumber(newCurrentEnergyThisType);
                                if (newCurrentEnergyThisType < currentEnergy) {
                                    triggerAnimation(els.currentEnergyEl, 'flash-red');
                                }
                                updateSingleSliderDisplay(type); // Update display after depletion
                            }
                        }
                    }
                });
                finalDamage += totalExtraDamageFromEnergy; // Add energy damage
                console.log(`After Energy Damage: ${finalDamage}`); // Debug Log
            // --- 4. Apply Dynamic Additive Factors ---
                document.querySelectorAll('#dynamic-modifiers-container .dynamic-box').forEach(modifierDiv => {
                    const valueInput = modifierDiv.querySelector('.modifier-value-input');
                    const typeOption = modifierDiv.querySelector('.modifier-type-option.active');
                    if (valueInput && typeOption && typeOption.dataset.value === 'additive') {
                        const modifierValue = safeParseFloat(valueInput.value, 0);
                        if (modifierValue !== 0) { // Only log if it changes something
                            console.log(`Applying Additive Modifier: +${modifierValue}`); // Debug Log
                            finalDamage += modifierValue;
                        }
                    }
                });
                 console.log(`After Additive Mods: ${finalDamage}`); // Debug Log

                // --- 5. Calculate and Add Speed Damage ---
                speedDamage = 0; // Reset for this calculation
                const speedSlider = document.getElementById('speed-slider');
                const baseSpeed = safeParseFloat(charSpeedInput?.value, 0);
                if (speedSlider && baseSpeed > 0) {
                    const sliderPercent = safeParseFloat(speedSlider.value, 0);
                    if (sliderPercent > 0) {
                        const speedUsed = baseSpeed * (sliderPercent / 100);
                        speedDamage = speedUsed * 1; // 1:1 conversion
                        finalDamage += speedDamage; // Add speed damage
                         console.log(`Speed Damage: Used ${speedUsed}, Added ${speedDamage}`); // Debug Log
                    }
                }
                 console.log(`After Speed Damage: ${finalDamage}`); // Debug Log

                // --- 6. Apply Kaioken Health Strain ---
                healthDepleted = false;
                if (energyType === 'ki' && kaiokenCheckbox.checked) { // Only check if focused energy is Ki
                    const currentHealthVal = parseFormattedNumber(currentHealthEl.textContent);
                    if (currentHealthVal > 0) {
                        const maxHealth = safeParseFloat(maxHealthInput.value, 0);
                        const kaiokenStrainPercent = safeParseFloat(kaiokenStrainInput.value, 0);
                        if (maxHealth > 0 && kaiokenStrainPercent > 0) {
                            const strainCost = maxHealth * (kaiokenStrainPercent / 100);
                            let newHealth = Math.max(0, currentHealthVal - strainCost);
                            currentHealthEl.textContent = formatStatNumber(newHealth);
                             console.log(`Kaioken Strain: Cost ${strainCost}, New Health ${newHealth}`); // Debug Log
                            if (newHealth < currentHealthVal) { triggerAnimation(currentHealthEl, 'flash-red'); }
                            if (newHealth === 0) { healthDepleted = true; console.warn("Health depleted by Kaioken!"); }
                        }
                    }
                }

                // --- 7. Update Overall Stats ---
                // Ensure finalDamage is not negative before adding to totals
                finalDamage = Math.max(0, finalDamage);
                totalDamageDealt += finalDamage;
                totalEnergySpent += totalEnergyUsedFromSliders; // Speed usage isn't tracked in "Energy Spent"
                attackCount++;
                if (finalDamage > highestDamage) {
                    highestDamage = finalDamage;
                }
                updateStatsDisplay(); // Update stats panel BEFORE potentially applying buffs
                // --- 8. *** APPLY FORM BUFFS (for NEXT turn) *** ---
                // Find which forms were active during *this* calculation
                const activeFormIdsThisTurn = [...(calculatorState.activeFormIds || [])]; // Clone array to avoid issues if state changes during loop
                let anyFormBuffed = false; // Track if any buff was applied

                if (activeFormIdsThisTurn.length > 0) {
                     console.log("Applying buffs for active forms:", activeFormIdsThisTurn); // Debug Log
                     activeFormIdsThisTurn.forEach(formId => {
                         const formIndex = characterForms.findIndex(f => f.id === formId);
                         if (formIndex > -1) {
                             const form = characterForms[formIndex]; // Get direct reference to modify object in the array
                             let formUpdated = false;

                             // Apply Form Multiplier Buff
                             if (form.enableFormBuff && form.formBuffValue != 0) { // Ensure buff is enabled and value is non-zero
                                 const buffVal = safeParseFloat(form.formBuffValue, 0);
                                 const currentMult = form.formMultiplier; // Get current value before modification
                                 if (form.formBuffType === 'add') {
                                     form.formMultiplier += buffVal;
                                 } else if (form.formBuffType === 'multiply') {
                                     form.formMultiplier *= buffVal;
                                 }
                                  form.formMultiplier = Math.max(0, form.formMultiplier); // Prevent negative multipliers
                                 if (form.formMultiplier !== currentMult) { // Check if value actually changed
                                     formUpdated = true;
                                     console.log(`Form "${form.name}" FM buffed: ${currentMult} -> ${form.formMultiplier}`); // Debug Log
                                 }
                             }

                             // Apply Pool Max Multiplier Buff
                             if (form.enablePoolBuff && form.poolBuffValue != 0) { // Ensure buff is enabled and value is non-zero
                                 const buffVal = safeParseFloat(form.poolBuffValue, 0);
                                 const currentMult = form.poolMaxMultiplier; // Get current value before modification
                                 if (form.poolBuffType === 'add') {
                                     form.poolMaxMultiplier += buffVal;
                                 } else if (form.poolBuffType === 'multiply') {
                                     form.poolMaxMultiplier *= buffVal;
                                 }
                                  form.poolMaxMultiplier = Math.max(0, form.poolMaxMultiplier); // Prevent negative multipliers
                                 if (form.poolMaxMultiplier !== currentMult) { // Check if value actually changed
                                     formUpdated = true;
                                      console.log(`Form "${form.name}" PM buffed: ${currentMult} -> ${form.poolMaxMultiplier}`); // Debug Log
                                 }
                             }

                             if (formUpdated) {
                                 anyFormBuffed = true; // Mark that at least one form was updated
                                 // We are directly modifying the object within the characterForms array
                             }
                         } else {
                              console.warn(`Tried to apply buff, but couldn't find form with ID: ${formId}`);
                         }
                     });

                     // If any forms were updated by buffs, refresh UI elements that depend on characterForms data
                      if (anyFormBuffed) {
                          console.log("Forms were buffed, refreshing relevant UI for next calculation cycle...");
                          renderFormList();           // Update tooltips in stats panel list
                          renderActiveFormsSection(); // Update tooltips on checkboxes
                          applyActiveFormEffects();   // Re-apply combined effects based on NEWLY buffed values for display consistency
                          // Equation display will be updated just before showing results anyway
                      }
                }
                // --- End Form Buff Logic ---
                // --- 9. Display results ---
                // Ensure final damage is non-negative for display
                finalDamage = Math.max(0, finalDamage);

                resultValueEl.textContent = formatSimpleNumber(finalDamage);
                resultTotalEnergyUsedEl.textContent = formatStatNumber(totalEnergyUsedFromSliders); // Only energy used
                // Include speed damage in the "Extra Damage" display
                const totalExtraDamage = totalExtraDamageFromEnergy + speedDamage;
                resultTotalExtraDamageEl.textContent = formatStatNumber(totalExtraDamage);
                const extraDamageLabel = resultTotalExtraDamageEl.closest('p')?.querySelector('strong');
                if (extraDamageLabel) {
                    extraDamageLabel.textContent = 'Total Extra Damage (Energy + Speed):';
                }

                displayAllFormats(finalDamage);
                updateEquationDisplay(); // Update equation one last time AFTER potential buffs for link accuracy
                resultDiv.classList.remove('hidden', 'bg-error-light', 'border-error', 'text-error-dark');
                resultDiv.classList.add('bg-success-light', 'border-success', 'text-success-dark');
                resultDiv.classList.remove('animate__animated', 'animate__fadeInUp');
                void resultDiv.offsetWidth; // Trigger reflow for animation restart
                resultDiv.classList.add('animate__animated', 'animate__fadeInUp');
                resultDiv.querySelector('.result-title').className = 'result-title text-lg font-semibold mb-2 text-success-dark';
                let successMsg = 'Calculation successful!';
                if (healthDepleted) { successMsg += ' Warning: Health depleted by Kaioken strain!'; }
                showMessage(successMsg, healthDepleted ? 'error' : 'success');

            } catch (error) {
                console.error("Calculation Error:", error);
                // Display error state...
                resultValueEl.textContent = 'Error';
                resultTotalEnergyUsedEl.textContent = 'N/A';
                resultTotalExtraDamageEl.textContent = 'N/A';
                resultScientificEl.textContent = 'N/A';
                resultWordsEl.textContent = 'Error';
                equationDisplayEl.innerHTML = '<span class="text-error-dark">Error calculating equation.</span>';
                resultDiv.classList.remove('hidden', 'bg-success-light', 'border-success', 'text-success-dark');
                resultDiv.classList.add('bg-error-light', 'border-error', 'text-error-dark');
                resultDiv.querySelector('.result-title').className = 'result-title text-lg font-semibold mb-2 text-error-dark';
                showMessage(`Calculation failed: ${error.message || 'Unknown error'}`, 'error');
            } finally {
                showLoading(false); // Ensure loading indicator is hidden
            }
        }, 50); // Short delay for loading indicator allows UI to update
    } // <-- End of performCalculation function
    // --- Number Formatting ---
    function displayAllFormats(damage) {
         // Ensure damage is a valid number before formatting
         damage = safeParseFloat(damage, 0);
         try {
             resultScientificEl.textContent = damage.toExponential(2).replace(/e\+?(-?)/, ' x 10^$1');
         } catch (e) {
             resultScientificEl.textContent = "Invalid";
             console.error("Scientific notation error:", e);
         }
         try {
             resultWordsEl.textContent = convertNumberToWords(damage);
         } catch (e) {
             resultWordsEl.textContent = "Error: " + e.message;
             console.error("Number to words error:", e);
         }
     }
    // This long function converts a number to words (remains unchanged)
    function convertNumberToWords(number) { const units = ['', 'One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Eleven', 'Twelve', 'Thirteen', 'Fourteen', 'Fifteen', 'Sixteen', 'Seventeen', 'Eighteen', 'Nineteen']; const tens = ['', '', 'Twenty', 'Thirty', 'Forty', 'Fifty', 'Sixty', 'Seventy', 'Eighty', 'Ninety']; const scales = [ '', 'Thousand', 'Million', 'Billion', 'Trillion', 'Quadrillion', 'Quintillion', 'Sextillion', 'Septillion', 'Octillion', 'Nonillion', 'Decillion', 'Undecillion', 'Duodecillion', 'Tredecillion', 'Quattuordecillion', 'Quindecillion', 'Sexdecillion', 'Septendecillion', 'Octodecillion', 'Novemdecillion', 'Vigintillion', 'Unvigintillion', 'Duovigintillion', 'Tresvigintillion', 'Quattuorvigintillion', 'Quinvigintillion', 'Sesvigintillion', 'Septemvigintillion', 'Octovigintillion', 'Novemvigintillion', 'Trigintillion', 'Untrigintillion', 'Duotrigintillion', 'Trestrigintillion', 'Quattuortrigintillion', 'Quintrigintillion', 'Sestrigintillion', 'Septentrigintillion', 'Octotrigintillion', 'Noventrigintillion', 'Quadragintillion', 'Unquadragintillion', 'Duoquadragintillion', 'Tresquadragintillion', 'Quattuorquadragintillion', 'Quinquadragintillion', 'Sesquadragintillion', 'Septenquadragintillion', 'Octoquadragintillion', 'Novemquadragintillion', 'Quinquagintillion', 'Unquinquagintillion', 'Duoquinquagintillion', 'Tresquinquagintillion', 'Quattuorquinquagintillion', 'Quinquinquagintillion', 'Sesquinquagintillion', 'Septenquinquagintillion', 'Octoquinquagintillion', 'Novemquinquagintillion', 'Sexagintillion', 'Unsexagintillion', 'Duosexagintillion', 'Tresexagintillion', 'Quattuorsexagintillion', 'Quinsexagintillion', 'Sesexagintillion', 'Septensexagintillion', 'Octosexagintillion', 'Novemsexagintillion', 'Septuagintillion', 'Unseptuagintillion', 'Duoseptuagintillion', 'Tresseptuagintillion', 'Quattuorseptuagintillion', 'Quinseptuagintillion', 'Seseptuagintillion', 'Septenseptuagintillion', 'Octoseptuagintillion', 'Novemseptuagintillion', 'Octogintillion', 'Unoctogintillion', 'Duooctogintillion', 'Tresoctogintillion', 'Quattuoroctogintillion', 'Quinoctogintillion', 'Sexoctogintillion', 'Septemoctogintillion', 'Octooctogintillion', 'Novemoctogintillion', 'Nonagintillion', 'Unnonagintillion', 'Duononagintillion', 'Tresnonagintillion', 'Quattuornonagintillion', 'Quinnonagintillion', 'Senonagintillion', 'Septenonagintillion', 'Octononagintillion', 'Novenonagintillion', 'Centillion' ]; if (typeof number !== 'number' || !isFinite(number)) { return 'Invalid Number'; } if (number === 0) { return 'Zero'; } const MAX_SAFE_INTEGER_FOR_WORDS = BigInt("9".repeat((scales.length) * 3)); let numForCheck; try { numForCheck = number < 0 ? BigInt(Math.abs(Math.trunc(number))) : BigInt(Math.trunc(number)); } catch (e) { console.error("Error converting number to BigInt for size check:", number, e); return number.toExponential(2) + " (Extremely large)"; } if (numForCheck > MAX_SAFE_INTEGER_FOR_WORDS) { console.warn("Number too large for full word conversion, returning scientific."); return number.toExponential(2) + " (Too large for words)"; } let isNegative = number < 0; if (isNegative) number = -number; let integerPart; let fractionalPart = 0; try { const numStr = number.toLocaleString('en-US', { useGrouping: false, maximumFractionDigits: 20 }); const parts = numStr.split('.'); integerPart = BigInt(parts[0]); if (parts.length > 1) { fractionalPart = parseFloat('0.' + parts[1]); } } catch (e) { console.error("Error processing number for words:", number, e); return "Number too large or invalid format"; } let words = isNegative ? 'Negative ' : ''; function convertHundreds(num) { let word = ''; const h = Math.floor(num / 100); const r = num % 100; if (h > 0) { word += units[h] + ' Hundred'; } if (r > 0) { if (word !== '') word += ' '; if (r < 20) { word += units[r]; } else { const t = Math.floor(r / 10); const o = r % 10; word += tens[t]; if (o > 0) { word += '-' + units[o]; } } } return word; } if (integerPart === 0n) { if (fractionalPart === 0) words += 'Zero'; } else { let scaleIndex = 0; let tempWords = []; let currentInt = integerPart; while (currentInt > 0n) { if (scaleIndex >= scales.length) { console.error("Number exceeds defined scales during conversion:", number); return number.toExponential(2) + " (Too large for words)"; } const chunk = Number(currentInt % 1000n); if (chunk !== 0) { const chunkWords = convertHundreds(chunk); tempWords.push(chunkWords + (scaleIndex > 0 ? ' ' + scales[scaleIndex] : '')); } currentInt /= 1000n; scaleIndex++; } words += tempWords.reverse().filter(w => w.trim()).join(', '); } if (fractionalPart > 1e-9) { words += ' Point'; let fractionalStr = fractionalPart.toFixed(6).substring(2).replace(/0+$/, ''); if (fractionalStr.length > 0) { for (const digit of fractionalStr) { words += ' ' + (units[parseInt(digit)] || 'Zero'); } } else { words = words.replace(/ Point$/, ''); } } return words.trim(); }
    // --- Equation Display Function (Includes Speed Term) ---
    function updateEquationDisplay() {
         if (!equationDisplayEl) return;
         let equationHTML = '';
         const op = (operator) => `<span class="equation-operator">${operator}</span>`;
         const group = (content) => `<span class="equation-group">(</span>${content}<span class="equation-group">)</span>`;
         // Helper to create clickable number spans linked to input IDs
         const num = (value, targetId, title = '') => {
             const titleAttr = title ? ` title="${escapeHtml(title)}"` : '';
             // Ensure targetId is not null/undefined before using it
             const targetAttr = targetId ? ` data-target-id="${targetId}"` : '';
             return `<span class="equation-number"${targetAttr}${titleAttr}>${formatSimpleNumber(value)}</span>`;
         };

         try {
             const baseDamage = safeParseFloat(baseDamageInput.value, 0);
             const baseMultiplier = safeParseFloat(baseMultiplierInput.value, 1);
             // Use the *combined* form multiplier currently displayed
             const formMultiplierVal = safeParseFloat(formMultiplierInput.value, 1);

             let basePart = num(baseDamage, 'base-damage', 'Base Damage');
             // Only show base multiplier if not default 1
             if (baseMultiplier !== 1 || baseMultiplierInput.value.trim() !== '1') {
                 basePart += op('*') + num(baseMultiplier, 'base-multiplier', 'Base Multiplier');
             }
             // Only show combined form multiplier if not default 1
             if (formMultiplierVal !== 1 || formMultiplierInput.value.trim() !== '1') {
                 basePart += op('*') + num(formMultiplierVal, 'form-multiplier', 'Combined Form Multiplier');
             }

             // Group base parts if there was multiplication
             let baseCalculationHTML = (basePart.includes(op('*'))) ? group(basePart) : basePart;

             // Add Compression Points multiplier if applicable
             const compressionPoints = safeParseFloat(attackCompressionPointsInput.value, 0);
             if (compressionPoints > 0) {
                 let compressionMultiplierValue = Math.max(1, (compressionPoints * 1.5) + (Math.floor(compressionPoints / 10) * 3));
                  // Ensure grouping if previous part exists and compression is added
                 if (baseCalculationHTML && baseCalculationHTML !== '0') {
                     baseCalculationHTML = group(baseCalculationHTML);
                 } else if (!baseCalculationHTML || baseCalculationHTML === '0') {
                     // If base damage part was 0 or empty, start fresh but show the 1x multiplier implicitly
                     baseCalculationHTML = ''; // Will just show compression multiplier
                 }
                 baseCalculationHTML += (baseCalculationHTML ? op('*') : '') + num(compressionMultiplierValue, 'attack-compression-points', `${compressionPoints} Comp. Points -> x${formatSimpleNumber(compressionMultiplierValue)} Multiplier`);
             }
             equationHTML = baseCalculationHTML || '0'; // Start with base calculation or 0

             // Add Dynamic Multiplicative Modifiers
             let multiplicativeTerms = [];
             document.querySelectorAll('#dynamic-modifiers-container .dynamic-box').forEach((modifierDiv) => {
                 const valueInput = modifierDiv.querySelector('.modifier-value-input');
                 const typeOption = modifierDiv.querySelector('.modifier-type-option.active');
                 const nameInput = modifierDiv.querySelector('.modifier-name-input');
                 const modifierId = valueInput?.id;
                 const factorName = nameInput?.value.trim() || 'Unnamed Multiplier';
                 if (valueInput && typeOption && modifierId && typeOption.dataset.value === 'multiplicative') {
                     const multiplier = safeParseFloat(valueInput.value, 1);
                     if (multiplier !== 1 || valueInput.value.trim() !== '1') { // Only include if not default 1
                         multiplicativeTerms.push(num(multiplier, modifierId, factorName));
                     }
                 }
             });
             if (multiplicativeTerms.length > 0) {
                 // Group previous parts if they exist and contain operations or if there's more than one mult term
                 if (equationHTML.includes(op('*')) || equationHTML.includes(op('+')) || multiplicativeTerms.length > 1) {
                      if (equationHTML !== '0') equationHTML = group(equationHTML); // Group if not just 0
                 }
                  if (equationHTML === '0') equationHTML = ''; // Avoid showing "0 * (...)"
                 equationHTML += (equationHTML ? op('*') : '') + (multiplicativeTerms.length > 1 ? group(multiplicativeTerms.join(op('*'))) : multiplicativeTerms[0]);
             }

             // Add Energy Damage Terms
             let energyTerms = [];
             ALL_ENERGY_TYPES.forEach(type => {
                 const els = getEnergyElements(type);
                 if (els?.energySlider && els.currentEnergyEl && els.damagePerPowerEl) {
                     const sliderPercent = safeParseFloat(els.energySlider.value, 0);
                     const activeAttack = activeAttacks[type] || null;
                     let limitPercent = 100;
                     if (activeAttack === 'super') limitPercent = 95;
                     else if (activeAttack === 'ultimate') limitPercent = 90;
                     const effectivePercent = Math.min(sliderPercent, limitPercent);
                     if (effectivePercent > 0) {
                         const currentEnergy = parseFormattedNumber(els.currentEnergyEl.textContent);
                         if (currentEnergy > 0) {
                             const damagePerPower = safeParseFloat(els.damagePerPowerEl.value, 1);
                             const energyUsed = Math.min(currentEnergy * (effectivePercent / 100), currentEnergy);
                             const energyDamage = energyUsed * damagePerPower;
                             if (energyDamage !== 0) {
                                 const energyTitle = `${ENERGY_TYPE_DETAILS[type]?.name || type} Energy Used (${sliderPercent}%)`;
                                 const dppTitle = `${ENERGY_TYPE_DETAILS[type]?.name || type} Damage/Point`;
                                 let term = num(energyUsed, `${type}-energy-slider`, energyTitle);
                                 if (damagePerPower !== 1 || els.damagePerPowerEl.value.trim() !== '1') {
                                      term += op('*') + num(damagePerPower, `${type}-damage-per-power`, dppTitle);
                                      term = group(term); // Group if DPP is involved
                                 }
                                 energyTerms.push(term);
                             }
                         }
                     }
                 }
             });
             if (energyTerms.length > 0) {
                 // Group previous calculation before adding energy terms
                 if (equationHTML.includes(op('*')) || equationHTML.includes(op('+'))) {
                     if (equationHTML !== '0') equationHTML = group(equationHTML);
                 }
                 if (equationHTML === '0') equationHTML = ''; // Avoid 0 + (...)
                  equationHTML += (equationHTML ? op('+') : '') + group(energyTerms.join(op('+')));
             }

             // Add Dynamic Additive Modifiers
             let additiveTerms = [];
             document.querySelectorAll('#dynamic-modifiers-container .dynamic-box').forEach((modifierDiv) => {
                 const valueInput = modifierDiv.querySelector('.modifier-value-input');
                 const typeOption = modifierDiv.querySelector('.modifier-type-option.active');
                 const nameInput = modifierDiv.querySelector('.modifier-name-input');
                 const modifierId = valueInput?.id;
                 const factorName = nameInput?.value.trim() || 'Unnamed Additive';
                 if (valueInput && typeOption && modifierId && typeOption.dataset.value === 'additive') {
                     const modifierValue = safeParseFloat(valueInput.value, 0);
                     if (modifierValue !== 0 || valueInput.value.trim() !== '0') { // Only include if not default 0
                         additiveTerms.push(num(modifierValue, modifierId, factorName));
                     }
                 }
             });
             if (additiveTerms.length > 0) {
                 // Group previous calculation before adding additive terms
                 if (equationHTML.includes(op('*')) || equationHTML.includes(op('+'))) {
                      if (equationHTML !== '0') equationHTML = group(equationHTML);
                 }
                 if (equationHTML === '0') equationHTML = ''; // Avoid 0 + (...)
                 equationHTML += (equationHTML ? op('+') : '') + (additiveTerms.length > 1 ? group(additiveTerms.join(op('+'))) : additiveTerms[0]);
             }

             // Add Speed Term (At the end)
             const speedSliderEq = document.getElementById('speed-slider');
             const baseSpeedEq = safeParseFloat(charSpeedInput?.value, 0);
             if (speedSliderEq && baseSpeedEq > 0) {
                 const sliderPercentEq = safeParseFloat(speedSliderEq.value, 0);
                 if (sliderPercentEq > 0) {
                      const speedUsedEq = baseSpeedEq * (sliderPercentEq / 100);
                      const speedDamageEq = speedUsedEq * 1; // 1:1 conversion
                      if (speedDamageEq !== 0) {
                         // Group previous calculation before adding speed term
                         if (equationHTML.includes(op('*')) || equationHTML.includes(op('+'))) {
                              if (equationHTML !== '0') equationHTML = group(equationHTML);
                         }
                          if (equationHTML === '0') equationHTML = ''; // Avoid 0 + (...)
                         // Use speed-slider as the target ID for linking
                         equationHTML += (equationHTML ? op('+') : '') + num(speedDamageEq, 'speed-slider', `${formatSimpleNumber(speedUsedEq)} Speed Used`);
                      }
                 }
             }

             // Final display assignment
              if (!equationHTML || equationHTML.trim() === '0') {
                  equationHTML = '0'; // Display '0' if calculation results in empty string or just '0'
              }
             equationDisplayEl.innerHTML = equationHTML;
         } catch (error) {
             console.error("Error updating equation:", error);
             equationDisplayEl.innerHTML = '<span class="text-error-dark">Could not generate equation.</span>';
         }
        }
       // --- Click Handler for Equation Numbers ---
     function handleEquationClick(event) {
         const target = event.target;
         // Check if the clicked element is a number span with a target ID
         if (target.classList.contains('equation-number') && target.dataset.targetId) {
             const targetId = target.dataset.targetId;
             const sourceElement = document.getElementById(targetId); // Find the linked input/slider/etc.

             if (sourceElement) {
                 // Scroll the source element into view
                 sourceElement.scrollIntoView({ behavior: 'smooth', block: 'center' });

                 // Determine which element to visually pulse
                 let elementToPulse = sourceElement;
                 if (sourceElement.tagName === 'SPAN' && sourceElement.classList.contains('readonly-display')) {
                     // If it's a read-only display span (like current energy), pulse the parent pool
                     elementToPulse = sourceElement.closest('.energy-pool') || sourceElement;
                 } else if (sourceElement.type === 'range') {
                     // If it's a slider input, pulse its parent section
                     elementToPulse = sourceElement.closest('.energy-slider-section') || sourceElement;
                 } else if (sourceElement.classList.contains('modifier-value-input')) {
                      // If it's an input within a dynamic modifier box, pulse the box
                     elementToPulse = sourceElement.closest('.dynamic-box') || sourceElement;
                 }
                 // Specific case for Speed slider link in equation
                  else if (targetId === 'speed-slider') {
                       elementToPulse = document.getElementById('speed-slider-section') || sourceElement;
                  }

                 // Trigger the pulse animation
                 triggerAnimation(elementToPulse, 'pulse-source');

                 // Focus the element if it's an editable input (not range or readonly)
                 if (sourceElement.tagName === 'INPUT' && !sourceElement.readOnly && sourceElement.type !== 'range') {
                     sourceElement.focus();
                 }

                 // Check if the click corresponds to an energy element that isn't currently focused
                 const energyTypeMatch = targetId.match(/^([a-z]+)-(damage-per-power|energy-slider|max-multiplier)/);
                 if (energyTypeMatch) {
                     const energyType = energyTypeMatch[1];
                     if (ALL_ENERGY_TYPES.includes(energyType) && energyTypeSelect.value !== energyType) {
                         // If clicking an energy element from a non-focused pool, switch the view
                         console.log(`Switching view to ${energyType} pool triggered by equation click...`);
                         energyTypeSelect.value = energyType;
                         showSelectedEnergyPool(); // This will show the correct pool
                     }
                 }
             } else {
                 console.warn(`Equation link target element not found: #${targetId}`);
             }
         }
     }         
    // --- Tab Switching Logic ---
    function showCharacterStatsView() {
        if (mainCalculatorContent) mainCalculatorContent.classList.add('hidden');
        if (characterStatsScreen) characterStatsScreen.classList.remove('hidden');
        if (mainTitle) mainTitle.textContent = 'Character Stats';
        if (showCharacterStatsBtn) showCharacterStatsBtn.textContent = 'Energy Calculator';
        if (characterStatsScreen) triggerAnimation(characterStatsScreen, 'fadeIn');
        // Store view preference
        calculatorState.activeView = 'stats';
    }
    function showCalculatorView() {
        if (characterStatsScreen) characterStatsScreen.classList.add('hidden');
        if (mainCalculatorContent) mainCalculatorContent.classList.remove('hidden');
        if (mainTitle) mainTitle.textContent = 'Energy Calculator';
        if (showCharacterStatsBtn) showCharacterStatsBtn.textContent = 'Character Stats';
        if (mainCalculatorContent) triggerAnimation(mainCalculatorContent, 'fadeIn');
        // Store view preference
        calculatorState.activeView = 'calculator';
    }
    // --- Event Listener Helper ---
    // This function is called when character stats like Vitality, Speed, etc. change
    function handleStatChange() {
        console.log("Stat change detected, updating dependent elements..."); // Debug Log
        // Update Base AC/TR/Speed in stats panel display immediately
        updateStatsDisplay(); // Includes speed stat display update now

        // Recalculate all energy pools as base stats affect them
        // Also ensures Pool Max Multipliers (which might depend on forms) are re-applied correctly
        // Note: applyActiveFormEffects also calls calculateAndResetEnergy internally for relevant pools
        applyActiveFormEffects();

        // Update equation
        updateEquationDisplay();

        // Ensure Speed Slider UI is updated based on the new speed value
        updateSpeedSliderVisibility(); // Show/hide slider based on new speed value
        updateSpeedSliderDisplay();   // Update slider text (S: ..., D: ...)
    }
    // --- Ryoko Mode Logic ---
    function handleRyokoCheckboxChange() { if (!ryokoCheckbox || !ryokoEquationContainer || !charBaseMultiplierInput || !ryokoEquationInput) return; const isChecked = ryokoCheckbox.checked; ryokoEquationContainer.classList.toggle('hidden', !isChecked); charBaseMultiplierInput.readOnly = isChecked; charBaseMultiplierInput.classList.toggle('bg-gray-100', isChecked); charBaseMultiplierInput.classList.toggle('cursor-not-allowed', isChecked); charBaseMultiplierInput.classList.toggle('opacity-70', isChecked); if (isChecked) { if (ryokoEquationInput.value.trim() === '') { ryokoEquationInput.value = DEFAULT_RYOKO_EQUATION; } evaluateRyokoEquation(); ryokoEquationInput.focus(); } else { ryokoEquationInput.classList.remove('border-red-500', 'focus:ring-red-500'); ryokoEquationInput.classList.add('border-gray-300', 'focus:ring-teal-focus'); // Revert border/focus
           // Need to re-evaluate standard stats if Ryoko mode is turned off
           handleStatChange();
        }
        // No need to call handleStatChange if Ryoko mode is turned on, as evaluateRyokoEquation calls it.
     }

    function evaluateRyokoEquation() { if (!ryokoCheckbox || !ryokoCheckbox.checked || !ryokoEquationInput || !charBaseMultiplierInput) return; const expression = ryokoEquationInput.value.trim(); let result = 1; ryokoEquationInput.classList.remove('border-red-500', 'focus:ring-red-500'); ryokoEquationInput.classList.add('border-gray-300', 'focus:ring-teal-focus'); if (expression) { try { const evaluatedResult = math.evaluate(expression); if (typeof evaluatedResult === 'number' && isFinite(evaluatedResult)) { result = evaluatedResult; } else { console.error("Ryoko equation evaluated to non-finite number:", evaluatedResult); throw new Error("Invalid result (NaN or Infinity)"); } } catch (error) { console.error("Error evaluating Ryoko equation:", error); ryokoEquationInput.classList.remove('focus:ring-teal-focus'); ryokoEquationInput.classList.add('border-red-500', 'focus:ring-red-500'); showMessage(`Invalid Ryoko equation: ${error.message}`, 'error'); result = 1; } } charBaseMultiplierInput.value = formatSimpleNumber(result); handleStatChange(); } // Calls handleStatChange after evaluation
    // --- State Management ---
    function gatherState() {
        const state = {
            // Basic inputs
            baseDamage: baseDamageInput.value,
            baseMultiplier: baseMultiplierInput.value,
            attackCompressionPoints: attackCompressionPointsInput.value,
            selectedEnergyType: energyTypeSelect.value, // Still useful for focus/Kaioken
            // Character Stats
            characterName: characterNameInput?.value || '',
            charBaseHealth: charBaseHealthInput?.value || '',
            charBaseMultiplier: charBaseMultiplierInput?.value || '1',
            charVitality: charVitalityInput?.value || '',
            charSoulPower: charSoulPowerInput?.value || '',
            charSoulHp: charSoulHpInput?.value || '',
            charBaseAc: charBaseAcInput?.value || '10',
            charBaseTr: charBaseTrInput?.value || '5',
            charSpeed: charSpeedInput?.value || '',      // <<< Speed Input Save
            // Ryoko Mode
            ryokoCheckboxState: ryokoCheckbox?.checked || false,
            ryokoEquationValue: ryokoEquationInput?.value || '',
            // UI State
            activeView: calculatorState.activeView || 'calculator', // Get from state
            // Kaioken State
            kaiokenActive: kaiokenCheckbox.checked,
            maxHealth: maxHealthInput.value,
            kaiokenStrain: kaiokenStrainInput.value,
            currentHealth: currentHealthEl?.textContent || '0',
            // Energy Pool Details & Sliders
            sliderPercentages: {}, // For energy sliders
            energyPools: {},       // For pool-specific inputs like DPP, regen, current value
             // Form System State
            characterForms: characterForms,         // Save the array of form objects (includes buff values now)
            activeFormIds: calculatorState.activeFormIds || [], // <<< Save active form IDs array
            // Other dynamic elements
            dynamicModifiers: [],
            activeAttacks: activeAttacks,
            // Overall Stats
            totalDamageDealt: totalDamageDealt,
            totalEnergySpent: totalEnergySpent,
            attackCount: attackCount,
            highestDamage: highestDamage,
        };

        // Gather Energy Pool Data
        ALL_ENERGY_TYPES.forEach(type => {
            const els = getEnergyElements(type);
            if (els) {
                state.energyPools[type] = {
                    // Note: maxMultiplier is controlled by forms, but save the input value anyway
                    maxMultiplier: els.maxMultiplierEl?.value || '1',
                    currentEnergy: els.currentEnergyEl?.textContent || '0',
                    damagePerPower: els.damagePerPowerEl?.value || '1',
                    regenPercent: els.regenPercentEl?.value || ''
                 };
                 state.sliderPercentages[type] = els.energySlider?.value || '0';
            }
        });

        // Gather Speed Slider Percentage
        const speedSlider = document.getElementById('speed-slider');
        state.speedSliderPercentage = speedSlider?.value || '0'; // <<< Speed Slider Save

        // Gather Dynamic Modifiers
        dynamicModifiersContainer.querySelectorAll('.dynamic-box').forEach(box => {
            const nameInput = box.querySelector('.modifier-name-input');
            const valueInput = box.querySelector('.modifier-value-input');
            const typeOption = box.querySelector('.modifier-type-option.active');
            if (nameInput && valueInput && typeOption) {
                state.dynamicModifiers.push({
                    name: nameInput.value,
                    value: valueInput.value,
                    type: typeOption.dataset.value });
            }
        });

        console.log("State gathered:", state); // Debug Log
        return state;
    }   
    function applyState(state) {
        if (!state) {
             console.warn("applyState called with null or undefined state.");
             return; // Exit if no state provided
        }
        console.log("Applying loaded state...");

        // Restore Character Stats first, as they influence other calculations
        if (characterNameInput) characterNameInput.value = state.characterName || '';
        if (charBaseHealthInput) charBaseHealthInput.value = state.charBaseHealth || '';
        if (charBaseMultiplierInput) charBaseMultiplierInput.value = state.charBaseMultiplier || '1';
        if (charVitalityInput) charVitalityInput.value = state.charVitality || '';
        if (charSoulPowerInput) charSoulPowerInput.value = state.charSoulPower || '';
        if (charSoulHpInput) charSoulHpInput.value = state.charSoulHp || '';
        if (charBaseAcInput) charBaseAcInput.value = state.charBaseAc || '10';
        if (charBaseTrInput) charBaseTrInput.value = state.charBaseTr || '5';
        if (charSpeedInput) charSpeedInput.value = state.charSpeed || '';     // <<< Restore Speed

        // Restore Ryoko state & Apply potential base multiplier override (needs to happen before energy calcs)
        if (ryokoCheckbox) ryokoCheckbox.checked = state.ryokoCheckboxState || false;
        if (ryokoEquationInput) ryokoEquationInput.value = state.ryokoEquationValue || '';
        handleRyokoCheckboxChange(); // Apply UI changes and potentially recalculate multiplier, then calls handleStatChange

        // Restore Calculator Inputs
        baseDamageInput.value = state.baseDamage || '';
        attackCompressionPointsInput.value = state.attackCompressionPoints || '0';
        energyTypeSelect.value = state.selectedEnergyType || 'ki'; // Restore focus type

        // Restore Form Data (including buff states within the form objects)
        characterForms = state.characterForms || []; // Load forms array
        // Restore the list of active form IDs
        calculatorState.activeFormIds = Array.isArray(state.activeFormIds) ? state.activeFormIds : []; // Ensure it's an array

        // Restore energy pool details (DPP, Regen %, Current Value)
        // Note: Max Multiplier input value will be set by applyActiveFormEffects later
        if (state.energyPools) {
             ALL_ENERGY_TYPES.forEach(type => {
                 const els = getEnergyElements(type);
                 const poolData = state.energyPools[type];
                 if (els && poolData) {
                     // Restore inputs directly modifiable by user within the pool section
                     if(els.damagePerPowerEl) els.damagePerPowerEl.value = poolData.damagePerPower || '1';
                     if(els.regenPercentEl) els.regenPercentEl.value = poolData.regenPercent || '';

                     // --- Defer Current Energy Restoration ---
                     // We need to calculate the Max Energy based on restored stats and active forms first.
                     // We'll restore current energy *after* applyActiveFormEffects runs.
                     // Store the saved value temporarily if needed, or just use the value from poolData later.
                 }
             });
        }

        // Restore dynamic modifiers
        dynamicModifiersContainer.innerHTML = '<h4 class="text-md font-semibold mb-2 text-gray-700">Additional Factors:</h4>'; dynamicModifierCount = 0; if (state.dynamicModifiers && Array.isArray(state.dynamicModifiers)) { state.dynamicModifiers.forEach(modData => addDynamicModifier(modData)); }

        // Restore Kaioken state
        kaiokenCheckbox.checked = state.kaiokenActive || false; maxHealthInput.value = state.maxHealth || '1000'; kaiokenStrainInput.value = state.kaiokenStrain || '10'; if(currentHealthEl) { const savedHealthNum = parseFormattedNumber(state.currentHealth || '0'); currentHealthEl.textContent = formatStatNumber(savedHealthNum); }
        // Apply initial Kaioken style if needed (will be re-checked in showSelectedEnergyPool)
        if (kaiokenCheckbox.checked && energyTypeSelect.value === 'ki') { applyKaiokenStyle(); } else { removeKaiokenStyle(); }


        // Restore overall stats tracking
        totalDamageDealt = state.totalDamageDealt || 0; totalEnergySpent = state.totalEnergySpent || 0; attackCount = state.attackCount || 0; highestDamage = state.highestDamage || 0;

        // Restore attack states (which energy types had super/ultimate active)
        activeAttacks = state.activeAttacks || {};

        // --- Update UI based on restored state ---
        // Order is important here!

        // 1. Render form lists (needed before applying effects and restoring current energy)
        renderFormList();           // Update list in stats panel (uses characterForms)
        renderActiveFormsSection(); // Update checkboxes in main section (uses characterForms and activeFormIds)

        // 2. Apply combined form effects (sets multipliers, AC/TR state, recalculates base/total energy pools)
        applyActiveFormEffects();   // Uses activeFormIds and characterForms

        // 3. Restore CURRENT Energy *after* total energy has been recalculated by applyActiveFormEffects
         if (state.energyPools) {
             ALL_ENERGY_TYPES.forEach(type => {
                 const els = getEnergyElements(type);
                 const poolData = state.energyPools[type];
                 if (els && els.currentEnergyEl && poolData) {
                     const savedCurrentNum = parseFormattedNumber(poolData.currentEnergy || '0');
                     const currentTotal = parseFormattedNumber(els.totalEnergyEl.textContent || '0');
                     // Cap saved current energy by the calculated total energy for consistency
                     els.currentEnergyEl.textContent = formatStatNumber(Math.max(0, Math.min(savedCurrentNum, currentTotal)));
                 }
             });
        }


        // 4. Restore slider percentages AFTER pools potentially recalculated by applyActiveFormEffects AND current energy restored
        if (state.sliderPercentages) { ALL_ENERGY_TYPES.forEach(type => { const els = getEnergyElements(type); if (els?.energySlider) { els.energySlider.value = state.sliderPercentages[type] || '0'; updateSingleSliderDisplay(type); } updateSliderVisibility(type); }); }
        // Restore Speed Slider percentage & Update display
        updateSpeedSliderVisibility(); // Ensure slider exists if speed > 0
        const speedSlider = document.getElementById('speed-slider');
        if (speedSlider && state.speedSliderPercentage) { // Check speedSlider exists AFTER visibility check potentially created it
            speedSlider.value = state.speedSliderPercentage || '0';
        }
        updateSpeedSliderDisplay(); // Update display text

        // 5. Update attack button states & slider gradients for focused type
        updateAttackButtonStates(energyTypeSelect.value);
        ALL_ENERGY_TYPES.forEach(type => { updateSliderLimitAndStyle(type); }); // Update all gradients

        // 6. Update stats display and equation (final check based on all restored state)
        updateStatsDisplay();
        updateEquationDisplay();

        // 7. Restore active view (calculator or stats screen)
        calculatorState.activeView = state.activeView || 'calculator'; // Make sure it's set in state object
        if (calculatorState.activeView === 'stats') { showCharacterStatsView(); }
        else { showCalculatorView(); }

        // 8. Ensure the initially selected energy pool is displayed correctly
        showSelectedEnergyPool(); // Call this last to ensure visual consistency for the focused pool

        console.log("State application complete.");
    }
    // *** ADDED FUNCTIONS FOR GOOGLE SIGN-IN / SIGN-OUT ***
    async function handleGoogleSignIn() {
        const provider = new window.firebaseGoogleAuthProvider();
        try {
            console.log("Attempting Google Sign-in...");
            const result = await window.firebaseSignInWithPopup(window.firebaseAuth, provider);
            // onAuthStateChanged will handle loading state and UI updates
            const user = result.user;
            console.log("Google Sign-in successful for:", user.displayName);
            showMessage(`Signed in as ${user.displayName || user.email}`, 'success');
        } catch (error) {
            console.error("Google Sign-in error:", error);
            // Provide more user-friendly messages for common errors
            if (error.code === 'auth/popup-closed-by-user') {
                 showMessage('Sign-in cancelled.', 'info');
            } else if (error.code === 'auth/network-request-failed') {
                 showMessage('Network error during sign-in. Please check connection.', 'error');
            } else {
                showMessage(`Google Sign-in failed: ${error.message}`, 'error');
            }
        }
    }
    async function handleSignOut() {
        try {
            await window.firebaseSignOut(window.firebaseAuth);
            console.log("Sign-out successful.");
            showMessage('Signed out successfully.', 'info');
            // onAuthStateChanged will handle UI/state reset
        } catch (error) {
            console.error("Sign-out error:", error);
            showMessage(`Sign-out failed: ${error.message}`, 'error');
        }
    }
 // --- Helper functions for initialization ---
    function initializeDefaultState() {
        console.log("Initializing default state...");
        // Reset core calculator state variables
        characterForms = []; // Clear saved forms
        calculatorState = { activeFormIds: [], appliedAcBonus: 0, appliedTrueResistanceBonus: 0, activeView: 'calculator' }; // Reset form state & view
        totalDamageDealt = 0; totalEnergySpent = 0; attackCount = 0; highestDamage = 0;
        activeAttacks = {}; // Clear attack reservations

        // Reset UI elements - Character Stats
        if (characterNameInput) characterNameInput.value = '';
        if (charBaseHealthInput) charBaseHealthInput.value = '';
        if (charBaseMultiplierInput) charBaseMultiplierInput.value = '1';
        if (charVitalityInput) charVitalityInput.value = '';
        if (charSoulPowerInput) charSoulPowerInput.value = '';
        if (charSoulHpInput) charSoulHpInput.value = '';
        if (charBaseAcInput) charBaseAcInput.value = '10';
        if (charBaseTrInput) charBaseTrInput.value = '5';
        if (charSpeedInput) charSpeedInput.value = ''; // <<< Reset Speed Input
        if (ryokoCheckbox) ryokoCheckbox.checked = false;
        if (ryokoEquationInput) ryokoEquationInput.value = '';
        handleRyokoCheckboxChange(); // Apply default Ryoko state

        // Reset UI elements - Main Calculator
        baseDamageInput.value = '';
        attackCompressionPointsInput.value = '0';
        energyTypeSelect.value = 'ki'; // Default to Ki focus
        dynamicModifiersContainer.innerHTML = '<h4 class="text-md font-semibold mb-2 text-gray-700">Additional Factors:</h4>'; dynamicModifierCount = 0;
        if(resultDiv) resultDiv.classList.add('hidden'); // Hide results

        // Reset UI elements - Stats Panel / Kaioken
        kaiokenCheckbox.checked = false;
        maxHealthInput.value = '1000';
        kaiokenStrainInput.value = '10';
        if(currentHealthEl) { currentHealthEl.textContent = maxHealthInput.value; }
        removeKaiokenStyle();
        if(kaiokenDetails) kaiokenDetails.classList.add('hidden');


        // --- Update UI based on Default State ---
        // 1. Render empty form lists
        renderFormList();           // Update list in stats panel
        renderActiveFormsSection(); // Update checkboxes in main section

        // 2. Apply default (no) form effects (sets multipliers to 1, bonuses to 0, recalculates energy)
        applyActiveFormEffects();

        // 3. Update sliders (will be hidden if energy/speed is 0)
        ALL_ENERGY_TYPES.forEach(type => { updateSingleSliderDisplay(type); updateSliderVisibility(type); });
        updateSpeedSliderVisibility(); // Ensure speed slider is hidden/shown correctly
        updateSpeedSliderDisplay();   // Ensure speed slider text is correct

        // 4. Update stats display and equation
        updateStatsDisplay();
        updateEquationDisplay();

        // 5. Set default view
        showCalculatorView(); // Default to calculator view
        // showSelectedEnergyPool() is effectively called within applyActiveFormEffects -> calculateAndResetEnergy
    }

    // This function is less critical now as applyState handles most UI updates after loading.
    // It primarily ensures the correct view is displayed.
    function initializeLoadedStateUI() {
        console.log("Initializing UI based on loaded state...");
        // applyState handles calling necessary render/update functions.
        // Just ensure the correct tab/view is displayed based on loaded state.
        const activeView = calculatorState.activeView || 'calculator'; // Get view from state (applyState should set this)
         if (activeView === 'stats') {
             showCharacterStatsView();
         } else {
             showCalculatorView();
         }
         // Potentially re-render form sections just in case applyState order wasn't perfect
         // These are also called within applyState -> showSelectedEnergyPool -> applyActiveFormEffects though
         // renderFormList();
         // renderActiveFormsSection();
    }
    // --- Event Listeners Setup ---
    // NOTE: This function should be called ONLY ONCE after initial HTML generation and DOM references are set.
    function setupEventListeners() {
        console.log("Setting up event listeners...");

        // --- Static element listeners ---
        if (energyTypeSelect) {
             energyTypeSelect.addEventListener('change', () => {
                 console.log('DROPDOWN CHANGED to:', energyTypeSelect.value); // Log for debugging
                 showSelectedEnergyPool();
                 // updateEquationDisplay(); // Called within showSelectedEnergyPool -> applyActiveFormEffects now
             });
        }
        if (calculateBtn) {
             calculateBtn.addEventListener('click', () => {
                 console.log('CALCULATE BUTTON CLICKED'); // Log for debugging
                 triggerAnimation(calculateBtn, 'pulse');
                 performCalculation();
             });
        }
        if (addDynamicBoxBtn) {
            addDynamicBoxBtn.addEventListener('click', () => {
                triggerAnimation(addDynamicBoxBtn, 'pulse');
                addDynamicModifier();
                updateEquationDisplay();
            });
        }
        // Base Damage / Compression / Base Multiplier Inputs -> Update Equation on change
        [baseDamageInput, attackCompressionPointsInput, baseMultiplierInput].forEach(input => {
            if (input) {
                input.addEventListener('input', updateEquationDisplay);
                input.addEventListener('change', updateEquationDisplay);
            }
        });

        // --- Character Stat inputs listener (includes Speed) ---
        // These trigger recalculations of energy pools and other stats
        const characterStatInputs = [
             charBaseHealthInput,
             charVitalityInput,
             charSoulPowerInput,
             charSoulHpInput,
             charBaseAcInput,
             charBaseTrInput,
             charSpeedInput // <<< Added charSpeedInput here
        ];
        characterStatInputs.forEach(input => {
             if (input) {
                 input.addEventListener('input', handleStatChange);
                 input.addEventListener('change', handleStatChange); // Also trigger on change (e.g., paste)
            }
        });

        // Specific handling for Character Base Multiplier (affected by Ryoko mode)
        if (charBaseMultiplierInput) {
             charBaseMultiplierInput.addEventListener('input', () => {
                 // Only trigger full stat change if NOT in Ryoko mode (handled separately)
                 if (!charBaseMultiplierInput.readOnly) {
                     handleStatChange();
                 } else {
                     // If readonly (Ryoko mode), maybe just update equation?
                     updateEquationDisplay();
                 }
             });
             charBaseMultiplierInput.addEventListener('change', () => {
                 if (!charBaseMultiplierInput.readOnly) { handleStatChange();} else { updateEquationDisplay();}
            });
        }
        if (ryokoCheckbox) { ryokoCheckbox.addEventListener('change', handleRyokoCheckboxChange); }
        if (ryokoEquationInput) { ryokoEquationInput.addEventListener('input', evaluateRyokoEquation); ryokoEquationInput.addEventListener('change', evaluateRyokoEquation); }

        /// --- Energy Pool Input Listeners (using delegation on the container) ---
        if (energyPoolsContainer) {
             energyPoolsContainer.addEventListener('input', (event) => {
                 const target = event.target;
                 if (target.classList.contains('max-multiplier')) {
                     const type = target.id.split('-')[0];
                     // Recalculate this pool's energy based on user override of max multiplier
                     // Note: This might get overridden again if active forms change later
                     calculateAndResetEnergy(type);
                     updateStatsDisplay();
                     updateEquationDisplay();
                 } else if (target.classList.contains('damage-per-power')) {
                     const type = target.id.split('-')[0];
                     updateSingleSliderDisplay(type); // Update slider text immediately
                     updateEquationDisplay(); // Update equation immediately
                 } else if (target.classList.contains('regen-percent')) {
                     // No action needed on mere input, only on button click
                 }
                 // No listener needed for form-select as it was removed
             });
             // Listener for Regen button clicks
             energyPoolsContainer.addEventListener('click', (event) => {
                 if (event.target.classList.contains('regen-btn')) {
                     triggerAnimation(event.target, 'pulse');
                     regenerateEnergy(event.target.dataset.type);
                 }
             });
             // Removed change listener for form-select
        }

        // --- Slider Input Listener (Energy + Speed, using delegation on the grid) ---
        if (slidersGrid) {
        slidersGrid.addEventListener('input', (event) => {
            const slider = event.target;
            if (slider.type === 'range' && slider.classList.contains('energy-slider')) {
                const currentType = slider.dataset.type;
                console.log(`Slider input event for type: ${currentType}, value: ${slider.value}`); // <<< ADD THIS LOG

                if (currentType === 'speed') {
                     updateSpeedSliderDisplay();
                     updateEquationDisplay();
                } else if (ALL_ENERGY_TYPES.includes(currentType)) {
                    // Handle Energy Sliders input
                    const activeAttack = activeAttacks[currentType] || null;
                    let limitPercent = 100;
                    if (activeAttack === 'super') limitPercent = 95;
                    else if (activeAttack === 'ultimate') limitPercent = 90;
                    if (parseInt(slider.value) > limitPercent) {
                        slider.value = limitPercent;
                    }
                    console.log(` -> Calling updateSingleSliderDisplay(${currentType})`); // <<< ADD THIS LOG
                    updateSingleSliderDisplay(currentType);
                    updateEquationDisplay();
                }
            }
        });
    }
        // --- Auth buttons ---
        const googleSignInBtn = document.getElementById('google-signin-btn');
        const signOutBtn = document.getElementById('sign-out-btn');
        if (googleSignInBtn) { googleSignInBtn.removeEventListener('click', handleGoogleSignIn); googleSignInBtn.addEventListener('click', handleGoogleSignIn); }
        if (signOutBtn) { signOutBtn.removeEventListener('click', handleSignOut); signOutBtn.addEventListener('click', handleSignOut); }

        // --- Save/Load/Clear buttons ---
        if (saveBtn) saveBtn.addEventListener('click', () => { console.log('SAVE BUTTON CLICKED'); triggerAnimation(saveBtn, 'pulse'); saveState(); });
        if (loadBtn) loadBtn.addEventListener('click', () => { console.log('LOAD BUTTON CLICKED'); triggerAnimation(loadBtn, 'pulse'); loadState().then(loaded => { if(loaded) { showMessage('State loaded successfully.', 'success'); } else { showMessage('No saved state found or failed to load.', 'info');} }); });
        if (clearBtn) clearBtn.addEventListener('click', () => { console.log('CLEAR BUTTON CLICKED'); triggerAnimation(clearBtn, 'pulse'); clearState(); });

        // --- Kaioken section listeners ---
        if (kaiokenCheckbox) { kaiokenCheckbox.addEventListener('change', () => { const isChecked = kaiokenCheckbox.checked; kaiokenDetails.classList.toggle('hidden', !isChecked); if (isChecked) { applyKaiokenStyle(); updateCurrentHealthDisplay(); } else { removeKaiokenStyle(); } updateEquationDisplay(); }); } // Equation might change if Kaioken affects multipliers indirectly? Re-evaluating is safe.
        if (maxHealthInput) { maxHealthInput.addEventListener('input', () => { updateCurrentHealthDisplay(); updateEquationDisplay(); }); maxHealthInput.addEventListener('change', () => { updateCurrentHealthDisplay(); updateEquationDisplay(); }); }
        if (kaiokenStrainInput) { kaiokenStrainInput.addEventListener('input', updateEquationDisplay); kaiokenStrainInput.addEventListener('change', updateEquationDisplay);}
        if (regenHealthBtn) { regenHealthBtn.addEventListener('click', () => { triggerAnimation(regenHealthBtn, 'pulse'); regenerateHealth(); }); }

        // --- Equation click listener ---
        if (equationDisplayEl) { equationDisplayEl.addEventListener('click', handleEquationClick); }

        // --- Reset Attack Count button listener ---
        if (resetAttackCountBtn) { resetAttackCountBtn.addEventListener('click', () => { triggerAnimation(resetAttackCountBtn, 'pulse'); attackCount = 0; updateStatsDisplay(); showMessage('Attack count reset.', 'info'); }); }

        // --- Attack Button Listeners ---
        if (superAttackBtn) superAttackBtn.addEventListener('click', handleAttackButtonClick);
        if (ultimateAttackBtn) ultimateAttackBtn.addEventListener('click', handleAttackButtonClick);

        // --- Tab Switching Button Listener ---
        if (showCharacterStatsBtn) { showCharacterStatsBtn.addEventListener('click', () => { console.log('SHOW CHAR STATS BUTTON CLICKED'); triggerAnimation(showCharacterStatsBtn, 'pulse'); if (characterStatsScreen && characterStatsScreen.classList.contains('hidden')) { showCharacterStatsView(); } else { showCalculatorView(); } }); }
       
            
        
        // Add listeners for new buff inputs (optional, can just read on button click)
        // Example: formEnableFormBuffCheckbox.addEventListener('change', someFunction);
        // Example: formFormBuffValueInput.addEventListener('input', someFunction);

        // Listener for the main "Add This Form" button
        if (addFormButton) {
            addFormButton.addEventListener('click', () => {
                triggerAnimation(addFormButton, 'pulse');
                const formName = formNameInput.value.trim();
                const energyType = formEnergyTypeSelect.value;
                const affectsResistances = formAffectsResistancesCheckbox.checked;

                if (!formName) { showMessage("Please enter a Form Name.", 'error'); return; }
                // Check for duplicate form names
                if (characterForms.some(form => form.name.toLowerCase() === formName.toLowerCase())) {
                     showMessage(`A form named "${formName}" already exists. Please use a unique name.`, 'error'); return;
                }

                // Read buff values when adding the form
                const enableFormBuff = formEnableFormBuffCheckbox.checked;
                const formBuffValue = safeParseFloat(formFormBuffValueInput.value, 0);
                const formBuffType = formFormBuffTypeSelect.value; // 'add' or 'multiply'
                const enablePoolBuff = formEnablePoolBuffCheckbox.checked;
                const poolBuffValue = safeParseFloat(formPoolBuffValueInput.value, 0);
                const poolBuffType = formPoolBuffTypeSelect.value; // 'add' or 'multiply'

                // Create the new form object, including buff properties
                const newForm = {
                    id: `form_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`, // Unique ID
                    name: formName,
                    formMultiplier: safeParseFloat(formFormMultiplierInput.value, 1),
                    poolMaxMultiplier: safeParseFloat(formPoolMaxMultiplierInput.value, 1),
                    energyType: energyType, // Can be 'None'
                    affectsResistances: affectsResistances,
                    acBonus: affectsResistances ? (safeParseFloat(formAcBonusInput.value, 0)) : 0,
                    trueResistanceBonus: affectsResistances ? (safeParseFloat(formTrueResistanceBonusInput.value, 0)) : 0,
                    // Add buff properties with defaults if needed
                    enableFormBuff: enableFormBuff || false,
                    formBuffValue: formBuffValue || 0,
                    formBuffType: formBuffType || 'add',
                    enablePoolBuff: enablePoolBuff || false,
                    poolBuffValue: poolBuffValue || 0,
                    poolBuffType: poolBuffType || 'add'
                };

                characterForms.push(newForm); // Add to our main forms array
                console.log("Form Added:", newForm);
                showMessage(`Form "${newForm.name}" added!`, 'success');

                renderFormList();           // Update the list in the stats panel
                renderActiveFormsSection(); // Update the list of checkboxes in main section

                // Reset Form Creator fields including buff inputs
                formNameInput.value = '';
                formEnergyTypeSelect.value = 'None';
                formFormMultiplierInput.value = 1;
                formPoolMaxMultiplierInput.value = 1;
                formAffectsResistancesCheckbox.checked = false;
                formResistanceBonusInputsDiv.classList.add('hidden');
                formAcBonusInput.value = 0;
                formTrueResistanceBonusInput.value = 0;
                formEnableFormBuffCheckbox.checked = false;
                formFormBuffValueInput.value = 0;
                formFormBuffTypeSelect.value = 'add';
                formEnablePoolBuffCheckbox.checked = false;
                formPoolBuffValueInput.value = 0;
                formPoolBuffTypeSelect.value = 'add';

                // Note: State is not auto-saved here. User uses Save button.
            });
        }

        // --- Form List Delete listener (Stats Panel - using delegation) ---
        if (formListContainer) {
            formListContainer.addEventListener('click', handleDeleteFormClick); // Uses the function defined elsewhere
        }

        // --- Active Forms Checkbox Listener ---
        // Attached directly to checkboxes in renderActiveFormsSection, no delegation needed here

        console.log("Event listeners setup complete.");
    } // <-- End of setupEventListeners function
                          // --- Form Creator Listeners ---
        if (formAffectsResistancesCheckbox) {
            formAffectsResistancesCheckbox.addEventListener('change', () => {
                 // Toggle visibility of AC/TR bonus inputs
                 formResistanceBonusInputsDiv.classList.toggle('hidden', !formAffectsResistancesCheckbox.checked);
                 // Reset values if checkbox is unchecked
                 if (!formAffectsResistancesCheckbox.checked) {
                     if(formAcBonusInput) formAcBonusInput.value = 0;
                     if(formTrueResistanceBonusInput) formTrueResistanceBonusInput.value = 0;
                 }
            });
        }
        // Add listeners for new buff inputs (optional, can just read on button click)
        // Example: formEnableFormBuffCheckbox.addEventListener('change', someFunction);
        // Example: formFormBuffValueInput.addEventListener('input', someFunction);

        // Listener for the main "Add This Form" button
        if (addFormButton) {
            addFormButton.addEventListener('click', () => {
                triggerAnimation(addFormButton, 'pulse');
                const formName = formNameInput.value.trim();
                const energyType = formEnergyTypeSelect.value;
                const affectsResistances = formAffectsResistancesCheckbox.checked;

                if (!formName) { showMessage("Please enter a Form Name.", 'error'); return; }
                // Check for duplicate form names
                if (characterForms.some(form => form.name.toLowerCase() === formName.toLowerCase())) {
                     showMessage(`A form named "${formName}" already exists. Please use a unique name.`, 'error'); return;
                }

                // Read buff values when adding the form
                const enableFormBuff = formEnableFormBuffCheckbox.checked;
                const formBuffValue = safeParseFloat(formFormBuffValueInput.value, 0);
                const formBuffType = formFormBuffTypeSelect.value; // 'add' or 'multiply'
                const enablePoolBuff = formEnablePoolBuffCheckbox.checked;
                const poolBuffValue = safeParseFloat(formPoolBuffValueInput.value, 0);
                const poolBuffType = formPoolBuffTypeSelect.value; // 'add' or 'multiply'

                // Create the new form object, including buff properties
                const newForm = {
                    id: `form_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`, // Unique ID
                    name: formName,
                    formMultiplier: safeParseFloat(formFormMultiplierInput.value, 1),
                    poolMaxMultiplier: safeParseFloat(formPoolMaxMultiplierInput.value, 1),
                    energyType: energyType, // Can be 'None'
                    affectsResistances: affectsResistances,
                    acBonus: affectsResistances ? (safeParseFloat(formAcBonusInput.value, 0)) : 0,
                    trueResistanceBonus: affectsResistances ? (safeParseFloat(formTrueResistanceBonusInput.value, 0)) : 0,
                    // Add buff properties with defaults if needed
                    enableFormBuff: enableFormBuff || false,
                    formBuffValue: formBuffValue || 0,
                    formBuffType: formBuffType || 'add',
                    enablePoolBuff: enablePoolBuff || false,
                    poolBuffValue: poolBuffValue || 0,
                    poolBuffType: poolBuffType || 'add'
                };

                characterForms.push(newForm); // Add to our main forms array
                console.log("Form Added:", newForm);
                showMessage(`Form "${newForm.name}" added!`, 'success');

                renderFormList();           // Update the list in the stats panel
                renderActiveFormsSection(); // Update the list of checkboxes in main section

                // Reset Form Creator fields including buff inputs
                formNameInput.value = '';
                formEnergyTypeSelect.value = 'None';
                formFormMultiplierInput.value = 1;
                formPoolMaxMultiplierInput.value = 1;
                formAffectsResistancesCheckbox.checked = false;
                formResistanceBonusInputsDiv.classList.add('hidden');
                formAcBonusInput.value = 0;
                formTrueResistanceBonusInput.value = 0;
                formEnableFormBuffCheckbox.checked = false;
                formFormBuffValueInput.value = 0;
                formFormBuffTypeSelect.value = 'add';
                formEnablePoolBuffCheckbox.checked = false;
                formPoolBuffValueInput.value = 0;
                formPoolBuffTypeSelect.value = 'add';

                // Note: State is not auto-saved here. User uses Save button.
            });
        }

        // --- Form List Delete listener (Stats Panel - using delegation) ---
        if (formListContainer) {
            formListContainer.addEventListener('click', handleDeleteFormClick); // Uses the function defined elsewhere
        }

        // --- Active Forms Checkbox Listener ---
        // Attached directly to checkboxes in renderActiveFormsSection, no delegation needed here

        console.log("Event listeners setup complete.");
        // --- Generate Elements from Templates ---
    function generateEnergySections() {
        if (!energyPoolTemplate || !energySliderTemplate || !energyPoolsContainer || !slidersGrid) {
            console.error("Required templates or containers not found! Cannot generate energy sections.");
            return;
        }
        energyPoolsContainer.innerHTML = '';
        slidersGrid.innerHTML = ''; // Clear sliders grid too

        ALL_ENERGY_TYPES.forEach(type => {
            const details = ENERGY_TYPE_DETAILS[type];
            if (!details) return;

            // --- Generate Energy Pool Section ---
            const poolClone = energyPoolTemplate.content.cloneNode(true);
            const poolDiv = poolClone.querySelector('.energy-pool');
            if (poolDiv) {
                poolDiv.id = `${type}-pool`;
                poolDiv.style.display = 'none'; // Start hidden
                poolDiv.classList.add(details.border, details.gradientTo);

                const titleEl = poolDiv.querySelector('.pool-title');
                if (titleEl) titleEl.textContent = `${details.name} Energy Pool`;

                // Setup inputs/spans with unique IDs and labels
                const setupElement = (selectorSuffix, isInput = true, focusClass = '') => {
                    const el = poolDiv.querySelector(`.${selectorSuffix}`);
                    const labelEl = poolDiv.querySelector(`.${selectorSuffix}-label`);
                    if (el) {
                        el.id = `${type}-${selectorSuffix}`;
                        if(labelEl) {
                            if(isInput) { labelEl.htmlFor = el.id; } else { labelEl.removeAttribute('for'); }
                        }
                        if (isInput && focusClass) el.classList.add(focusClass);
                    }
                };
                setupElement('base-max-energy', false);
                setupElement('max-multiplier', true, details.focusRing); // Pool Max Multiplier
                setupElement('total-energy', false);
                setupElement('current-energy', false);
                setupElement('damage-per-power', true, details.focusRing);
                setupElement('regen-percent', true, details.focusRing);
                // NOTE: Form select elements removed from template and this setup

                const regenBtn = poolDiv.querySelector('.regen-btn');
                if (regenBtn) { regenBtn.dataset.type = type; }

                energyPoolsContainer.appendChild(poolClone);
            } else {
                console.error(`Could not find .energy-pool in template clone for ${type}`);
            }

            // --- Generate Slider Section ---
            const sliderClone = energySliderTemplate.content.cloneNode(true);
            const sliderSection = sliderClone.querySelector('.energy-slider-section');
            if (sliderSection) {
                sliderSection.id = `${type}-slider-section`;
                sliderSection.dataset.type = type; // Link to energy type
                const sliderLabel = sliderSection.querySelector('.slider-label');
                if (sliderLabel) { sliderLabel.htmlFor = `${type}-energy-slider`; sliderLabel.textContent = `${details.name} Energy Used (%):`; }
                const energySlider = sliderSection.querySelector('.energy-slider');
                if (energySlider) { energySlider.id = `${type}-energy-slider`; energySlider.dataset.type = type; } // Link slider too
                const valueDisplay = sliderSection.querySelector('.energy-slider-value-display');
                if (valueDisplay) { valueDisplay.id = `${type}-slider-value-display`; }
                slidersGrid.appendChild(sliderClone);
            } else {
                console.error(`Could not find .energy-slider-section in template clone for ${type}`);
            }
        });
        console.log("Energy sections generated from templates.");
        // Speed slider is generated separately by generateSpeedSlider() when needed
    }
    ;
 
    // 1. Generate base DOM structure for energy sections (pools/sliders)
    generateEnergySections();
    // Note: Speed slider DOM is generated only *if needed* by updateSpeedSliderVisibility,
    // which is called later during initialization or state application.

    // 2. Attach all static and dynamic event listeners
    setupEventListeners();


    // --- Authentication State Change Listener ---
    // 3. Set up the Authentication Listener - This drives the rest of the initial state loading or default setup
    window.firebaseOnAuthStateChanged(window.firebaseAuth, async (user) => {
        const googleSignInBtn = document.getElementById('google-signin-btn');
        const signOutBtn = document.getElementById('sign-out-btn');
        const userInfoSpan = document.getElementById('user-info');

        if (user) {
            // User is signed in.
            currentUser = user;
            console.log("User signed in:", currentUser.displayName, currentUser.uid);

            // Update Auth UI
            if (userInfoSpan) userInfoSpan.textContent = `Signed in as: ${currentUser.displayName || currentUser.email || 'User'}`;
            if (googleSignInBtn) googleSignInBtn.classList.add('hidden');
            if (signOutBtn) signOutBtn.classList.remove('hidden');

            // Attempt to load state for THIS user
            console.log("Attempting to load state for user:", currentUser.uid);
            let stateLoaded = false;
            try {
                stateLoaded = await loadState(); // loadState calls applyState inside if successful
            } catch (loadError) {
                console.error("Error during state load after sign-in:", loadError);
                showMessage(`Failed to load saved state: ${loadError.message}`, 'error');
            }

            // Initialize UI based on loaded state or defaults
            if (!stateLoaded) {
                console.log("No valid state loaded from Firebase, initializing defaults for user.");
                 initializeDefaultState(); // Sets default values and updates UI
                 showMessage('Welcome! No saved state found, starting fresh.', 'info');
            } else {
                console.log("Saved state loaded from Firebase for user.");
                 // initializeLoadedStateUI(); // Most UI updates now happen within applyState
                 showMessage(`Welcome back, ${currentUser.displayName || 'User'}! State loaded.`, 'success');
            }

        } else {
            // User is signed out.
            currentUser = null;
            console.log("User is signed out.");

            // Update Auth UI
            if (userInfoSpan) userInfoSpan.textContent = 'Not signed in.';
            if (googleSignInBtn) googleSignInBtn.classList.remove('hidden');
            if (signOutBtn) signOutBtn.classList.add('hidden');

            // Initialize with defaults when user signs out
            console.log("Initializing default state as user is signed out.");
            initializeDefaultState(); // Resets everything to default values/UI

        }

         // Ensure the main form multiplier input is always readonly after any state change
         if (formMultiplierInput) {
             formMultiplierInput.readOnly = true;
             formMultiplierInput.classList.add('bg-gray-100', 'opacity-70', 'cursor-not-allowed');
             formMultiplierInput.title = "Combined multiplier from active forms"; // Update tooltip
         }
         console.log("Auth state change processed.");

    }); // End onAuthStateChanged

}); // --- END of firebaseReady listener ---
    </script>

</body>
</html>
