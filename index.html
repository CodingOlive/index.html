<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Energy Calculator - Multi-Slider (Refactored)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        // Tailwind Custom Configuration (from original)
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        // Energy types
                        ki: '#FF9800', nen: '#2196F3', chakra: '#9C27B0', magic: '#26a69a', cursed: '#dc2626',
                        reiatsu: '#475569', haki: '#1f2937', alchemy: '#f59e0b', nature: '#84cc16',
                        'ki-dark': '#e65100', 'nen-dark': '#0d47a1', 'chakra-dark': '#4a148c', 'magic-dark': '#00796b', 'cursed-dark': '#b91c1c',
                        'reiatsu-dark': '#1e293b', 'haki-dark': '#000000', 'alchemy-dark': '#b45309', 'nature-dark': '#4d7c0f',
                        // UI feedback
                        'success-light': '#e8f5e9', 'success': '#4CAF50', 'success-dark': '#2e7d32',
                        'error-light': '#ffebee', 'error': '#f44336', 'error-dark': '#c62828',
                        // Stats panel
                        'stats-border': '#60a5fa', 'stats-header': '#1e3a8a',
                        // Kaioken active state
                        'kaioken-border': '#f87171', 'kaioken-header': '#b91c1c', 'kaioken-focus': '#ef4444',
                        // Focus Rings per type
                        'magic-focus': '#26a69a', 'cursed-focus': '#dc2626', 'reiatsu-focus': '#475569',
                        'haki-focus': '#1f2937', 'alchemy-focus': '#f59e0b', 'nature-focus': '#84cc16',
                        // Specific focus rings matching base colors (if needed)
                        'ki-focus': '#FF9800', 'nen-focus': '#2196F3', 'chakra-focus': '#9C27B0'
                    },
                    animation: {
                        spin: 'spin 1s linear infinite', shake: 'shake 0.5s ease-in-out', fadeIn: 'fadeIn 0.3s ease-in', pulse: 'pulse 1.5s infinite',
                        'pulse-additive': 'pulse-additive 0.5s', 'pulse-multiplicative': 'pulse-multiplicative 0.5s', 'pulse-result': 'pulse-result 0.3s ease-in-out',
                        'flash-red': 'flash-red-bg 0.5s ease-out', 'flash-green': 'flash-green-bg 0.5s ease-out', 'kaioken-glow': 'kaioken-glow 1.5s infinite ease-in-out',
                        // Dynamic glow animations linked in JS map
                        'animate-pulse-glow-ki': 'pulse-glow-ki 1.5s infinite ease-in-out',
                        'animate-pulse-glow-nen': 'pulse-glow-nen 1.5s infinite ease-in-out',
                        'animate-pulse-glow-chakra': 'pulse-glow-chakra 1.5s infinite ease-in-out',
                        'animate-pulse-glow-magic': 'pulse-glow-magic 1.5s infinite ease-in-out',
                        'animate-pulse-glow-cursed': 'pulse-glow-cursed 1.5s infinite ease-in-out',
                        'animate-pulse-glow-reiatsu': 'pulse-glow-reiatsu 1.5s infinite ease-in-out',
                        'animate-pulse-glow-haki': 'pulse-glow-haki 1.5s infinite ease-in-out',
                        'animate-pulse-glow-alchemy': 'pulse-glow-alchemy 1.5s infinite ease-in-out',
                        'animate-pulse-glow-nature': 'pulse-glow-nature 1.5s infinite ease-in-out',
                    },
                    keyframes: {
                        spin: { '0%': { transform: 'rotate(0deg)' }, '100%': { transform: 'rotate(360deg)' }, },
                        shake: { '0%, 100%': { transform: 'translateX(0)' }, '25%, 75%': { transform: 'translateX(-5px)' }, '50%': { transform: 'translateX(5px)' }, },
                        fadeIn: { from: { opacity: 0, transform: 'translateY(10px)' }, to: { opacity: 1, transform: 'translateY(0)' }, },
                        pulse: { '0%, 100%': { transform: 'scale(1)' }, '50%': { transform: 'scale(1.05)' }, },
                        'pulse-additive': { '0%, 100%': { color: '#558b2f' }, '50%': { color: '#8BC34A' }, },
                        'pulse-multiplicative': { '0%, 100%': { color: '#e65100' }, '50%': { color: '#FF9800' }, },
                        'pulse-result': { '0%, 100%': { transform: 'scale(1)' }, '50%': { transform: 'scale(1.05)' }, },
                        'flash-red-bg': { '50%': { backgroundColor: '#ffebee', borderColor: '#f44336' } },
                        'flash-green-bg': { '50%': { backgroundColor: '#e8f5e9', borderColor: '#4CAF50' } },
                        'kaioken-glow': { '0%, 100%': { boxShadow: `0 0 10px #f8717180` }, '50%': { boxShadow: `0 0 20px #f87171CC` } },
                        // Dynamic Glow Keyframes (ensure names match animation names)
                         'pulse-glow-ki': { '0%, 100%': { boxShadow: `0 0 8px #FF980066` }, '50%': { boxShadow: `0 0 16px #FF9800B3` } },
                         'pulse-glow-nen': { '0%, 100%': { boxShadow: `0 0 8px #2196F366` }, '50%': { boxShadow: `0 0 16px #2196F3B3` } },
                         'pulse-glow-chakra': { '0%, 100%': { boxShadow: `0 0 8px #9C27B066` }, '50%': { boxShadow: `0 0 16px #9C27B0B3` } },
                         'pulse-glow-magic': { '0%, 100%': { boxShadow: `0 0 8px #26a69a66` }, '50%': { boxShadow: `0 0 16px #26a69aB3` } },
                         'pulse-glow-cursed': { '0%, 100%': { boxShadow: `0 0 8px #dc262666` }, '50%': { boxShadow: `0 0 16px #dc2626B3` } },
                         'pulse-glow-reiatsu': { '0%, 100%': { boxShadow: `0 0 8px #47556966` }, '50%': { boxShadow: `0 0 16px #475569B3` } },
                         'pulse-glow-haki': { '0%, 100%': { boxShadow: `0 0 8px #1f293766` }, '50%': { boxShadow: `0 0 16px #1f2937B3` } },
                         'pulse-glow-alchemy': { '0%, 100%': { boxShadow: `0 0 8px #f59e0b66` }, '50%': { boxShadow: `0 0 16px #f59e0bB3` } },
                         'pulse-glow-nature': { '0%, 100%': { boxShadow: `0 0 8px #84cc1666` }, '50%': { boxShadow: `0 0 16px #84cc16B3` } },
                    }
                }
            }
        }
    </script>
    <link rel="preconnect" href="https://rsms.me/">
    <link rel="stylesheet" href="https://rsms.me/inter/inter.css">
    <style>
        /* Base Styles */
        body { font-family: 'Inter', sans-serif; background-color: #f9f9f9; color: #333; }
        .energy-pool { @apply p-5 mb-5 rounded-lg shadow-sm border-l-4; transition: box-shadow 0.3s ease-in-out, opacity 0.3s ease-in-out; }

        /* Dynamic Pool Styles (applied by JS using ENERGY_TYPE_DETAILS map) */
        .energy-pool-ki { border-left-color: theme('colors.ki'); } .energy-pool-ki h3 { color: theme('colors.ki-dark'); }
        .energy-pool-nen { border-left-color: theme('colors.nen'); } .energy-pool-nen h3 { color: theme('colors.nen-dark'); }
        .energy-pool-chakra { border-left-color: theme('colors.chakra'); } .energy-pool-chakra h3 { color: theme('colors.chakra-dark'); }
        .energy-pool-magic { border-left-color: theme('colors.magic'); } .energy-pool-magic h3 { color: theme('colors.magic-dark'); }
        .energy-pool-cursed { border-left-color: theme('colors.cursed'); } .energy-pool-cursed h3 { color: theme('colors.cursed-dark'); }
        .energy-pool-reiatsu { border-left-color: theme('colors.reiatsu'); } .energy-pool-reiatsu h3 { color: theme('colors.reiatsu-dark'); }
        .energy-pool-haki { border-left-color: theme('colors.haki'); } .energy-pool-haki h3 { color: theme('colors.haki-dark'); }
        .energy-pool-alchemy { border-left-color: theme('colors.alchemy'); } .energy-pool-alchemy h3 { color: theme('colors.alchemy-dark'); }
        .energy-pool-nature { border-left-color: theme('colors.nature'); } .energy-pool-nature h3 { color: theme('colors.nature-dark'); }

        /* Base Slider Track */
        .energy-slider { @apply w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer; }
        /* Base Slider Thumb */
        .energy-slider::-webkit-slider-thumb { appearance: none; width: 20px; height: 20px; border-radius: 50%; cursor: pointer; box-shadow: 0 1px 3px rgba(0,0,0,0.2); transition: background 0.3s; border: none; }
        .energy-slider::-moz-range-thumb { width: 20px; height: 20px; border-radius: 50%; cursor: pointer; box-shadow: 0 1px 3px rgba(0,0,0,0.2); transition: background 0.3s; border: none; }

        /* Individual Slider Thumb Styles (Still needed as CSS targets generated IDs) */
        #ki-energy-slider::-webkit-slider-thumb { background: theme('colors.ki'); } #ki-energy-slider::-moz-range-thumb { background: theme('colors.ki'); }
        #nen-energy-slider::-webkit-slider-thumb { background: theme('colors.nen'); } #nen-energy-slider::-moz-range-thumb { background: theme('colors.nen'); }
        #chakra-energy-slider::-webkit-slider-thumb { background: theme('colors.chakra'); } #chakra-energy-slider::-moz-range-thumb { background: theme('colors.chakra'); }
        #magic-energy-slider::-webkit-slider-thumb { background: theme('colors.magic'); } #magic-energy-slider::-moz-range-thumb { background: theme('colors.magic'); }
        #cursed-energy-slider::-webkit-slider-thumb { background: theme('colors.cursed'); } #cursed-energy-slider::-moz-range-thumb { background: theme('colors.cursed'); }
        #reiatsu-energy-slider::-webkit-slider-thumb { background: theme('colors.reiatsu'); } #reiatsu-energy-slider::-moz-range-thumb { background: theme('colors.reiatsu'); }
        #haki-energy-slider::-webkit-slider-thumb { background: theme('colors.haki'); } #haki-energy-slider::-moz-range-thumb { background: theme('colors.haki'); }
        #alchemy-energy-slider::-webkit-slider-thumb { background: theme('colors.alchemy'); } #alchemy-energy-slider::-moz-range-thumb { background: theme('colors.alchemy'); }
        #nature-energy-slider::-webkit-slider-thumb { background: theme('colors.nature'); } #nature-energy-slider::-moz-range-thumb { background: theme('colors.nature'); }

        /* Optional: Darker hover for thumbs (can keep or remove) */
        #ki-energy-slider:hover::-webkit-slider-thumb { background: theme('colors.ki-dark'); } #ki-energy-slider:hover::-moz-range-thumb { background: theme('colors.ki-dark'); }
        #nen-energy-slider:hover::-webkit-slider-thumb { background: theme('colors.nen-dark'); } #nen-energy-slider:hover::-moz-range-thumb { background: theme('colors.nen-dark'); }
        /* ... add other hover styles if desired ... */

        /* Other Styles */
        .modifier-type-option.additive { border-color: theme('colors.success'); color: theme('colors.success-dark'); }
        .modifier-type-option.additive.active { background-color: theme('colors.success-light'); box-shadow: 0 1px 5px rgba(76, 175, 80, 0.3); animation: pulse-additive 0.5s; color: theme('colors.success'); }
        .modifier-type-option.multiplicative { border-color: theme('colors.ki'); color: theme('colors.ki-dark'); }
        .modifier-type-option.multiplicative.active { background-color: theme('colors.ki / 0.1'); box-shadow: 0 1px 5px rgba(255, 152, 0, 0.3); animation: pulse-multiplicative 0.5s; color: theme('colors.ki'); }
        .animate-pulse-result { animation: pulse-result 0.3s ease-in-out; }
        .animate-flash-red { animation: flash-red-bg 0.5s ease-out; }
        .animate-flash-green { animation: flash-green-bg 0.5s ease-out; }
        .animate-kaioken-glow { animation: kaioken-glow 1.5s infinite ease-in-out; }
        /* Static Glow classes (applied by JS when not pulsing) */
        .static-glow-ki { box-shadow: 0 0 10px #FF980080; } .static-glow-nen { box-shadow: 0 0 10px #2196F380; } .static-glow-chakra { box-shadow: 0 0 10px #9C27B080; } .static-glow-magic { box-shadow: 0 0 10px #26a69a80; } .static-glow-cursed { box-shadow: 0 0 10px #dc262680; } .static-glow-reiatsu { box-shadow: 0 0 10px #47556980; } .static-glow-haki { box-shadow: 0 0 10px #1f293780; } .static-glow-alchemy { box-shadow: 0 0 10px #f59e0b80; } .static-glow-nature { box-shadow: 0 0 10px #84cc1680; }

        .sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 0, 0); white-space: nowrap; border-width: 0; }
        .stats-panel { border-left-width: 4px; transition: border-color 0.3s ease-in-out, box-shadow 1.5s ease-in-out; }
        .stats-panel-header { transition: color 0.3s ease-in-out; }
        .lbl { @apply block mb-1 font-medium text-sm text-gray-600; }
        .inpt { @apply w-full p-2 border border-gray-300 rounded-md focus:ring-2 focus:border-transparent text-sm transition-colors duration-300; }
        .inpt-ro { @apply w-full p-2 border border-gray-300 rounded-md bg-gray-100 text-sm cursor-not-allowed transition-colors duration-300; }
        .regen-btn { @apply px-3 py-2 text-white rounded-md focus:outline-none focus:ring-2 focus:ring-offset-2 transition-all duration-150 ease-in-out text-sm font-semibold shadow-sm active:scale-95; }
        .save-load-btn { @apply px-3 py-1 text-sm text-white rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-offset-1 transition-all duration-150 ease-in-out active:scale-95; }

        /* Focus rings applied by JS */
        /* .focus:ring-ki, .focus:ring-nen, etc. are defined in tailwind.config */

    </style>
</head>
<body class="p-4 md:p-6">

    <div class="mb-4 flex gap-2">
        <button id="save-state-btn" class="save-load-btn bg-blue-500 hover:bg-blue-600 focus:ring-blue-400">Save State</button>
        <button id="load-state-btn" class="save-load-btn bg-gray-500 hover:bg-gray-600 focus:ring-gray-400">Load State</button>
        <button id="clear-state-btn" class="save-load-btn bg-red-500 hover:bg-red-600 focus:ring-red-400">Clear Saved</button>
    </div>
    <h1 class="text-3xl font-bold mb-6 text-center text-gray-800">Energy Calculator</h1>

    <div class="flex flex-col md:flex-row gap-6 max-w-7xl mx-auto">

        <div class="flex-grow md:w-3/4">

            <div id="message-area" class="mb-4 p-3 rounded-md text-sm hidden" role="alert"></div>

            <div class="energy-pool bg-white p-5 mb-5 rounded-lg shadow-sm border-l-4 border-gray-400">
                 <h3 class="text-xl font-semibold mb-4 flex items-center"> Damage Modifiers <span class="flex-grow h-px bg-gray-200 ml-3"></span> </h3>
                 <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                     <div><label for="base-damage" class="lbl">Base Damage:</label><input type="text" id="base-damage" placeholder="e.g., 100" aria-required="true" class="inpt focus:ring-success"></div>
                     <div><label for="attack-compression-points" class="lbl">Attack Compression Points:</label><input type="text" id="attack-compression-points" placeholder="e.g., 10" value="0" class="inpt focus:ring-red-500"></div>
                     <div><label for="base-multiplier" class="lbl">Base Multiplier:</label><input type="text" id="base-multiplier" placeholder="e.g., 1.5" value="1" class="inpt focus:ring-success"></div>
                     <div><label for="form-multiplier" class="lbl">Form Multiplier:</label><input type="text" id="form-multiplier" placeholder="e.g., 2" value="1" class="inpt focus:ring-success"></div>
                 </div>
                 <div id="dynamic-modifiers-container" class="mb-4"><h4 class="text-md font-semibold mb-2 text-gray-700">Additional Factors:</h4></div>
                 <button id="add-dynamic-box" aria-label="Add modifier factor" class="px-4 py-2 bg-chakra text-white rounded-md hover:bg-chakra-dark focus:outline-none focus:ring-2 focus:ring-chakra focus:ring-offset-2 transition-all duration-150 ease-in-out text-sm font-semibold shadow-sm active:scale-95"> Add Factor </button>
            </div>

            <div class="form-group mb-5">
                 <label for="energy-type" class="lbl">Energy Type:</label>
                 <select id="energy-type" aria-label="Select energy type" class="w-full p-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-success focus:border-transparent text-sm bg-white">
                     <option value="ki">Ki Energy</option> <option value="nen">Nen Energy</option> <option value="chakra">Chakra Energy</option> <option value="magic">Magic Energy</option> <option value="cursed">Cursed Energy</option> <option value="reiatsu">Reiatsu</option> <option value="haki">Haki</option> <option value="alchemy">Alchemy</option> <option value="nature">Nature Energy</option>
                 </select>
            </div>

            <div id="energy-pools-container" class="mb-5">
                </div>

            <div id="all-sliders-container" class="bg-white p-5 mb-5 rounded-lg shadow-sm">
                <h3 class="text-xl font-semibold mb-4 text-gray-700 border-b pb-2">Energy Usage Sliders</h3>
                <div id="sliders-grid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-x-6 gap-y-4">
                    </div>
            </div>

            <button id="calculate-btn" aria-label="Calculate final damage value" class="w-full px-4 py-3 bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 transition-all duration-150 ease-in-out text-lg font-semibold shadow-md mb-5 active:scale-95"> Calculate Damage </button>
            <div id="loading" class="loading text-center p-5 hidden">
                <div class="loading-spinner inline-block w-8 h-8 border-4 border-t-success border-gray-200 rounded-full animate-spin" aria-hidden="true"></div>
                <div class="loading-text mt-2 text-gray-600">Calculating...</div><span class="sr-only">Loading, please wait</span>
             </div>
            <div id="result" class="result bg-success-light p-5 rounded-lg border-l-4 border-success shadow-sm hidden animate-fadeIn" aria-live="polite">
                <div class="result-title text-lg font-semibold mb-2 text-success-dark">Calculated Damage:</div>
                <div id="result-value" class="result-value text-3xl font-bold mb-3 break-words">0</div>
                <div id="result-details" class="result-details text-sm text-gray-700 mt-3 border-t border-success/30 pt-3">
                    <p><strong>Total Energy Used:</strong> <span id="result-total-energy-used">0</span></p>
                    <p><strong>Total Extra Damage from Energy:</strong> <span id="result-total-extra-damage">0.00</span></p>
                    <hr class="my-2 border-success/20">
                    <p><strong>Scientific Notation:</strong> <span id="result-scientific">0</span></p>
                    <p><strong>In Words:</strong> <span id="result-words">Zero</span></p>
                </div>
             </div>

        </div><div id="stats-panel" class="stats-panel md:w-1/4 lg:w-1/5 p-5 bg-white rounded-lg shadow-sm self-start sticky top-6 border-stats-border">
             <h3 id="stats-panel-header" class="stats-panel-header text-xl font-semibold mb-4 flex items-center text-stats-header"> Stats <span class="flex-grow h-px bg-gray-200 ml-3"></span> </h3>
             <div class="space-y-3">
                 <p class="text-sm text-gray-600">Selected Current Energy: <span id="stat-current-energy" class="font-medium text-gray-800">0</span></p>
                 <hr class="border-gray-200">
                 <p class="text-sm text-gray-600">Total Damage Dealt: <span id="stat-total-damage" class="font-medium text-gray-800">0</span></p>
                 <p class="text-sm text-gray-600">Total Energy Spent: <span id="stat-total-energy-spent" class="font-medium text-gray-800">0</span></p>
                 <p class="text-sm text-gray-600">Highest Damage: <span id="stat-highest-damage" class="font-medium text-gray-800">0</span></p>
                 <p class="text-sm text-gray-600">Number of Attacks: <span id="stat-attack-count" class="font-medium text-gray-800">0</span></p>

                 <div id="kaioken-section" class="hidden pt-3 border-t border-gray-200">
                     <div class="flex items-center gap-2 mb-3">
                         <input type="checkbox" id="kaioken-checkbox" class="rounded border-gray-300 text-red-600 shadow-sm focus:ring-kaioken-focus">
                         <label for="kaioken-checkbox" class="text-sm font-medium text-kaioken-header">Kaioken?</label>
                     </div>
                     <div id="kaioken-details" class="hidden space-y-2">
                         <div class="flex items-center gap-2">
                             <div class="flex-grow">
                                 <label for="max-health" class="lbl">Max Health:</label>
                                 <input type="text" id="max-health" placeholder="e.g., 1000" value="1000" class="inpt focus:ring-kaioken-focus"> </div>
                             <button id="regen-health-btn" title="Regenerate Health to Max" class="px-2 py-1 text-xs bg-success hover:bg-success-dark text-white rounded-md focus:outline-none focus:ring-2 focus:ring-success focus:ring-offset-1 self-end mb-1 transition-transform active:scale-95">Regen Health</button>
                         </div>
                         <div><label for="kaioken-strain" class="lbl">Kaioken Strain (% Max HP):</label><input type="text" id="kaioken-strain" placeholder="e.g., 10" value="10" class="inpt focus:ring-kaioken-focus"></div> <div><label for="current-health" class="lbl">Current Health:</label><input type="text" id="current-health" readonly class="inpt-ro"></div>
                     </div>
                 </div>
             </div>
        </div> </div><template id="energy-pool-template">
        <div class="energy-pool bg-gradient-to-br from-white p-5 mb-5 rounded-lg shadow-sm border-l-4" style="display: none;"> <h3 class="text-xl font-semibold mb-4 flex items-center">
                <span class="pool-title">Energy Pool Title</span> <span class="flex-grow h-px bg-gray-200 ml-3"></span>
            </h3>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div><label class="lbl max-energy-label">Max Energy:</label><input type="text" value="1000" class="inpt max-energy"></div>
                <div><label class="lbl max-multiplier-label">Max Energy Multiplier:</label><input type="text" value="1" class="inpt max-multiplier"></div>
                <div><label class="lbl total-energy-label">Total Energy (Calculated):</label><input type="text" readonly class="inpt-ro total-energy"></div>
                <div><label class="lbl current-energy-label">Current Energy:</label><input type="text" readonly class="inpt-ro current-energy"></div>
                <div><label class="lbl damage-per-power-label">Damage per Energy Point:</label><input type="text" value="1" class="inpt damage-per-power"></div>
                <div>
                    <label class="lbl regen-percent-label">Regeneration Rate (% of Max):</label>
                    <div class="flex items-center gap-2">
                        <input type="text" placeholder="e.g., 10" class="flex-grow p-2 border border-gray-300 rounded-md focus:ring-2 focus:border-transparent text-sm regen-percent">
                        <button class="regen-btn bg-success hover:bg-success-dark focus:ring-success px-3 py-2 text-white rounded-md focus:outline-none focus:ring-2 focus:ring-offset-2 transition-all duration-150 ease-in-out text-sm font-semibold shadow-sm active:scale-95">Regen</button>
                    </div>
                </div>
            </div>
        </div>
    </template>

    <template id="energy-slider-template">
         <div class="energy-slider-section hidden"> <label class="lbl text-sm slider-label">Energy Used (%):</label> <input type="range" class="energy-slider w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer" min="0" max="100" value="0"> <div class="flex justify-between text-xs text-gray-500 px-1"><span>0%</span><span>50%</span><span>100%</span></div>
             <div class="energy-slider-value-display text-xs text-center bg-gray-100 text-gray-700 p-1 rounded-md">0% (Energy: 0, Damage: 0.00)</div>
         </div>
    </template>


    <script>
        // --- DOM Element References ---
        const energyTypeSelect = document.getElementById('energy-type');
        // Containers for generated content
        const energyPoolsContainer = document.getElementById('energy-pools-container');
        const slidersGrid = document.getElementById('sliders-grid');
        // Templates
        const energyPoolTemplate = document.getElementById('energy-pool-template');
        const energySliderTemplate = document.getElementById('energy-slider-template');

        // Other UI elements
        const calculateBtn = document.getElementById('calculate-btn');
        const resultDiv = document.getElementById('result');
        const resultValueEl = document.getElementById('result-value');
        const resultTotalEnergyUsedEl = document.getElementById('result-total-energy-used');
        const resultTotalExtraDamageEl = document.getElementById('result-total-extra-damage');
        const resultScientificEl = document.getElementById('result-scientific');
        const resultWordsEl = document.getElementById('result-words');
        const loadingDiv = document.getElementById('loading');
        const messageArea = document.getElementById('message-area');
        const dynamicModifiersContainer = document.getElementById('dynamic-modifiers-container');
        const addDynamicBoxBtn = document.getElementById('add-dynamic-box');
        const baseDamageInput = document.getElementById('base-damage');
        const baseMultiplierInput = document.getElementById('base-multiplier');
        const formMultiplierInput = document.getElementById('form-multiplier');
        const attackCompressionPointsInput = document.getElementById('attack-compression-points');
        const statsPanel = document.getElementById('stats-panel');
        const statsPanelHeader = document.getElementById('stats-panel-header');
        const statCurrentEnergyEl = document.getElementById('stat-current-energy');
        const statTotalDamageEl = document.getElementById('stat-total-damage');
        const statTotalEnergySpentEl = document.getElementById('stat-total-energy-spent');
        const statAttackCountEl = document.getElementById('stat-attack-count');
        const statHighestDamageEl = document.getElementById('stat-highest-damage');
        const kaiokenSection = document.getElementById('kaioken-section');
        const kaiokenCheckbox = document.getElementById('kaioken-checkbox');
        const kaiokenDetails = document.getElementById('kaioken-details');
        const maxHealthInput = document.getElementById('max-health');
        const kaiokenStrainInput = document.getElementById('kaioken-strain');
        const currentHealthEl = document.getElementById('current-health');
        const regenHealthBtn = document.getElementById('regen-health-btn');
        const saveBtn = document.getElementById('save-state-btn');
        const loadBtn = document.getElementById('load-state-btn');
        const clearBtn = document.getElementById('clear-state-btn');

        // --- Global State & Constants ---
        let totalDamageDealt = 0, totalEnergySpent = 0, attackCount = 0, highestDamage = 0;
        const LOCAL_STORAGE_KEY = 'energyCalculatorState_v1';
        let poolAnimationTimeoutId = null;
        const ALL_ENERGY_TYPES = ['ki', 'nen', 'chakra', 'magic', 'cursed', 'reiatsu', 'haki', 'alchemy', 'nature'];
        let dynamicModifierCount = 0;

        // Map for easy lookup of display names and styles defined in Tailwind config
        // Ensure focus ring class names match your Tailwind config and usage (.e.g., 'focus:ring-ki' vs 'focus:ring-ki-focus')
        const ENERGY_TYPE_DETAILS = {
            ki:      { name: 'Ki',      color: 'ki',      colorDark: 'ki-dark',      gradientTo: 'to-orange-100', focusRing: 'focus:ring-ki',      staticGlow: 'static-glow-ki',      pulseGlow: 'animate-pulse-glow-ki',      border: 'border-l-ki' },
            nen:     { name: 'Nen',     color: 'nen',     colorDark: 'nen-dark',     gradientTo: 'to-blue-100',   focusRing: 'focus:ring-nen',     staticGlow: 'static-glow-nen',     pulseGlow: 'animate-pulse-glow-nen',     border: 'border-l-nen' },
            chakra:  { name: 'Chakra',  color: 'chakra',  colorDark: 'chakra-dark',  gradientTo: 'to-purple-100', focusRing: 'focus:ring-chakra',  staticGlow: 'static-glow-chakra',  pulseGlow: 'animate-pulse-glow-chakra',  border: 'border-l-chakra' },
            magic:   { name: 'Magic',   color: 'magic',   colorDark: 'magic-dark',   gradientTo: 'to-teal-100',   focusRing: 'focus:ring-magic-focus',   staticGlow: 'static-glow-magic',   pulseGlow: 'animate-pulse-glow-magic',   border: 'border-l-magic' },
            cursed:  { name: 'Cursed',  color: 'cursed',  colorDark: 'cursed-dark',  gradientTo: 'to-red-100',    focusRing: 'focus:ring-cursed-focus',  staticGlow: 'static-glow-cursed',  pulseGlow: 'animate-pulse-glow-cursed',  border: 'border-l-cursed' },
            reiatsu: { name: 'Reiatsu', color: 'reiatsu', colorDark: 'reiatsu-dark', gradientTo: 'to-slate-100',  focusRing: 'focus:ring-reiatsu-focus', staticGlow: 'static-glow-reiatsu', pulseGlow: 'animate-pulse-glow-reiatsu', border: 'border-l-reiatsu' },
            haki:    { name: 'Haki',    color: 'haki',    colorDark: 'haki-dark',    gradientTo: 'to-gray-100',   focusRing: 'focus:ring-haki-focus',    staticGlow: 'static-glow-haki',    pulseGlow: 'animate-pulse-glow-haki',    border: 'border-l-haki' },
            alchemy: { name: 'Alchemy', color: 'alchemy', colorDark: 'alchemy-dark', gradientTo: 'to-amber-100',  focusRing: 'focus:ring-alchemy-focus', staticGlow: 'static-glow-alchemy', pulseGlow: 'animate-pulse-glow-alchemy', border: 'border-l-alchemy' },
            nature:  { name: 'Nature',  color: 'nature',  colorDark: 'nature-dark',  gradientTo: 'to-lime-100',   focusRing: 'focus:ring-nature-focus',  staticGlow: 'static-glow-nature',  pulseGlow: 'animate-pulse-glow-nature',  border: 'border-l-nature' },
        };

        // --- Utility Functions ---
        function safeParseFloat(value, defaultValue = 0) { if (typeof value !== 'string' && typeof value !== 'number') return defaultValue; const num = parseFloat(String(value).replace(/,/g, '')); return isNaN(num) ? defaultValue : num; }
        function formatNumber(num) { if (typeof num !== 'number' || isNaN(num)) return '0'; try { const options = { maximumFractionDigits: 2 }; return num.toLocaleString('en-US', options); } catch (e) { console.warn("Format err:", e); return num.toExponential(2); } }
        function showMessage(text, type = 'info') { messageArea.textContent = text; messageArea.className = 'mb-4 p-3 rounded-md text-sm border'; messageArea.classList.remove('hidden'); switch (type) { case 'error': messageArea.classList.add('bg-error-light', 'text-error-dark', 'border-error'); break; case 'success': messageArea.classList.add('bg-success-light', 'text-success-dark', 'border-success'); break; default: messageArea.classList.add('bg-blue-100', 'text-blue-800', 'border-blue-300'); } setTimeout(() => { messageArea.classList.add('hidden'); }, 5000); }
        function showLoading(isLoading) { loadingDiv.classList.toggle('hidden', !isLoading); if(isLoading) resultDiv.classList.add('hidden'); calculateBtn.disabled = isLoading; calculateBtn.classList.toggle('opacity-50', isLoading); calculateBtn.classList.toggle('cursor-not-allowed', isLoading); }
        function triggerAnimation(element, animationClass, duration = 500) { if (!element) return; element.classList.remove(animationClass); void element.offsetWidth; element.classList.add(animationClass); setTimeout(() => { element.classList.remove(animationClass); }, duration); }


        // --- Energy Pool Logic ---
        function getEnergyElements(type) {
            if (!ALL_ENERGY_TYPES.includes(type)) { console.error("Invalid type:", type); return null; }
            return {
                poolDiv: document.getElementById(`${type}-pool`),
                maxEnergyEl: document.getElementById(`${type}-max-energy`),
                maxMultiplierEl: document.getElementById(`${type}-max-multiplier`),
                totalEnergyEl: document.getElementById(`${type}-total-energy`),
                currentEnergyEl: document.getElementById(`${type}-current-energy`),
                damagePerPowerEl: document.getElementById(`${type}-damage-per-power`),
                regenPercentEl: document.getElementById(`${type}-regen-percent`),
                sliderSection: document.getElementById(`${type}-slider-section`),
                energySlider: document.getElementById(`${type}-energy-slider`),
                sliderValueDisplay: document.getElementById(`${type}-slider-value-display`)
            };
        }

         function updateSliderVisibility(type) {
             const els = getEnergyElements(type);
             if (els?.totalEnergyEl && els.sliderSection) {
                 const totalEnergy = safeParseFloat(els.totalEnergyEl.value.replace(/,/g, ''), 0);
                 const shouldShow = totalEnergy > 0;
                 els.sliderSection.classList.toggle('hidden', !shouldShow);
                 if (!shouldShow && els.energySlider) {
                     els.energySlider.value = 0;
                     updateSingleSliderDisplay(type);
                 }
             }
         }
         function calculateAndResetEnergy(type) {
             const els = getEnergyElements(type);
             if (!els?.maxEnergyEl || !els?.maxMultiplierEl || !els?.totalEnergyEl || !els?.currentEnergyEl) { console.error(`Elements missing for reset: ${type}`); return 0; }
             const maxEnergy = safeParseFloat(els.maxEnergyEl.value, 0);
             const multiplier = safeParseFloat(els.maxMultiplierEl.value, 1);
             const totalEnergy = maxEnergy * multiplier;
             els.totalEnergyEl.value = formatNumber(totalEnergy);
             els.currentEnergyEl.value = formatNumber(totalEnergy);
             updateSliderVisibility(type);
             updateSingleSliderDisplay(type);
             return totalEnergy;
         }
         function regenerateEnergy(type) {
             const els = getEnergyElements(type);
             if (!els?.totalEnergyEl || !els?.currentEnergyEl || !els?.regenPercentEl) { console.error(`Elements missing for regen: ${type}`); return; }
             const totalEnergy = safeParseFloat(els.totalEnergyEl.value.replace(/,/g, ''), 0);
             let currentEnergy = safeParseFloat(els.currentEnergyEl.value.replace(/,/g, ''), 0);
             const regenPercent = safeParseFloat(els.regenPercentEl.value, 0);
             if (totalEnergy <= 0) { showMessage('Max Energy must be positive to regenerate.', 'error'); return; }
             if (regenPercent <= 0) { showMessage('Regen Rate must be positive.', 'error'); return; }
             const regenAmount = totalEnergy * (regenPercent / 100);
             let newEnergy = Math.min(currentEnergy + regenAmount, totalEnergy);
             els.currentEnergyEl.value = formatNumber(newEnergy);
             showMessage(`${formatNumber(regenAmount)} ${type} regenerated. Current: ${formatNumber(newEnergy)}`, 'success');
             triggerAnimation(els.currentEnergyEl, 'animate-flash-green');
             updateSingleSliderDisplay(type);
             updateStatsDisplay();
         }


        // --- Kaioken Styling ---
        function applyKaiokenStyle() { if (!statsPanel || !statsPanelHeader) return; statsPanel.classList.remove('border-stats-border'); statsPanel.classList.add('border-kaioken-border', 'animate-kaioken-glow'); statsPanelHeader.classList.remove('text-stats-header'); statsPanelHeader.classList.add('text-kaioken-header'); }
        function removeKaiokenStyle() { if (!statsPanel || !statsPanelHeader) return; statsPanel.classList.add('border-stats-border'); statsPanel.classList.remove('border-kaioken-border', 'animate-kaioken-glow'); statsPanelHeader.classList.add('text-stats-header'); statsPanelHeader.classList.remove('text-kaioken-header'); }

        // --- Health Update ---
         function updateCurrentHealthDisplay() { if (energyTypeSelect.value === 'ki' && kaiokenCheckbox.checked && maxHealthInput && currentHealthEl) { const maxHealth = safeParseFloat(maxHealthInput.value, 0); let currentHealth = safeParseFloat(currentHealthEl.value.replace(/,/g,''), -1); if (currentHealth === -1 || currentHealth > maxHealth || currentHealthEl.value === '') { currentHealthEl.value = formatNumber(maxHealth); } } else if (currentHealthEl && maxHealthInput && currentHealthEl.value === '') { currentHealthEl.value = formatNumber(safeParseFloat(maxHealthInput.value, 0)); } }
         function regenerateHealth() { if (!maxHealthInput || !currentHealthEl) { console.error("Health elements missing."); return; } const maxHealth = safeParseFloat(maxHealthInput.value, 0); currentHealthEl.value = formatNumber(maxHealth); showMessage('Health fully regenerated!', 'success'); triggerAnimation(currentHealthEl, 'animate-flash-green'); }


        // --- Show/Hide Logic & Pool Animation ---
        function showSelectedEnergyPool() {
            const selectedType = energyTypeSelect.value;
            const details = ENERGY_TYPE_DETAILS[selectedType];
            let newlyVisiblePool = null;

            if (poolAnimationTimeoutId) { clearTimeout(poolAnimationTimeoutId); poolAnimationTimeoutId = null; }

            // Hide all pools, remove glow/pulse classes
            ALL_ENERGY_TYPES.forEach(type => {
                const els = getEnergyElements(type);
                const typeDetails = ENERGY_TYPE_DETAILS[type];
                if (els?.poolDiv && typeDetails) {
                    els.poolDiv.classList.remove(typeDetails.pulseGlow, typeDetails.staticGlow);
                    if (type !== selectedType) { els.poolDiv.style.display = 'none'; }
                }
            });

            // Find the pool to show
            const poolToShowEls = getEnergyElements(selectedType);
            if (poolToShowEls?.poolDiv && details) {
                poolToShowEls.poolDiv.style.display = 'block';
                newlyVisiblePool = poolToShowEls.poolDiv;
                poolToShowEls.poolDiv.classList.add(details.pulseGlow); // Apply pulse

                poolAnimationTimeoutId = setTimeout(() => { // Switch to static glow
                    const currentSelectedType = energyTypeSelect.value;
                    const stillSelectedPoolEls = getEnergyElements(currentSelectedType);
                    const stillSelectedDetails = ENERGY_TYPE_DETAILS[currentSelectedType];
                    if (stillSelectedPoolEls?.poolDiv && stillSelectedDetails && currentSelectedType === selectedType) {
                        stillSelectedPoolEls.poolDiv.classList.remove(stillSelectedDetails.pulseGlow);
                        stillSelectedPoolEls.poolDiv.classList.add(stillSelectedDetails.staticGlow);
                    }
                    poolAnimationTimeoutId = null;
                }, 5000);
            }

            // Show/Hide Kaioken section
             if (kaiokenSection) { if (selectedType === 'ki') { kaiokenSection.classList.remove('hidden'); if (kaiokenCheckbox.checked) { kaiokenDetails.classList.remove('hidden'); updateCurrentHealthDisplay(); } } else { kaiokenSection.classList.add('hidden'); if (kaiokenCheckbox.checked) { kaiokenCheckbox.checked = false; kaiokenDetails.classList.add('hidden'); removeKaiokenStyle(); } } }

            // --- Persist Current Energy Logic ---
            const els = getEnergyElements(selectedType);
            if (els?.maxEnergyEl && els?.maxMultiplierEl && els?.totalEnergyEl && els?.currentEnergyEl) {
                const maxEnergy = safeParseFloat(els.maxEnergyEl.value, 0);
                const multiplier = safeParseFloat(els.maxMultiplierEl.value, 1);
                const totalEnergy = maxEnergy * multiplier;
                els.totalEnergyEl.value = formatNumber(totalEnergy);
                let currentEnergy = safeParseFloat(els.currentEnergyEl.value.replace(/,/g, ''), -1);
                if (currentEnergy === -1 || currentEnergy > totalEnergy || els.currentEnergyEl.value.trim() === '') {
                    els.currentEnergyEl.value = formatNumber(totalEnergy);
                }
                updateSliderVisibility(selectedType);
                updateSingleSliderDisplay(selectedType);
            }

            updateStatsDisplay();
        }


        // --- Dynamic Modifiers Logic ---
        function addDynamicModifier(modifierData = null) { dynamicModifierCount++; const modifierId = `dynamic-modifier-${dynamicModifierCount}`; const newModifierDiv = document.createElement('div'); const initialType = modifierData?.type || 'additive'; const initialValue = modifierData?.value || '0'; const initialName = modifierData?.name || ''; const isActiveAdditive = initialType === 'additive'; const boxClasses = `dynamic-box p-4 mt-3 border rounded-md border-l-4 relative transition-all duration-300 ease-in-out animate-fadeIn ${isActiveAdditive ? 'additive bg-success-light border-success' : 'multiplicative bg-ki/10 border-ki'}`; newModifierDiv.className = boxClasses; newModifierDiv.id = modifierId; newModifierDiv.innerHTML = ` <div class="absolute top-2 right-2"><button class="remove-dynamic-box bg-error text-white rounded-md shadow-sm w-6 h-6 flex items-center justify-center text-xs hover:bg-error-dark focus:outline-none focus:ring-2 focus:ring-error focus:ring-offset-1 transition-transform active:scale-95" aria-label="Remove this modifier" data-target="${modifierId}">×</button></div><div class="modifier-type-selector flex gap-2 mb-3 border-b pb-2"><div class="modifier-type-option additive ${isActiveAdditive ? 'active' : ''} flex-1 p-2 text-center border rounded-md cursor-pointer transition-all duration-300 ease-in-out text-sm" data-value="additive" tabindex="0" role="radio" aria-checked="${isActiveAdditive}"><input type="radio" name="modifier-type-${modifierId}" value="additive" class="sr-only" ${isActiveAdditive ? 'checked' : ''}> Additive (+)</div><div class="modifier-type-option multiplicative ${!isActiveAdditive ? 'active' : ''} flex-1 p-2 text-center border rounded-md cursor-pointer transition-all duration-300 ease-in-out text-sm" data-value="multiplicative" tabindex="0" role="radio" aria-checked="${!isActiveAdditive}"><input type="radio" name="modifier-type-${modifierId}" value="multiplicative" class="sr-only" ${!isActiveAdditive ? 'checked' : ''}> Multiplier (×)</div></div><div class="grid grid-cols-1 sm:grid-cols-2 gap-3"><div><label for="modifier-name-${modifierId}" class="lbl">Modifier Name:</label><input type="text" id="modifier-name-${modifierId}" placeholder="e.g., Buff" value="${initialName}" class="modifier-name-input w-full p-1.5 border border-gray-300 rounded-md focus:ring-1 focus:ring-success focus:border-transparent text-sm"></div><div><label for="modifier-value-${modifierId}" class="lbl">Value:</label><input type="text" id="modifier-value-${modifierId}" placeholder="e.g., 50 or 1.2" value="${initialValue}" class="modifier-value-input w-full p-1.5 border border-gray-300 rounded-md focus:ring-1 focus:ring-success focus:border-transparent text-sm"></div></div>`; dynamicModifiersContainer.appendChild(newModifierDiv); addListenersToModifierBox(newModifierDiv); }
        function addListenersToModifierBox(modifierDiv) { modifierDiv.querySelector('.remove-dynamic-box').addEventListener('click', function() { document.getElementById(this.dataset.target)?.remove(); }); modifierDiv.querySelectorAll('.modifier-type-option').forEach(option => { option.addEventListener('click', function() { const box = this.closest('.dynamic-box'); const value = this.dataset.value; box.querySelectorAll('input[type="radio"]').forEach(radio => radio.checked = (radio.value === value)); box.querySelectorAll('.modifier-type-option').forEach(opt => { const isActive = opt.dataset.value === value; opt.classList.toggle('active', isActive); opt.setAttribute('aria-checked', isActive); }); box.classList.remove('additive', 'multiplicative', 'bg-success-light', 'border-success', 'bg-ki/10', 'border-ki'); box.classList.add(value === 'additive' ? 'additive' : 'multiplicative'); box.classList.add(value === 'additive' ? 'bg-success-light' : 'bg-ki/10'); box.classList.add(value === 'additive' ? 'border-success' : 'border-ki'); }); option.addEventListener('keydown', function(e) { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); this.click(); } }); }); }


        // --- Stats Update Logic ---
         function updateStatsDisplay() { if (statTotalDamageEl) statTotalDamageEl.textContent = formatNumber(totalDamageDealt); if (statTotalEnergySpentEl) statTotalEnergySpentEl.textContent = formatNumber(totalEnergySpent); if (statAttackCountEl) statAttackCountEl.textContent = attackCount.toLocaleString(); if (statHighestDamageEl) statHighestDamageEl.textContent = formatNumber(highestDamage); const selectedType = energyTypeSelect.value; const els = getEnergyElements(selectedType); if (statCurrentEnergyEl && els?.currentEnergyEl) { statCurrentEnergyEl.textContent = els.currentEnergyEl.value || '0'; } else if (statCurrentEnergyEl) { statCurrentEnergyEl.textContent = 'N/A'; } }

        // --- Calculation Logic ---
         function updateSingleSliderDisplay(type) { const els = getEnergyElements(type); if (!els?.energySlider || !els?.sliderValueDisplay || !els?.currentEnergyEl || !els?.damagePerPowerEl) { return; } const sliderPercent = els.energySlider.value; const currentEnergy = safeParseFloat(els.currentEnergyEl.value.replace(/,/g, ''), 0); const damagePerPower = safeParseFloat(els.damagePerPowerEl.value, 1); const potentialEnergyUsed = currentEnergy * (sliderPercent / 100); const actualEnergyUsed = Math.min(potentialEnergyUsed, currentEnergy); const extraDamage = actualEnergyUsed * damagePerPower; els.sliderValueDisplay.textContent = `${sliderPercent}% (Use: ${formatNumber(actualEnergyUsed)}, Damage: ${formatNumber(extraDamage)})`; }
         function performCalculation() {
             showLoading(true);
             setTimeout(() => {
                 try {
                     const baseDamage = safeParseFloat(baseDamageInput.value, 0);
                     const compressionPoints = safeParseFloat(attackCompressionPointsInput.value, 0);
                     const baseMultiplier = safeParseFloat(baseMultiplierInput.value, 1);
                     const formMultiplier = safeParseFloat(formMultiplierInput.value, 1);
                     const energyType = energyTypeSelect.value;

                     let effectiveBaseMultiplier = baseMultiplier;
                      if (compressionPoints > 0) {
                          // Example: Each point adds 5% multiplier, every 10 points adds an extra 10%
                          effectiveBaseMultiplier *= (1 + (compressionPoints * 0.05) + (Math.floor(compressionPoints / 10) * 0.1));
                      }
                      let finalDamage = baseDamage * effectiveBaseMultiplier * formMultiplier;

                     document.querySelectorAll('#dynamic-modifiers-container .dynamic-box').forEach(modifierDiv => {
                         const valueInput = modifierDiv.querySelector('.modifier-value-input');
                         const typeOption = modifierDiv.querySelector('.modifier-type-option.active');
                         if (valueInput && typeOption) {
                             const modifierValue = safeParseFloat(valueInput.value, 0);
                             const modifierType = typeOption.dataset.value;
                             if (modifierType === 'additive') { finalDamage += modifierValue; }
                             else if (modifierType === 'multiplicative') { finalDamage *= ((modifierValue === 0) ? 1 : modifierValue); }
                         }
                     });

                     let totalEnergyUsedFromSliders = 0;
                     let totalExtraDamageFromEnergy = 0;
                     ALL_ENERGY_TYPES.forEach(type => {
                         const els = getEnergyElements(type);
                         if (els?.energySlider && els.currentEnergyEl && els.damagePerPowerEl) {
                             const sliderPercent = safeParseFloat(els.energySlider.value, 0);
                             if (sliderPercent > 0) {
                                 const currentEnergy = safeParseFloat(els.currentEnergyEl.value.replace(/,/g, ''), 0);
                                 const damagePerPower = safeParseFloat(els.damagePerPowerEl.value, 1);
                                 const energyUsedThisType = currentEnergy * (sliderPercent / 100);
                                 const actualEnergyUsed = Math.min(energyUsedThisType, currentEnergy);
                                 const extraDamageThisType = actualEnergyUsed * damagePerPower;
                                 totalEnergyUsedFromSliders += actualEnergyUsed;
                                 totalExtraDamageFromEnergy += extraDamageThisType;
                                 let newCurrentEnergyThisType = Math.max(0, currentEnergy - actualEnergyUsed);
                                 els.currentEnergyEl.value = formatNumber(newCurrentEnergyThisType);
                                 if (newCurrentEnergyThisType < currentEnergy) { triggerAnimation(els.currentEnergyEl, 'animate-flash-red'); }
                                 updateSingleSliderDisplay(type);
                             }
                         }
                     });
                     finalDamage += totalExtraDamageFromEnergy;

                     let healthDepleted = false;
                     if (energyType === 'ki' && kaiokenCheckbox.checked) {
                         const currentHealthVal = safeParseFloat(currentHealthEl.value.replace(/,/g, ''), 0);
                         if (currentHealthVal > 0) {
                             const maxHealth = safeParseFloat(maxHealthInput.value, 0);
                             const kaiokenStrainPercent = safeParseFloat(kaiokenStrainInput.value, 0);
                             if (maxHealth > 0 && kaiokenStrainPercent > 0) {
                                 const strainCost = maxHealth * (kaiokenStrainPercent / 100);
                                 let newHealth = Math.max(0, currentHealthVal - strainCost);
                                 currentHealthEl.value = formatNumber(newHealth);
                                 if (newHealth < currentHealthVal) { triggerAnimation(currentHealthEl, 'animate-flash-red'); }
                                 if (newHealth === 0) { healthDepleted = true; }
                             }
                         } else { /* Health already 0 */ }
                     }

                     // Update Stats
                     totalDamageDealt += finalDamage;
                     totalEnergySpent += totalEnergyUsedFromSliders;
                     attackCount++;
                     if (finalDamage > highestDamage) { highestDamage = finalDamage; }
                     updateStatsDisplay();

                     // Display Results
                     resultValueEl.textContent = formatNumber(finalDamage);
                     triggerAnimation(resultValueEl, 'animate-pulse-result', 300);
                     resultTotalEnergyUsedEl.textContent = formatNumber(totalEnergyUsedFromSliders);
                     resultTotalExtraDamageEl.textContent = formatNumber(totalExtraDamageFromEnergy);
                     displayAllFormats(finalDamage);
                     resultDiv.classList.remove('hidden', 'bg-error-light', 'border-error', 'text-error-dark');
                     resultDiv.classList.add('bg-success-light', 'border-success', 'text-success-dark');
                     resultDiv.querySelector('.result-title').className = 'result-title text-lg font-semibold mb-2 text-success-dark';
                     let successMsg = 'Calculation successful!';
                     if (healthDepleted) { successMsg += ' Warning: Health depleted by Kaioken strain!'; }
                     showMessage(successMsg, healthDepleted ? 'error' : 'success');

                 } catch (error) {
                     console.error("Calculation Error:", error);
                     resultValueEl.textContent = 'Error'; resultTotalEnergyUsedEl.textContent = 'N/A'; resultTotalExtraDamageEl.textContent = 'N/A'; resultScientificEl.textContent = 'N/A'; resultWordsEl.textContent = 'Error';
                     resultDiv.classList.remove('hidden', 'bg-success-light', 'border-success', 'text-success-dark'); resultDiv.classList.add('bg-error-light', 'border-error', 'text-error-dark'); resultDiv.querySelector('.result-title').className = 'result-title text-lg font-semibold mb-2 text-error-dark';
                     showMessage(`Calculation failed: ${error.message || 'Unknown error'}`, 'error');
                 } finally {
                     showLoading(false);
                 }
             }, 50);
         }


        // --- Number Formatting ---
         function displayAllFormats(damage) { try { resultScientificEl.textContent = damage.toExponential(2).replace(/e\+?(-?)/, ' x 10^$1'); } catch (e) { resultScientificEl.textContent = "Invalid"; console.error("Scientific notation error:", e); } try { resultWordsEl.textContent = convertNumberToWords(damage); } catch (e) { resultWordsEl.textContent = "Error: " + e.message; console.error("Number to words error:", e); } }
         function convertNumberToWords(number) { const units = ['', 'One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Eleven', 'Twelve', 'Thirteen', 'Fourteen', 'Fifteen', 'Sixteen', 'Seventeen', 'Eighteen', 'Nineteen']; const tens = ['', '', 'Twenty', 'Thirty', 'Forty', 'Fifty', 'Sixty', 'Seventy', 'Eighty', 'Ninety']; const scales = ['', 'Thousand', 'Million', 'Billion', 'Trillion', 'Quadrillion', 'Quintillion', 'Sextillion', 'Septillion', 'Octillion', 'Nonillion', 'Decillion', 'Undecillion', 'Duodecillion', 'Tredecillion', 'Quattuordecillion', 'Quindecillion']; if (typeof number !== 'number' || !isFinite(number)) { return 'Invalid Number'; } if (number === 0) { return 'Zero'; } const MAX_SAFE_INTEGER_FOR_WORDS = BigInt("9".repeat((scales.length) * 3)); let numForCheck = number < 0 ? BigInt(Math.abs(Math.trunc(number))) : BigInt(Math.trunc(number)); if (numForCheck > MAX_SAFE_INTEGER_FOR_WORDS) { console.warn("Number too large for full word conversion, returning scientific."); return number.toExponential(2) + " (Too large for words)"; } let isNegative = number < 0; if (isNegative) number = -number; let integerPart; let fractionalPart = 0; try { const numStr = number.toLocaleString('en-US', { useGrouping: false, maximumFractionDigits: 20 }); const parts = numStr.split('.'); integerPart = BigInt(parts[0]); if (parts.length > 1) { fractionalPart = parseFloat('0.' + parts[1]); } } catch (e) { console.error("Error processing number for words:", number, e); return "Number too large or invalid format"; } let words = isNegative ? 'Negative ' : ''; function convertHundreds(num) { let word = ''; const h = Math.floor(num / 100); const r = num % 100; if (h > 0) word += units[h] + ' Hundred'; if (r > 0) { if (word !== '') word += ' '; if (r < 20) { word += units[r]; } else { const t = Math.floor(r / 10); const o = r % 10; word += tens[t]; if (o > 0) word += '-' + units[o]; } } return word; } if (integerPart === 0n) { words += 'Zero'; } else { let scaleIndex = 0; let tempWords = []; let currentInt = integerPart; while (currentInt > 0n) { if (scaleIndex >= scales.length) { console.error("Number exceeds defined scales during conversion:", number); return number.toExponential(2) + " (Too large for words)"; } const chunk = Number(currentInt % 1000n); if (chunk !== 0) { const chunkWords = convertHundreds(chunk); tempWords.push(chunkWords + (scaleIndex > 0 ? ' ' + scales[scaleIndex] : '')); } currentInt /= 1000n; scaleIndex++; } words += tempWords.reverse().filter(w => w.trim()).join(', '); } if (fractionalPart > 1e-9) { words += ' Point'; let fractionalStr = fractionalPart.toFixed(6).substring(2).replace(/0+$/, ''); if (fractionalStr.length > 0) { for (const digit of fractionalStr) { words += ' ' + (units[parseInt(digit)] || 'Zero'); } } else { words = words.replace(/ Point$/, ''); } } return words.trim(); }

        // --- State Management ---
        function gatherState() { const state = { baseDamage: baseDamageInput.value, baseMultiplier: baseMultiplierInput.value, formMultiplier: formMultiplierInput.value, attackCompressionPoints: attackCompressionPointsInput.value, selectedEnergyType: energyTypeSelect.value, sliderPercentages: {}, energyPools: {}, dynamicModifiers: [], kaiokenActive: kaiokenCheckbox.checked, maxHealth: maxHealthInput.value, kaiokenStrain: kaiokenStrainInput.value, currentHealth: currentHealthEl.value, totalDamageDealt: totalDamageDealt, totalEnergySpent: totalEnergySpent, attackCount: attackCount, highestDamage: highestDamage }; ALL_ENERGY_TYPES.forEach(type => { const els = getEnergyElements(type); if (els) { state.energyPools[type] = { maxEnergy: els.maxEnergyEl?.value || '0', maxMultiplier: els.maxMultiplierEl?.value || '1', currentEnergy: els.currentEnergyEl?.value || '0', damagePerPower: els.damagePerPowerEl?.value || '1', regenPercent: els.regenPercentEl?.value || '' }; state.sliderPercentages[type] = els.energySlider?.value || '0'; } }); dynamicModifiersContainer.querySelectorAll('.dynamic-box').forEach(box => { const nameInput = box.querySelector('.modifier-name-input'); const valueInput = box.querySelector('.modifier-value-input'); const typeOption = box.querySelector('.modifier-type-option.active'); if (nameInput && valueInput && typeOption) { state.dynamicModifiers.push({ name: nameInput.value, value: valueInput.value, type: typeOption.dataset.value }); } }); return state; }
        function applyState(state) { if (!state) return; baseDamageInput.value = state.baseDamage || ''; baseMultiplierInput.value = state.baseMultiplier || '1'; formMultiplierInput.value = state.formMultiplier || '1'; attackCompressionPointsInput.value = state.attackCompressionPoints || '0'; energyTypeSelect.value = state.selectedEnergyType || 'ki'; if (state.energyPools) { ALL_ENERGY_TYPES.forEach(type => { const els = getEnergyElements(type); const poolData = state.energyPools[type]; if (els && poolData && els.maxEnergyEl) { els.maxEnergyEl.value = poolData.maxEnergy || ''; els.maxMultiplierEl.value = poolData.maxMultiplier || '1'; els.damagePerPowerEl.value = poolData.damagePerPower || '1'; els.regenPercentEl.value = poolData.regenPercent || ''; const loadedTotal = (safeParseFloat(poolData.maxEnergy, 0) * safeParseFloat(poolData.maxMultiplier, 1)); els.totalEnergyEl.value = formatNumber(loadedTotal); els.currentEnergyEl.value = formatNumber(Math.min(safeParseFloat(poolData.currentEnergy, loadedTotal), loadedTotal)); } }); } if (state.sliderPercentages) { ALL_ENERGY_TYPES.forEach(type => { const els = getEnergyElements(type); if (els?.energySlider) { els.energySlider.value = state.sliderPercentages[type] || '0'; } updateSliderVisibility(type); updateSingleSliderDisplay(type); }); } dynamicModifiersContainer.innerHTML = '<h4 class="text-md font-semibold mb-2 text-gray-700">Additional Factors:</h4>'; dynamicModifierCount = 0; if (state.dynamicModifiers && Array.isArray(state.dynamicModifiers)) { state.dynamicModifiers.forEach(modData => { addDynamicModifier(modData); }); } kaiokenCheckbox.checked = state.kaiokenActive || false; maxHealthInput.value = state.maxHealth || '1000'; kaiokenStrainInput.value = state.kaiokenStrain || '10'; currentHealthEl.value = state.currentHealth || formatNumber(safeParseFloat(maxHealthInput.value, 0)); totalDamageDealt = state.totalDamageDealt || 0; totalEnergySpent = state.totalEnergySpent || 0; attackCount = state.attackCount || 0; highestDamage = state.highestDamage || 0; /* UI update happens after applyState in DOMContentLoaded */ }
        function saveState() { try { const state = gatherState(); const stateString = JSON.stringify(state); localStorage.setItem(LOCAL_STORAGE_KEY, stateString); showMessage('State saved successfully!', 'success'); } catch (error) { console.error("Error saving state:", error); showMessage(`Failed to save state. ${error.message}`, 'error'); } }
        function loadState() { const stateString = localStorage.getItem(LOCAL_STORAGE_KEY); if (stateString) { try { const state = JSON.parse(stateString); applyState(state); showMessage('State loaded successfully!', 'success'); return true; /* Indicate state was loaded */ } catch (error) { console.error("Error loading state:", error); showMessage(`Failed to load saved state. Data might be corrupted. ${error.message}`, 'error'); localStorage.removeItem(LOCAL_STORAGE_KEY); } } return false; /* Indicate no state loaded */ }
        function clearState() { if (confirm('Are you sure you want to clear the saved state? This cannot be undone.')) { localStorage.removeItem(LOCAL_STORAGE_KEY); showMessage('Saved state cleared. Reloading.', 'success'); setTimeout(() => window.location.reload(), 1000); } }


        // +++ Function to Generate Elements from Templates +++
        function generateEnergySections() {
            if (!energyPoolTemplate || !energySliderTemplate || !energyPoolsContainer || !slidersGrid) { console.error("Required templates or containers not found!"); return; }
            energyPoolsContainer.innerHTML = ''; slidersGrid.innerHTML = ''; // Clear containers
            ALL_ENERGY_TYPES.forEach(type => {
                const details = ENERGY_TYPE_DETAILS[type]; if (!details) return;
                // Generate Energy Pool
                const poolClone = energyPoolTemplate.content.cloneNode(true);
                const poolDiv = poolClone.querySelector('.energy-pool');
                if (poolDiv) {
                    poolDiv.id = `${type}-pool`; poolDiv.style.display = 'none';
                    poolDiv.classList.add(details.border, details.gradientTo);
                    const titleEl = poolDiv.querySelector('.pool-title');
                    if (titleEl) titleEl.textContent = `${details.name} Energy Pool`;
                    const setupInput = (selectorSuffix, focusClass = '') => { const inputEl = poolDiv.querySelector(`.${selectorSuffix}`); const labelEl = poolDiv.querySelector(`.${selectorSuffix}-label`); if (inputEl) { inputEl.id = `${type}-${selectorSuffix}`; if(labelEl) labelEl.htmlFor = inputEl.id; if (focusClass) inputEl.classList.add(focusClass); } };
                    setupInput('max-energy', details.focusRing); setupInput('max-multiplier', details.focusRing); setupInput('total-energy'); setupInput('current-energy'); setupInput('damage-per-power', details.focusRing); setupInput('regen-percent', details.focusRing);
                    const regenBtn = poolDiv.querySelector('.regen-btn'); if (regenBtn) { regenBtn.dataset.type = type; }
                    energyPoolsContainer.appendChild(poolClone);
                } else { console.error(`Could not find .energy-pool in template clone for ${type}`);}
                // Generate Energy Slider
                const sliderClone = energySliderTemplate.content.cloneNode(true);
                const sliderSection = sliderClone.querySelector('.energy-slider-section');
                if (sliderSection) {
                     sliderSection.id = `${type}-slider-section`; sliderSection.dataset.type = type;
                     const sliderLabel = sliderSection.querySelector('.slider-label'); const energySlider = sliderSection.querySelector('.energy-slider'); const valueDisplay = sliderSection.querySelector('.energy-slider-value-display');
                     if (sliderLabel) { sliderLabel.htmlFor = `${type}-energy-slider`; sliderLabel.textContent = `${details.name} Energy Used (%):`; }
                     if (energySlider) { energySlider.id = `${type}-energy-slider`; energySlider.dataset.type = type; }
                     if (valueDisplay) { valueDisplay.id = `${type}-slider-value-display`; }
                     slidersGrid.appendChild(sliderClone);
                } else { console.error(`Could not find .energy-slider-section in template clone for ${type}`);}
            });
            console.log("Energy sections generated.");
        }


        // --- Event Listeners Setup ---
        function setupEventListeners() {
            energyTypeSelect.addEventListener('change', showSelectedEnergyPool);
            calculateBtn.addEventListener('click', performCalculation);
            addDynamicBoxBtn.addEventListener('click', () => addDynamicModifier());
            document.querySelectorAll('.energy-slider').forEach(slider => { slider.addEventListener('input', (event) => { updateSingleSliderDisplay(event.target.dataset.type); }); });
            ALL_ENERGY_TYPES.forEach(type => {
                const els = getEnergyElements(type);
                if (els) {
                    if (els.maxEnergyEl) els.maxEnergyEl.addEventListener('input', () => { calculateAndResetEnergy(type); updateStatsDisplay(); });
                    if (els.maxMultiplierEl) els.maxMultiplierEl.addEventListener('input', () => { calculateAndResetEnergy(type); updateStatsDisplay(); });
                    if (els.damagePerPowerEl) els.damagePerPowerEl.addEventListener('input', () => updateSingleSliderDisplay(type));
                    const regenBtn = els.poolDiv?.querySelector('.regen-btn');
                     if (regenBtn) { regenBtn.addEventListener('click', function() { regenerateEnergy(this.dataset.type); }); }
                } else { console.warn(`Could not find elements for type ${type} to attach listeners.`); }
            });
             if (kaiokenCheckbox) { kaiokenCheckbox.addEventListener('change', () => { const isChecked = kaiokenCheckbox.checked; kaiokenDetails.classList.toggle('hidden', !isChecked); if (isChecked) { applyKaiokenStyle(); updateCurrentHealthDisplay(); } else { removeKaiokenStyle(); } }); }
             if (maxHealthInput) { maxHealthInput.addEventListener('input', updateCurrentHealthDisplay); }
             if (regenHealthBtn) { regenHealthBtn.addEventListener('click', regenerateHealth); }
             if (saveBtn) saveBtn.addEventListener('click', saveState);
             if (loadBtn) loadBtn.addEventListener('click', loadState);
             if (clearBtn) clearBtn.addEventListener('click', clearState);
             console.log("Event listeners set up.");
        }


        // --- Initial Setup on Page Load ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM Loaded. Initializing...");
            generateEnergySections(); // 1. Generate HTML elements

            // 2. Initialize energy values from defaults (needed before loadState)
            ALL_ENERGY_TYPES.forEach(type => { calculateAndResetEnergy(type); });

            const stateLoaded = loadState(); // 3. Try loading saved state

            setupEventListeners(); // 4. Attach event listeners

            // 5. Set initial UI state and update displays
            showSelectedEnergyPool(); // Show the correct pool based on dropdown (which loadState might have set)
            updateStatsDisplay(); // Update stats panel based on loaded or default data

            console.log(`Initialization complete. ${stateLoaded ? '(State Loaded)' : '(No State Loaded)'}`);
        });

    </script>

</body>
</html>
