<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Energy Calculator - v11.0 (Modular Forms)</title> <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/12.4.1/math.min.js"></script>
    <link
        rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css"
    />
    <script>
        // Tailwind CSS Configuration
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        // Energy types
                        ki: '#FF9800', nen: '#2196F3', chakra: '#9C27B0', magic: '#26a69a', cursed: '#dc2626',
                        reiatsu: '#475569', haki: '#1f2937', alchemy: '#f59e0b', nature: '#84cc16',
                        force: '#d946ef',
                        // Darker variants
                        'ki-dark': '#e65100', 'nen-dark': '#0d47a1', 'chakra-dark': '#4a148c', 'magic-dark': '#00796b', 'cursed-dark': '#b91c1c',
                        'reiatsu-dark': '#1e293b', 'haki-dark': '#000000', 'alchemy-dark': '#b45309', 'nature-dark': '#4d7c0f',
                        'force-dark': '#a21caf',
                        // UI feedback colors
                        'success-light': '#e8f5e9', 'success': '#4CAF50', 'success-dark': '#2e7d32',
                        'error-light': '#ffebee', 'error': '#f44336', 'error-dark': '#c62828',
                        // Stats panel specific colors
                        'stats-border': '#60a5fa', 'stats-header': '#1e3a8a',
                        // Kaioken active state colors
                        'kaioken-border': '#f87171', 'kaioken-header': '#b91c1c', 'kaioken-focus': '#ef4444',
                        // Focus Rings
                        'magic-focus': '#26a69a', 'cursed-focus': '#dc2626', 'reiatsu-focus': '#475569',
                        'haki-focus': '#1f2937', 'alchemy-focus': '#f59e0b', 'nature-focus': '#84cc16',
                        'ki-focus': '#FF9800', 'nen-focus': '#2196F3', 'chakra-focus': '#9C27B0',
                        'force-focus': '#d946ef',
                        'teal-focus': '#2dd4bf', // Teal focus for character stats
                        'form-creator-focus': '#a78bfa', // Violet focus for form creator
                    },
                    // Animations
                    animation: {
                        spin: 'spin 1s linear infinite', shake: 'shake 0.5s ease-in-out', fadeIn: 'fadeIn 0.3s ease-in', pulse: 'pulse 1.5s infinite',
                        'pulse-additive': 'pulse-additive 0.5s', 'pulse-multiplicative': 'pulse-multiplicative 0.5s', 'pulse-result': 'pulse-result 0.3s ease-in-out',
                        'flash-red': 'flash-red-bg 0.5s ease-out', 'flash-green': 'flash-green-bg 0.5s ease-out', 'kaioken-glow': 'kaioken-glow 1.5s infinite ease-in-out',
                        'animate-pulse-glow-ki': 'pulse-glow-ki 1.5s infinite ease-in-out',
                        'animate-pulse-glow-nen': 'pulse-glow-nen 1.5s infinite ease-in-out',
                        'animate-pulse-glow-chakra': 'pulse-glow-chakra 1.5s infinite ease-in-out',
                        'animate-pulse-glow-magic': 'pulse-glow-magic 1.5s infinite ease-in-out',
                        'animate-pulse-glow-cursed': 'pulse-glow-cursed 1.5s infinite ease-in-out',
                        'animate-pulse-glow-reiatsu': 'pulse-glow-reiatsu 1.5s infinite ease-in-out',
                        'animate-pulse-glow-haki': 'pulse-glow-haki 1.5s infinite ease-in-out',
                        'animate-pulse-glow-alchemy': 'pulse-glow-alchemy 1.5s infinite ease-in-out',
                        'animate-pulse-glow-nature': 'pulse-glow-nature 1.5s infinite ease-in-out',
                        'animate-pulse-glow-force': 'pulse-glow-force 1.5s infinite ease-in-out',
                        'animate-pulse-source': 'pulse-source-input 0.8s ease-out',
                        'bounceIn': 'bounceIn 0.75s', 'bounceOut': 'bounceOut 0.75s', 'fadeInUp': 'fadeInUp 0.5s',
                    },
                    // Keyframes
                    keyframes: {
                        spin: { '0%': { transform: 'rotate(0deg)' }, '100%': { transform: 'rotate(360deg)' }, },
                        shake: { '0%, 100%': { transform: 'translateX(0)' }, '25%, 75%': { transform: 'translateX(-5px)' }, '50%': { transform: 'translateX(5px)' }, },
                        fadeIn: { from: { opacity: 0, transform: 'translateY(10px)' }, to: { opacity: 1, transform: 'translateY(0)' }, },
                        pulse: { '0%, 100%': { transform: 'scale(1)' }, '50%': { transform: 'scale(1.05)' }, },
                        'pulse-additive': { '0%, 100%': { color: '#558b2f' }, '50%': { color: '#8BC34A' }, },
                        'pulse-multiplicative': { '0%, 100%': { color: '#e65100' }, '50%': { color: '#FF9800' }, },
                        'pulse-result': { '0%, 100%': { transform: 'scale(1)' }, '50%': { transform: 'scale(1.05)' }, },
                        'flash-red-bg': { '50%': { backgroundColor: '#ffebee', borderColor: '#f44336' } },
                        'flash-green-bg': { '50%': { backgroundColor: '#e8f5e9', borderColor: '#4CAF50' } },
                        'kaioken-glow': { '0%, 100%': { boxShadow: `0 0 10px #f8717180` }, '50%': { boxShadow: `0 0 20px #f87171CC` } },
                         'pulse-glow-ki': { '0%, 100%': { boxShadow: `0 0 8px #FF980066` }, '50%': { boxShadow: `0 0 16px #FF9800B3` } },
                         'pulse-glow-nen': { '0%, 100%': { boxShadow: `0 0 8px #2196F366` }, '50%': { boxShadow: `0 0 16px #2196F3B3` } },
                         'pulse-glow-chakra': { '0%, 100%': { boxShadow: `0 0 8px #9C27B066` }, '50%': { boxShadow: `0 0 16px #9C27B0B3` } },
                         'pulse-glow-magic': { '0%, 100%': { boxShadow: `0 0 8px #26a69a66` }, '50%': { boxShadow: `0 0 16px #26a69aB3` } },
                         'pulse-glow-cursed': { '0%, 100%': { boxShadow: `0 0 8px #dc262666` }, '50%': { boxShadow: `0 0 16px #dc2626B3` } },
                         'pulse-glow-reiatsu': { '0%, 100%': { boxShadow: `0 0 8px #47556966` }, '50%': { boxShadow: `0 0 16px #475569B3` } },
                         'pulse-glow-haki': { '0%, 100%': { boxShadow: `0 0 8px #1f293766` }, '50%': { boxShadow: `0 0 16px #1f2937B3` } },
                         'pulse-glow-alchemy': { '0%, 100%': { boxShadow: `0 0 8px #f59e0b66` }, '50%': { boxShadow: `0 0 16px #f59e0bB3` } },
                         'pulse-glow-nature': { '0%, 100%': { boxShadow: `0 0 8px #84cc1666` }, '50%': { boxShadow: `0 0 16px #84cc16B3` } },
                         'pulse-glow-force': { '0%, 100%': { boxShadow: `0 0 8px #d946ef66` }, '50%': { boxShadow: `0 0 16px #d946efB3` } },
                         'pulse-source-input': { '0%, 100%': { boxShadow: 'none' }, '50%': { boxShadow: '0 0 12px theme("colors.blue.400")' } },
                         'shakeX': { /* Uses animate.css definition */ },
                         'bounceIn': { /* Uses animate.css definition */ },
                         'bounceOut': { /* Uses animate.css definition */ },
                         'fadeInUp': { /* Uses animate.css definition */ },
                    }
                }
            }
        }
    </script>
    <link rel="preconnect" href="https://rsms.me/">
    <link rel="stylesheet" href="https://rsms.me/inter/inter.css">
    <style>
        /* Base Styles */
        body { font-family: 'Inter', sans-serif; background-color: #f9f9f9; color: #333; }
        /* Base style for energy pool sections */
        .energy-pool { @apply p-5 mb-5 rounded-lg shadow-sm border-l-4; transition: box-shadow 0.3s ease-in-out, opacity 0.3s ease-in-out; }

        /* Dynamic Pool Styles */
        .energy-pool-ki { border-left-color: #FF9800; } .energy-pool-ki h3 { color: #e65100; }
        .energy-pool-nen { border-left-color: #2196F3; } .energy-pool-nen h3 { color: #0d47a1; }
        .energy-pool-chakra { border-left-color: #9C27B0; } .energy-pool-chakra h3 { color: #4a148c; }
        .energy-pool-magic { border-left-color: #26a69a; } .energy-pool-magic h3 { color: #00796b; }
        .energy-pool-cursed { border-left-color: #dc2626; } .energy-pool-cursed h3 { color: #b91c1c; }
        .energy-pool-reiatsu { border-left-color: #475569; } .energy-pool-reiatsu h3 { color: #1e293b; }
        .energy-pool-haki { border-left-color: #1f2937; } .energy-pool-haki h3 { color: #000000; }
        .energy-pool-alchemy { border-left-color: #f59e0b; } .energy-pool-alchemy h3 { color: #b45309; }
        .energy-pool-nature { border-left-color: #84cc16; } .energy-pool-nature h3 { color: #4d7c0f; }
        .energy-pool-force { border-left-color: #d946ef; } .energy-pool-force h3 { color: #a21caf; }

        /* Base Slider Track Style */
        .energy-slider {
            @apply w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer;
            transition: background 0.2s ease-in-out;
            }
        /* Base Slider Thumb Style */
        .energy-slider::-webkit-slider-thumb { appearance: none; width: 20px; height: 20px; border-radius: 50%; cursor: pointer; box-shadow: 0 1px 3px rgba(0,0,0,0.2); transition: background 0.3s; border: none; background: #9ca3af; }
        .energy-slider::-moz-range-thumb { width: 20px; height: 20px; border-radius: 50%; cursor: pointer; box-shadow: 0 1px 3px rgba(0,0,0,0.2); transition: background 0.3s; border: none; background: #9ca3af; }

        /* Slider Thumb Colors */
        #ki-energy-slider::-webkit-slider-thumb { background: #FF9800; } #ki-energy-slider::-moz-range-thumb { background: #FF9800; }
        #nen-energy-slider::-webkit-slider-thumb { background: #2196F3; } #nen-energy-slider::-moz-range-thumb { background: #2196F3; }
        #chakra-energy-slider::-webkit-slider-thumb { background: #9C27B0; } #chakra-energy-slider::-moz-range-thumb { background: #9C27B0; }
        #magic-energy-slider::-webkit-slider-thumb { background: #26a69a; } #magic-energy-slider::-moz-range-thumb { background: #26a69a; }
        #cursed-energy-slider::-webkit-slider-thumb { background: #dc2626; } #cursed-energy-slider::-moz-range-thumb { background: #dc2626; }
        #reiatsu-energy-slider::-webkit-slider-thumb { background: #475569; } #reiatsu-energy-slider::-moz-range-thumb { background: #475569; }
        #haki-energy-slider::-webkit-slider-thumb { background: #1f2937; } #haki-energy-slider::-moz-range-thumb { background: #1f2937; }
        #alchemy-energy-slider::-webkit-slider-thumb { background: #f59e0b; } #alchemy-energy-slider::-moz-range-thumb { background: #f59e0b; }
        #nature-energy-slider::-webkit-slider-thumb { background: #84cc16; } #nature-energy-slider::-moz-range-thumb { background: #84cc16; }
        #force-energy-slider::-webkit-slider-thumb { background: #d946ef; } #force-energy-slider::-moz-range-thumb { background: #d946ef; }

        /* Slider Thumb Hover Colors */
        #ki-energy-slider:hover::-webkit-slider-thumb { background: #e65100; } #ki-energy-slider:hover::-moz-range-thumb { background: #e65100; }
        #nen-energy-slider:hover::-webkit-slider-thumb { background: #0d47a1; } #nen-energy-slider:hover::-moz-range-thumb { background: #0d47a1; }
        #chakra-energy-slider:hover::-webkit-slider-thumb { background: #4a148c; } #chakra-energy-slider:hover::-moz-range-thumb { background: #4a148c; }
        #magic-energy-slider:hover::-webkit-slider-thumb { background: #00796b; } #magic-energy-slider:hover::-moz-range-thumb { background: #00796b; }
        #cursed-energy-slider:hover::-webkit-slider-thumb { background: #b91c1c; } #cursed-energy-slider:hover::-moz-range-thumb { background: #b91c1c; }
        #reiatsu-energy-slider:hover::-webkit-slider-thumb { background: #1e293b; } #reiatsu-energy-slider:hover::-moz-range-thumb { background: #1e293b; }
        #haki-energy-slider:hover::-webkit-slider-thumb { background: #000000; } #haki-energy-slider:hover::-moz-range-thumb { background: #000000; }
        #alchemy-energy-slider:hover::-webkit-slider-thumb { background: #b45309; } #alchemy-energy-slider:hover::-moz-range-thumb { background: #b45309; }
        #nature-energy-slider:hover::-webkit-slider-thumb { background: #4d7c0f; } #nature-energy-slider:hover::-moz-range-thumb { background: #4d7c0f; }
        #force-energy-slider:hover::-webkit-slider-thumb { background: #a21caf; } #force-energy-slider:hover::-moz-range-thumb { background: #a21caf; }

        /* Dynamic Modifier Box Styles */
        .modifier-type-option.additive { border-color: theme('colors.success'); color: theme('colors.success-dark'); }
        .modifier-type-option.additive.active { background-color: theme('colors.success-light'); box-shadow: 0 1px 5px rgba(76, 175, 80, 0.3); animation: pulse-additive 0.5s; color: theme('colors.success'); }
        .modifier-type-option.multiplicative { border-color: theme('colors.ki'); color: theme('colors.ki-dark'); }
        .modifier-type-option.multiplicative.active { background-color: theme('colors.ki / 0.1'); box-shadow: 0 1px 5px rgba(255, 152, 0, 0.3); animation: pulse-multiplicative 0.5s; color: theme('colors.ki'); }

        /* Custom Animation Classes */
        .animate-pulse-result { animation: pulse-result 0.3s ease-in-out; }
        .animate-flash-red { animation: flash-red-bg 0.5s ease-out; }
        .animate-flash-green { animation: flash-green-bg 0.5s ease-out; }
        .animate-kaioken-glow { animation: kaioken-glow 1.5s infinite ease-in-out; }

        /* Static Glow classes for energy pools */
        .static-glow-ki { box-shadow: 0 0 10px #FF980080; } .static-glow-nen { box-shadow: 0 0 10px #2196F380; } .static-glow-chakra { box-shadow: 0 0 10px #9C27B080; } .static-glow-magic { box-shadow: 0 0 10px #26a69a80; } .static-glow-cursed { box-shadow: 0 0 10px #dc262680; } .static-glow-reiatsu { box-shadow: 0 0 10px #47556980; } .static-glow-haki { box-shadow: 0 0 10px #1f293780; } .static-glow-alchemy { box-shadow: 0 0 10px #f59e0b80; } .static-glow-nature { box-shadow: 0 0 10px #84cc1680; }
        .static-glow-force { box-shadow: 0 0 10px #d946ef80; }

        /* Accessibility utility class */
        .sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 0, 0); white-space: nowrap; border-width: 0; }
        /* Stats Panel Styling */
        .stats-panel { border-left-width: 4px; transition: border-color 0.3s ease-in-out, box-shadow 1.5s ease-in-out; }
        .stats-panel-header { transition: color 0.3s ease-in-out; }
        /* Common Label Style */
        .lbl { @apply block mb-1 font-medium text-sm text-gray-600; }
        /* Common Input Style */
        .inpt { @apply w-full p-2 border border-gray-300 rounded-md focus:ring-2 focus:border-transparent text-sm transition-colors duration-300; }
        /* Common Select Style */
        .slct { @apply w-full p-2 border border-gray-300 rounded-md focus:ring-2 focus:border-transparent text-sm bg-white; }

        /* Input Readonly Style */
        .inpt:read-only, .slct:disabled { @apply bg-gray-100 cursor-not-allowed opacity-70; }
        /* Common Regen Button Style */
        .regen-btn { @apply px-3 py-2 text-white rounded-md focus:outline-none focus:ring-2 focus:ring-offset-2 transition-all duration-150 ease-in-out text-sm font-semibold shadow-sm active:scale-95; }
        /* Save/Load Button Style */
        .save-load-btn { @apply px-3 py-1 text-sm text-white rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-offset-1 transition-all duration-150 ease-in-out active:scale-95; }

        /* Style for span elements used as read-only displays */
        .readonly-display {
            @apply inline-block font-medium text-gray-800 min-h-[42px] px-2 py-2 w-full bg-gray-50 rounded-md border border-gray-200;
            line-height: 1.5; /* Vertically center text */
            word-break: break-all; /* Prevent layout breaks */
        }

        /* Equation Display Styles */
        .equation-number {
            @apply font-semibold text-blue-600 hover:text-blue-800 underline transition-colors duration-150;
            cursor: pointer;
        }
        .equation-number:hover {
             text-shadow: 0 0 8px rgba(147, 197, 253, 0.8); /* blue-300 with alpha */
        }
        .equation-operator { @apply text-gray-600 mx-1; }
        .equation-group { @apply mx-0.5; }

        /* Animation for pulsing the source input linked from equation */
        .animate-pulse-source {
            animation: pulse-source-input 0.8s ease-out;
        }

        /* Attack Button Active State */
        .attack-btn.active {
            @apply ring-2 ring-offset-2 scale-105 brightness-110; /* Add ring, slightly enlarge, and brighten */
        }
        #super-attack-btn.active {
            @apply ring-blue-600 bg-blue-700; /* Specific active style for super */
        }
        #ultimate-attack-btn.active {
            @apply ring-purple-600 bg-purple-700; /* Specific active style for ultimate */
        }

        /* Form Creator Specific Styles */
        .form-creator-input { @apply focus:ring-form-creator-focus; }
        .form-creator-button { @apply px-4 py-2 bg-purple-600 text-white rounded-md hover:bg-purple-700 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-offset-2 transition-all duration-150 ease-in-out text-sm font-semibold shadow-sm active:scale-95; }

        /* Form List Styles */
        .form-list-group h4 { @apply text-sm font-semibold text-gray-600 mt-2 mb-1 border-b border-gray-200 pb-1; }
        /* Updated form-list-item style to accommodate delete button */
        .form-list-item {
             @apply inline-block text-xs bg-gray-100 text-gray-700 border border-gray-300 rounded px-1.5 py-0.5 mr-1 mb-1;
             /* flex-grow added dynamically via JS */
             /* Removed fixed inline-block to allow flex layout */
        }
        /* Style for delete button added inline via JS for simplicity, or could be defined here */
        /* .delete-form-btn { ... } */

    </style>
</head>
<body class="p-4 md:p-6">

    <div class="mb-4 flex flex-wrap gap-2">
       <button id="google-signin-btn" class="save-load-btn bg-red-600 hover:bg-red-700 focus:ring-red-500">Sign in with Google</button>
        <button id="sign-out-btn" class="save-load-btn bg-gray-700 hover:bg-gray-800 focus:ring-gray-600 hidden">Sign Out</button> 
        <span id="user-info" class="text-sm text-gray-600 self-center ml-2">Not signed in.</span>
        <button id="save-state-btn" class="save-load-btn bg-blue-500 hover:bg-blue-600 focus:ring-blue-400">Save State</button>
        <button id="load-state-btn" class="save-load-btn bg-gray-500 hover:bg-gray-600 focus:ring-gray-400">Load State</button>
        <button id="clear-state-btn" class="save-load-btn bg-red-500 hover:bg-red-600 focus:ring-red-400">Clear Saved</button>
        <button id="show-character-stats-btn" class="save-load-btn bg-teal-500 hover:bg-teal-600 focus:ring-teal-400">Character Stats</button>
    </div>
    <h1 class="text-3xl font-bold mb-6 text-center text-gray-800">Energy Calculator</h1>

    <div id="main-calculator-content">
        <div class="flex flex-col md:flex-row gap-6 max-w-7xl mx-auto">

            <div class="flex-grow md:w-3/4">

                <div id="message-area" class="mb-4 p-3 rounded-md text-sm hidden" role="alert"></div>

                <div class="energy-pool bg-white p-5 mb-5 rounded-lg shadow-sm border-l-4 border-gray-400">
                     <h3 class="text-xl font-semibold mb-4 flex items-center">
                         Damage Modifiers
                         <span class="flex-grow h-px bg-gray-200 ml-3"></span> </h3>
                     <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                         <div><label for="base-damage" class="lbl">Base Damage:</label><input type="text" id="base-damage" placeholder="e.g., 100" aria-required="true" class="inpt focus:ring-success"></div>
                         <div><label for="attack-compression-points" class="lbl">Attack Compression Points:</label><input type="text" id="attack-compression-points" placeholder="e.g., 10" value="0" class="inpt focus:ring-red-500"></div>
                         <div><label for="base-multiplier" class="lbl">Base Multiplier:</label><input type="text" id="base-multiplier" placeholder="e.g., 1.5" value="1" class="inpt focus:ring-success"></div>
                         <div><label for="form-multiplier" class="lbl">Form Multiplier:</label><input type="text" id="form-multiplier" placeholder="From Active Form" value="1" class="inpt focus:ring-success" readonly></div>
                     </div>
                     <div id="dynamic-modifiers-container" class="mb-4"><h4 class="text-md font-semibold mb-2 text-gray-700">Additional Factors:</h4></div>
                     <button id="add-dynamic-box" aria-label="Add modifier factor" class="px-4 py-2 bg-chakra text-white rounded-md hover:bg-chakra-dark focus:outline-none focus:ring-2 focus:ring-chakra focus:ring-offset-2 transition-all duration-150 ease-in-out text-sm font-semibold shadow-sm active:scale-95">
                         Add Factor
                     </button>
                 </div>

                 <div class="form-group mb-5">
                     <label for="energy-type" class="lbl">Energy Type:</label>
                     <select id="energy-type" aria-label="Select energy type" class="slct focus:ring-success">
                         <option value="ki">Ki Energy</option>
                         <option value="nen">Nen Energy</option>
                         <option value="chakra">Chakra Energy</option>
                         <option value="magic">Magic Energy</option>
                         <option value="cursed">Cursed Energy</option>
                         <option value="reiatsu">Reiatsu</option>
                         <option value="haki">Haki</option>
                         <option value="alchemy">Alchemy</option>
                         <option value="nature">Nature Energy</option>
                         <option value="force">Force Energy</option>
                     </select>
                 </div>

                 <div id="energy-pools-container" class="mb-5">
                     </div>

                 <div id="attacks-section" class="bg-white p-5 mb-5 rounded-lg shadow-sm">
                  <h3 class="text-xl font-semibold mb-4 text-gray-700 border-b pb-2">Attacks</h3>
                  <div class="flex flex-col sm:flex-row gap-3">
                      <button id="super-attack-btn" data-attack-type="super" data-reserve-percent="5" class="attack-btn flex-1 px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-400 focus:ring-offset-2 transition-all duration-150 ease-in-out text-sm font-semibold shadow-sm active:scale-95">
                          Super Attack (Reserves 5%)
                      </button>
                      <button id="ultimate-attack-btn" data-attack-type="ultimate" data-reserve-percent="10" class="attack-btn flex-1 px-4 py-2 bg-purple-500 text-white rounded-md hover:bg-purple-600 focus:outline-none focus:ring-2 focus:ring-purple-400 focus:ring-offset-2 transition-all duration-150 ease-in-out text-sm font-semibold shadow-sm active:scale-95">
                          Ultimate Attack (Reserves 10%)
                      </button>
                  </div>
                  <p id="attack-status-message" class="text-xs text-gray-500 mt-2 min-h-[1.25rem]"></p>
                 </div>

                 <div id="all-sliders-container" class="bg-white p-5 mb-5 rounded-lg shadow-sm">
                  <h3 class="text-xl font-semibold mb-4 text-gray-700 border-b pb-2">Energy Usage Sliders</h3>
                  <div id="sliders-grid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-x-6 gap-y-4">
                      </div>
                 </div>

                 <button id="calculate-btn" aria-label="Calculate final damage value" class="w-full px-4 py-3 bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 transition-all duration-150 ease-in-out text-lg font-semibold shadow-md mb-5 active:scale-95">
                  Calculate Damage
                 </button>

                 <div id="loading" class="loading text-center p-5 hidden">
                  <div class="loading-spinner inline-block w-8 h-8 border-4 border-t-success border-gray-200 rounded-full animate-spin" aria-hidden="true"></div>
                  <div class="loading-text mt-2 text-gray-600">Calculating...</div><span class="sr-only">Loading, please wait</span>
                 </div>

                 <div id="result" class="result bg-success-light p-5 rounded-lg border-l-4 border-success shadow-sm hidden" aria-live="polite">
                  <div class="result-title text-lg font-semibold mb-2 text-success-dark">Calculated Damage:</div>
                  <div id="result-value" class="result-value text-3xl font-bold mb-3 break-words">0</div>
                  <div id="result-details" class="result-details text-sm text-gray-700 mt-3 border-t border-success/30 pt-3">
                      <p><strong>Total Energy Used:</strong> <span id="result-total-energy-used">0</span></p>
                      <p><strong>Total Extra Damage from Energy:</strong> <span id="result-total-extra-damage">0.00</span></p>
                      <div class="mt-3 pt-3 border-t border-success/20">
                          <p class="font-semibold mb-1">Calculation:</p>
                          <div id="equation-display" class="text-sm bg-gray-50 p-2 rounded border border-gray-200 break-words leading-relaxed">
                              Equation not yet calculated.
                          </div>
                      </div>
                      <hr class="my-2 border-success/20"> <p><strong>Scientific Notation:</strong> <span id="result-scientific">0</span></p>
                      <p><strong>In Words:</strong> <span id="result-words">Zero</span></p>
                  </div>
                 </div>

            </div> <div id="stats-panel" class="stats-panel md:w-1/4 lg:w-1/5 p-5 bg-white rounded-lg shadow-sm self-start sticky top-6 border-stats-border">
                 <h3 id="stats-panel-header" class="stats-panel-header text-xl font-semibold mb-4 flex items-center text-stats-header">
                     Stats
                     <span class="flex-grow h-px bg-gray-200 ml-3"></span> </h3>
                 <div class="space-y-3">
                     <p class="text-sm text-gray-600">Selected Current Energy: <span id="stat-current-energy" class="font-medium text-gray-800 break-words">0</span></p>
                     <hr class="border-gray-200">
                     <p class="text-sm text-gray-600">Total Damage Dealt: <span id="stat-total-damage" class="font-medium text-gray-800 break-words">0</span></p>
                     <p class="text-sm text-gray-600">Total Energy Spent: <span id="stat-total-energy-spent" class="font-medium text-gray-800 break-words">0</span></p>
                     <p class="text-sm text-gray-600">Highest Damage: <span id="stat-highest-damage" class="font-medium text-gray-800 break-words">0</span></p>
                     <div class="flex items-center justify-between text-sm text-gray-600">
                         <span>Number of Attacks: <span id="stat-attack-count" class="font-medium text-gray-800 break-words">0</span></span>
                         <button id="reset-attack-count-btn" title="Reset Attack Count" class="px-2 py-0.5 text-xs bg-gray-200 hover:bg-red-200 text-gray-600 hover:text-red-700 rounded focus:outline-none focus:ring-1 focus:ring-red-400 focus:ring-offset-1 transition-colors duration-150 active:scale-95">
                             Reset?
                         </button>
                     </div>
                     <hr class="border-gray-200">
                      <p class="text-sm text-gray-600">Form AC Bonus: <span id="stat-form-ac-bonus" class="font-medium text-gray-800 break-words">0</span></p>
                      <p class="text-sm text-gray-600">Form TR Bonus: <span id="stat-form-tr-bonus" class="font-medium text-gray-800 break-words">0</span></p>
                      <p class="text-sm text-gray-600">Total AC: <span id="stat-total-ac" class="font-medium text-gray-800 break-words">0</span></p>
                      <p class="text-sm text-gray-600">Total TR: <span id="stat-total-tr" class="font-medium text-gray-800 break-words">0</span></p>
                     <hr class="border-gray-200">
                     <div id="kaioken-section" class="hidden pt-3 border-t border-gray-200">
                         <div class="flex items-center gap-2 mb-3">
                             <input type="checkbox" id="kaioken-checkbox" class="rounded border-gray-300 text-red-600 shadow-sm focus:ring-kaioken-focus">
                             <label for="kaioken-checkbox" class="text-sm font-medium text-kaioken-header">Kaioken?</label>
                         </div>
                         <div id="kaioken-details" class="hidden space-y-2">
                             <div class="flex items-center gap-2">
                                 <div class="flex-grow">
                                     <label for="max-health" class="lbl">Max Health:</label>
                                     <input type="text" id="max-health" placeholder="e.g., 1000" value="1000" class="inpt focus:ring-kaioken-focus">
                                 </div>
                                 <button id="regen-health-btn" title="Regenerate Health to Max" class="px-2 py-1 text-xs bg-success hover:bg-success-dark text-white rounded-md focus:outline-none focus:ring-2 focus:ring-success focus:ring-offset-1 self-end mb-1 transition-transform active:scale-95">Regen Health</button>
                             </div>
                             <div><label for="kaioken-strain" class="lbl">Kaioken Strain (% Max HP):</label><input type="text" id="kaioken-strain" placeholder="e.g., 10" value="10" class="inpt focus:ring-kaioken-focus"></div>
                             <div>
                                 <label class="lbl">Current Health:</label>
                                 <span id="current-health" class="readonly-display current-health">1000</span>
                             </div>
                         </div>
                     </div>

                    <div id="formListSection" class="pt-3 border-t border-gray-200">
                         <h4 class="text-md font-semibold mb-2 text-gray-700">Saved Forms</h4>
                         <div id="formListContainer" class="max-h-48 overflow-y-auto text-xs">
                             <p class="text-gray-500">No forms created yet.</p>
                         </div>
                     </div>
                     </div>
            </div> </div> </div> <div id="character-stats-screen" class="hidden bg-white p-6 rounded-lg shadow-md max-w-7xl mx-auto mt-6 border border-gray-200">
        <div class="flex justify-between items-center mb-4 border-b pb-2">
            <h2 class="text-2xl font-bold text-gray-700">Character Stats</h2>
            </div>
        <div class="flex justify-center items-center flex-col mt-8">
            <label for="character-name" class="lbl text-lg mb-2">Character Name:</label>
            <input type="text" id="character-name" placeholder="Enter character name" class="inpt w-full md:w-1/2 lg:w-1/3 p-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-teal-focus focus:border-transparent text-center">
        </div>
        <div id="character-stats-inputs" class="mt-6 grid grid-cols-1 md:grid-cols-2 gap-x-6 gap-y-4">
            <div>
                <label for="char-base-health" class="lbl">Base Health:</label>
                <input type="text" id="char-base-health" placeholder="e.g., 1000" class="inpt focus:ring-teal-focus">
            </div>
             <div>
                <label for="char-base-multiplier" class="lbl">Base Multiplier:</label>
                <input type="text" id="char-base-multiplier" placeholder="e.g., 1" value="1" class="inpt focus:ring-teal-focus">
             </div>
            <div class="md:col-span-2 flex items-center gap-2 mt-1 -mb-2"> <input type="checkbox" id="ryoko-checkbox" class="h-4 w-4 rounded border-gray-300 text-teal-600 focus:ring-teal-500">
                 <label for="ryoko-checkbox" class="text-sm text-gray-700 select-none">Are you Ryoko?</label>
              </div>
             <div id="ryoko-equation-input-container" class="hidden md:col-span-2 mt-2"> <label for="ryoko-equation-input" class="lbl text-red-600">Type out your shit equation:</label> <input type="text" id="ryoko-equation-input" placeholder="Enter equation value..." class="inpt focus:ring-red-500 border-red-300"> </div>
            <div>
                <label for="char-vitality" class="lbl">Vitality:</label>
                <input type="text" id="char-vitality" placeholder="e.g., 50" class="inpt focus:ring-teal-focus">
            </div>
            <div>
                <label for="char-soul-power" class="lbl">Soul Power:</label>
                <input type="text" id="char-soul-power" placeholder="e.g., 100" class="inpt focus:ring-teal-focus">
            </div>
            <div>
                <label for="char-soul-hp" class="lbl">Soul HP:</label>
                <input type="text" id="char-soul-hp" placeholder="e.g., 200" class="inpt focus:ring-teal-focus">
            </div>
            <div>
                <label for="char-base-ac" class="lbl">Base AC:</label>
                <input type="text" id="char-base-ac" placeholder="e.g., 10" value="10" class="inpt focus:ring-teal-focus">
            </div>
             <div>
                <label for="char-base-tr" class="lbl">Base True Resistance:</label>
                <input type="text" id="char-base-tr" placeholder="e.g., 5" value="5" class="inpt focus:ring-teal-focus">
             </div>
            </div>

        <div id="formCreatorSection" class="mt-8 pt-6 border-t border-gray-200">
            <h3 class="text-xl font-semibold mb-4 text-gray-700">Form Creator</h3>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-x-6 gap-y-4 bg-gray-50 p-4 rounded-md border border-gray-200">
                 <div>
                    <label for="formNameInput" class="lbl">Form Name:</label>
                    <input type="text" id="formNameInput" placeholder="e.g., Super Saiyan 1" class="inpt form-creator-input">
                 </div>
                 <div>
                    <label for="formEnergyTypeSelect" class="lbl">Form Energy Type:</label>
                    <select id="formEnergyTypeSelect" class="slct form-creator-input">
                        <option value="None">None</option>
                        <option value="ki">Ki</option>
                        <option value="nen">Nen</option>
                        <option value="chakra">Chakra</option>
                        <option value="magic">Magic</option>
                        <option value="cursed">Cursed</option>
                        <option value="reiatsu">Reiatsu</option>
                        <option value="haki">Haki</option>
                        <option value="alchemy">Alchemy</option>
                        <option value="nature">Nature</option>
                        <option value="force">Force</option>
                        </select>
                 </div>
                 <div>
                    <label for="formFormMultiplierInput" class="lbl">Form Multiplier (Main):</label>
                    <input type="number" id="formFormMultiplierInput" value="1" step="0.1" class="inpt form-creator-input">
                 </div>
                 <div>
                    <label for="formPoolMaxMultiplierInput" class="lbl">Pool Max Multiplier:</label>
                    <input type="number" id="formPoolMaxMultiplierInput" value="1" step="0.1" class="inpt form-creator-input">
                 </div>

                 <div class="md:col-span-2">
                    <label for="formAffectsResistancesCheckbox" class="flex items-center gap-2">
                        <input type="checkbox" id="formAffectsResistancesCheckbox" class="h-4 w-4 rounded border-gray-300 text-purple-600 focus:ring-purple-500">
                        <span class="lbl mb-0">Affects Resistances?</span>
                    </label>
                 </div>
                 <div id="formResistanceBonusInputs" class="hidden md:col-span-2 grid grid-cols-1 md:grid-cols-2 gap-x-6 gap-y-4 pl-6 border-l-2 border-purple-200">
                     <div>
                        <label for="formAcBonusInput" class="lbl">AC Bonus:</label>
                        <input type="number" id="formAcBonusInput" value="0" class="inpt form-creator-input">
                     </div>
                     <div>
                        <label for="formTrueResistanceBonusInput" class="lbl">True Resistance Bonus:</label>
                        <input type="number" id="formTrueResistanceBonusInput" value="0" class="inpt form-creator-input">
                     </div>
                 </div>
                 <div class="md:col-span-2">
                    <button id="addFormButton" class="form-creator-button w-full md:w-auto">Add This Form</button>
                 </div>
            </div>
        </div>
         </div> <template id="energy-pool-template">
        <div class="energy-pool bg-gradient-to-br from-white p-5 mb-5 rounded-lg shadow-sm border-l-4" style="display: none;">
             <h3 class="text-xl font-semibold mb-4 flex items-center">
                 <span class="pool-title">Energy Pool Title</span>
                 <span class="flex-grow h-px bg-gray-200 ml-3"></span>
             </h3>

             <div class="form-select-container mb-4 hidden">
                 <label class="lbl form-select-label">Active Form:</label>
                 <select class="slct form-select">
                     <option value="none">None</option>
                     </select>
             </div>
             <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                 <div>
                     <label class="lbl base-max-energy-label">Base Max Energy (Calculated):</label>
                     <span class="readonly-display base-max-energy">0</span> </div>
                 <div><label class="lbl max-multiplier-label" for="">Pool Max Multiplier:</label><input type="text" value="1" class="inpt max-multiplier"></div>
                 <div>
                     <label class="lbl total-energy-label">Total Energy (Calculated):</label>
                     <span class="readonly-display total-energy">0</span> </div>
                 <div>
                     <label class="lbl current-energy-label">Current Energy:</label>
                     <span class="readonly-display current-energy">0</span> </div>
                 <div><label class="lbl damage-per-power-label" for="">Damage per Energy Point:</label><input type="text" value="1" class="inpt damage-per-power"></div>
                 <div>
                     <label class="lbl regen-percent-label" for="">Regeneration Rate (% of Total):</label>
                     <div class="flex items-center gap-2">
                         <input type="text" placeholder="e.g., 10" class="flex-grow p-2 border border-gray-300 rounded-md focus:ring-2 focus:border-transparent text-sm regen-percent">
                         <button class="regen-btn bg-success hover:bg-success-dark focus:ring-success px-3 py-2 text-white rounded-md focus:outline-none focus:ring-2 focus:ring-offset-2 transition-all duration-150 ease-in-out text-sm font-semibold shadow-sm active:scale-95">Regen</button>
                     </div>
                 </div>
             </div>
          </div>
       </template>

    <template id="energy-slider-template">
         <div class="energy-slider-section hidden">
             <label class="lbl text-sm slider-label" for="">Energy Used (%):</label>
             <input type="range" class="energy-slider w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer" min="0" max="100" value="0">
             <div class="flex justify-between text-xs text-gray-500 px-1"><span>0%</span><span>50%</span><span>100%</span></div>
             <div class="energy-slider-value-display flex justify-between items-center text-xs bg-gray-100 text-gray-700 p-1 rounded-md min-h-[2.5rem]">
                 <span class="slider-percent-value">0%</span>
                 <span class="slider-details-value text-right">(E: 0, D: 0.00)</span>
             </div>
         </div>
     </template>

    <script type="module">
      // Import the functions you need from the SDKs you need
      import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.0/firebase-app.js"; 
      import { getDatabase, ref, set, get, remove } from "https://www.gstatic.com/firebasejs/11.6.0/firebase-database.js"; 
      // *** Import Auth functions ***
      import { 
          getAuth, 
          onAuthStateChanged, 
          GoogleAuthProvider, 
          signInWithPopup,    
          signOut             
      } from "https://www.gstatic.com/firebasejs/11.6.0/firebase-auth.js"; 
      
      // === Your Specific Firebase Configuration ===
      // Make sure databaseURL has a comma after it if other properties follow!
      const firebaseConfig = {
        apiKey: "AIzaSyAbYQWbMQBHOdT-PxwIXeDFvLgEXlX7PhY", 
        authDomain: "dndfortheboys-d88d9.firebaseapp.com",
        databaseURL: "https://dndfortheboys-d88d9-default-rtdb.firebaseio.com/", // Comma added if needed
        projectId: "dndfortheboys-d88d9",
        storageBucket: "dndfortheboys-d88d9.firebasestorage.app", 
        messagingSenderId: "721075269380", 
        appId: "1:721075269380:web:197009bf7ded05903faa51", 
        measurementId: "G-H4HSEM39X5" 
      };
      // =========================================
    
      // Initialize Firebase App
      const app = initializeApp(firebaseConfig);
      const database = getDatabase(app); 
      const auth = getAuth(app); // Initialize Auth

      // --- Make Firebase functions globally accessible ---
      // Needed so your separate, non-module calculator script can use them.
      window.firebaseDb = database;       
      window.firebaseDbRef = ref;       
      window.firebaseDbSet = set;         
      window.firebaseDbGet = get;         
      window.firebaseDbRemove = remove;   
      // *** Export Auth functions ***
      window.firebaseAuth = auth; 
      window.firebaseOnAuthStateChanged = onAuthStateChanged; 
      window.firebaseGoogleAuthProvider = GoogleAuthProvider; 
      window.firebaseSignInWithPopup = signInWithPopup;
      window.firebaseSignOut = signOut; 

      // Signal that Firebase is ready for the main script
      console.log("Firebase Initialized (v9+ Modular with Auth)"); 
      document.dispatchEvent(new Event('firebaseReady')); 
    </script>
    ```

This block includes the necessary imports for Google Auth and makes the required functions available globally under the `window.` object (like `window.firebaseAuth`, `window.firebaseOnAuthStateChanged`, etc.) so your main script can call them.

Let me know once you have added this script block, and we can proceed to **Step 3: Modifying the Main Calculator Script**.

    <script>
  document.addEventListener('firebaseReady', async () => { 
        // --- DOM Element References ---
        const energyTypeSelect = document.getElementById('energy-type');
        const energyPoolsContainer = document.getElementById('energy-pools-container');
        const slidersGrid = document.getElementById('sliders-grid');
        const energyPoolTemplate = document.getElementById('energy-pool-template');
        const energySliderTemplate = document.getElementById('energy-slider-template');
        const calculateBtn = document.getElementById('calculate-btn');
        const resultDiv = document.getElementById('result');
        const resultValueEl = document.getElementById('result-value');
        const resultTotalEnergyUsedEl = document.getElementById('result-total-energy-used');
        const resultTotalExtraDamageEl = document.getElementById('result-total-extra-damage');
        const resultScientificEl = document.getElementById('result-scientific');
        const resultWordsEl = document.getElementById('result-words');
        const equationDisplayEl = document.getElementById('equation-display');
        const loadingDiv = document.getElementById('loading');
        const messageArea = document.getElementById('message-area');
        const dynamicModifiersContainer = document.getElementById('dynamic-modifiers-container');
        const addDynamicBoxBtn = document.getElementById('add-dynamic-box');
        const baseDamageInput = document.getElementById('base-damage');
        const baseMultiplierInput = document.getElementById('base-multiplier');
        const formMultiplierInput = document.getElementById('form-multiplier'); // Main display, now readonly
        const attackCompressionPointsInput = document.getElementById('attack-compression-points');
        const statsPanel = document.getElementById('stats-panel');
        const statsPanelHeader = document.getElementById('stats-panel-header');
        const statCurrentEnergyEl = document.getElementById('stat-current-energy');
        const statTotalDamageEl = document.getElementById('stat-total-damage');
        const statTotalEnergySpentEl = document.getElementById('stat-total-energy-spent');
        const statAttackCountEl = document.getElementById('stat-attack-count');
        const statHighestDamageEl = document.getElementById('stat-highest-damage');
        const resetAttackCountBtn = document.getElementById('reset-attack-count-btn');
        const kaiokenSection = document.getElementById('kaioken-section');
        const kaiokenCheckbox = document.getElementById('kaioken-checkbox');
        const kaiokenDetails = document.getElementById('kaioken-details');
        const maxHealthInput = document.getElementById('max-health');
        const kaiokenStrainInput = document.getElementById('kaioken-strain');
        const currentHealthEl = document.getElementById('current-health');
        const regenHealthBtn = document.getElementById('regen-health-btn');
        const saveBtn = document.getElementById('save-state-btn');
        const loadBtn = document.getElementById('load-state-btn');
        const clearBtn = document.getElementById('clear-state-btn');
        const superAttackBtn = document.getElementById('super-attack-btn');
        const ultimateAttackBtn = document.getElementById('ultimate-attack-btn');
        const attackStatusMessage = document.getElementById('attack-status-message');
        // Tab Switching References
        const showCharacterStatsBtn = document.getElementById('show-character-stats-btn');
        const characterStatsScreen = document.getElementById('character-stats-screen');
        const mainCalculatorContent = document.getElementById('main-calculator-content');
        const mainTitle = document.querySelector('h1.text-3xl');
        // Character Stats Input References
        const characterNameInput = document.getElementById('character-name');
        const charBaseHealthInput = document.getElementById('char-base-health');
        const charBaseMultiplierInput = document.getElementById('char-base-multiplier');
        const charVitalityInput = document.getElementById('char-vitality');
        const charSoulPowerInput = document.getElementById('char-soul-power');
        const charSoulHpInput = document.getElementById('char-soul-hp');
        const charBaseAcInput = document.getElementById('char-base-ac'); // New
        const charBaseTrInput = document.getElementById('char-base-tr'); // New
        // Ryoko Mode References
        const ryokoCheckbox = document.getElementById('ryoko-checkbox');
        const ryokoEquationContainer = document.getElementById('ryoko-equation-input-container');
        const ryokoEquationInput = document.getElementById('ryoko-equation-input');
        // Form Creator References
        const formNameInput = document.getElementById('formNameInput');
        const formEnergyTypeSelect = document.getElementById('formEnergyTypeSelect');
        const formFormMultiplierInput = document.getElementById('formFormMultiplierInput');
        const formPoolMaxMultiplierInput = document.getElementById('formPoolMaxMultiplierInput');
        const formAffectsResistancesCheckbox = document.getElementById('formAffectsResistancesCheckbox');
        const formResistanceBonusInputsDiv = document.getElementById('formResistanceBonusInputs');
        const formAcBonusInput = document.getElementById('formAcBonusInput');
        const formTrueResistanceBonusInput = document.getElementById('formTrueResistanceBonusInput');
        const addFormButton = document.getElementById('addFormButton');
        // Form List Container
        const formListContainer = document.getElementById('formListContainer'); // <<< Make sure this exists in HTML
        // Stats Panel AC/TR Displays
        const statFormAcBonusEl = document.getElementById('stat-form-ac-bonus');
        const statFormTrBonusEl = document.getElementById('stat-form-tr-bonus');
        const statTotalAcEl = document.getElementById('stat-total-ac');
        const statTotalTrEl = document.getElementById('stat-total-tr');


        // --- Global State & Constants ---
        const FIREBASE_SAVE_PATH_BASE = 'calculatorStates';
        let currentUser = null; // Will hold user info (like uid) when signed in
        let totalDamageDealt = 0, totalEnergySpent = 0, attackCount = 0, highestDamage = 0;
        const LOCAL_STORAGE_KEY = 'energyCalculatorState_v1.3_forms'; // Incremented version
        let poolAnimationTimeoutId = null;
        const ALL_ENERGY_TYPES = ['ki', 'nen', 'chakra', 'magic', 'cursed', 'reiatsu', 'haki', 'alchemy', 'nature', 'force'];
        const ALL_FORM_ENERGY_TYPES = ["None", ...ALL_ENERGY_TYPES]; // For form creator dropdown
        let dynamicModifierCount = 0;
        let activeAttacks = {};
        const ATTACK_RESERVE_COLOR = '#fed7aa'; // orange-200
        const SLIDER_TRACK_COLOR = '#e5e7eb'; // gray-200
        // Default Ryoko Equation String (commas removed for math.js)
        const DEFAULT_RYOKO_EQUATION = '((11250000 * 19 * 10 * 25 * 5 * 10 * 5 * 470) / 2) * 110';
        // Form System State
        let characterForms = []; // Holds all defined form objects
        let calculatorState = {
            selectedForms: {
                'ki': 'none', 'nen': 'none', 'chakra': 'none', 'magic': 'none', 'cursed': 'none',
                'reiatsu': 'none', 'haki': 'none', 'alchemy': 'none', 'nature': 'none', 'force': 'none'
            }
            // currentEnergyType is implicitly energyTypeSelect.value
        };


        const ENERGY_TYPE_DETAILS = {
            ki:      { name: 'Ki',      color: 'ki',      colorDark: 'ki-dark',      gradientTo: 'to-orange-100', focusRing: 'focus:ring-ki-focus',      staticGlow: 'static-glow-ki',      pulseGlow: 'animate-pulse-glow-ki',      border: 'border-l-ki' },
            nen:      { name: 'Nen',      color: 'nen',      colorDark: 'nen-dark',      gradientTo: 'to-blue-100',   focusRing: 'focus:ring-nen-focus',      staticGlow: 'static-glow-nen',      pulseGlow: 'animate-pulse-glow-nen',      border: 'border-l-nen' },
            chakra:   { name: 'Chakra',   color: 'chakra',   colorDark: 'chakra-dark',   gradientTo: 'to-purple-100', focusRing: 'focus:ring-chakra-focus',   staticGlow: 'static-glow-chakra',   pulseGlow: 'animate-pulse-glow-chakra',   border: 'border-l-chakra' },
            magic:    { name: 'Magic',    color: 'magic',    colorDark: 'magic-dark',    gradientTo: 'to-teal-100',   focusRing: 'focus:ring-magic-focus',    staticGlow: 'static-glow-magic',    pulseGlow: 'animate-pulse-glow-magic',    border: 'border-l-magic' },
            cursed:   { name: 'Cursed',   color: 'cursed',   colorDark: 'cursed-dark',   gradientTo: 'to-red-100',    focusRing: 'focus:ring-cursed-focus',   staticGlow: 'static-glow-cursed',   pulseGlow: 'animate-pulse-glow-cursed',   border: 'border-l-cursed' },
            reiatsu: { name: 'Reiatsu', color: 'reiatsu', colorDark: 'reiatsu-dark', gradientTo: 'to-slate-100',  focusRing: 'focus:ring-reiatsu-focus', staticGlow: 'static-glow-reiatsu', pulseGlow: 'animate-pulse-glow-reiatsu', border: 'border-l-reiatsu' },
            haki:     { name: 'Haki',     color: 'haki',     colorDark: 'haki-dark',     gradientTo: 'to-gray-100',   focusRing: 'focus:ring-haki-focus',     staticGlow: 'static-glow-haki',     pulseGlow: 'animate-pulse-glow-haki',     border: 'border-l-haki' },
            alchemy: { name: 'Alchemy', color: 'alchemy', colorDark: 'alchemy-dark', gradientTo: 'to-amber-100',  focusRing: 'focus:ring-alchemy-focus', staticGlow: 'static-glow-alchemy', pulseGlow: 'animate-pulse-glow-alchemy', border: 'border-l-alchemy' },
            nature:   { name: 'Nature',   color: 'nature',   colorDark: 'nature-dark',   gradientTo: 'to-lime-100',   focusRing: 'focus:ring-nature-focus',   staticGlow: 'static-glow-nature',   pulseGlow: 'animate-pulse-glow-nature',   border: 'border-l-nature' },
            force:    { name: 'Force',    color: 'force',    colorDark: 'force-dark',    gradientTo: 'to-fuchsia-100',focusRing: 'focus:ring-force-focus',    staticGlow: 'static-glow-force',    pulseGlow: 'animate-pulse-glow-force',    border: 'border-l-force' },
        };

        // --- Utility Functions ---

        function safeParseFloat(value, defaultValue = 0) { if (typeof value !== 'string' && typeof value !== 'number') return defaultValue; const num = parseFloat(String(value).replace(/,/g, '')); return isNaN(num) ? defaultValue : num; }
        function formatSimpleNumber(num) { if (typeof num !== 'number' || isNaN(num)) return '0'; try { const options = { maximumFractionDigits: 2 }; return num.toLocaleString('en-US', options); } catch (e) { return num.toString(); } }
        function showMessage(text, type = 'info') { messageArea.textContent = text; messageArea.className = 'mb-4 p-3 rounded-md text-sm border animate__animated'; messageArea.classList.remove('hidden', 'animate__fadeIn', 'animate__shakeX'); let animationClass = 'animate__fadeIn'; switch (type) { case 'error': messageArea.classList.add('bg-error-light', 'text-error-dark', 'border-error'); animationClass = 'animate__shakeX'; break; case 'success': messageArea.classList.add('bg-success-light', 'text-success-dark', 'border-success'); break; default: messageArea.classList.add('bg-blue-100', 'text-blue-800', 'border-blue-300'); break; } messageArea.classList.add(animationClass); messageArea.addEventListener('animationend', () => { messageArea.classList.remove('animate__animated', animationClass); }, { once: true }); setTimeout(() => { messageArea.classList.add('hidden'); }, 5000); }
        function showLoading(isLoading) { loadingDiv.classList.toggle('hidden', !isLoading); if(isLoading) resultDiv.classList.add('hidden'); calculateBtn.disabled = isLoading; calculateBtn.classList.toggle('opacity-50', isLoading); calculateBtn.classList.toggle('cursor-not-allowed', isLoading); }
        function triggerAnimation(element, animationName, duration = 800) { if (!element || !animationName) return; const animateCSSBase = 'animate__animated'; const animationClass = animationName.startsWith('animate__') ? animationName : `animate__${animationName}`; const classesToAdd = [animateCSSBase, animationClass]; element.classList.remove(...classesToAdd); void element.offsetWidth; element.classList.add(...classesToAdd); element.addEventListener('animationend', () => { element.classList.remove(...classesToAdd); }, { once: true }); }
        function formatStatNumber(num) { if (typeof num !== 'number' || isNaN(num)) return '0'; const absNum = Math.abs(num); if (absNum >= 1e9) { return num.toExponential(2); } if (absNum >= 1e6) { let shortNum = num / 1e6; let formatted = shortNum.toLocaleString('en-US', { minimumFractionDigits: absNum < 10e6 ? 2 : 1, maximumFractionDigits: absNum < 10e6 ? 2 : 1 }); formatted = formatted.replace(/\.0$/, ''); return formatted + 'M'; } if (absNum >= 1e3) { let shortNum = num / 1e3; let formatted = shortNum.toLocaleString('en-US', { minimumFractionDigits: absNum < 10e3 ? 2 : 1, maximumFractionDigits: absNum < 10e3 ? 2 : 1 }); formatted = formatted.replace(/\.0$/, ''); return formatted + 'K'; } if (absNum < 1000) { return num.toLocaleString('en-US', { maximumFractionDigits: 2 }); } return num.toLocaleString('en-US'); }
        function parseFormattedNumber(str) { if (typeof str !== 'string' && typeof str !== 'number') return 0; if (typeof str === 'number') return isNaN(str) ? 0 : str; str = str.trim().toUpperCase().replace(/,/g, ''); if (str.includes('E')) { const num = parseFloat(str); return isNaN(num) ? 0 : num; } const lastChar = str.slice(-1); const numPart = parseFloat(str.slice(0, -1)); const fullNum = parseFloat(str); if (!isNaN(fullNum) && !['K', 'M', 'B', 'T', 'Q'].includes(lastChar)) { return fullNum; } if (isNaN(numPart) && ['K', 'M', 'B', 'T', 'Q'].includes(lastChar)) return 0; switch (lastChar) { case 'K': return numPart * 1e3; case 'M': return numPart * 1e6; case 'B': return numPart * 1e9; case 'T': return numPart * 1e12; case 'Q': return numPart * 1e15; default: return isNaN(fullNum) ? 0 : fullNum; } }
        function escapeHtml(unsafe) { if (typeof unsafe !== 'string') return ''; return unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;"); }


        // --- Energy Pool Logic ---

        function getEnergyElements(type) {
            if (!ALL_ENERGY_TYPES.includes(type)) {
                console.error("Invalid energy type requested:", type);
                return null;
            }
            const poolDiv = document.getElementById(`${type}-pool`);
            if (!poolDiv) {
                // Don't log error if pool just hasn't been generated yet during init
                // console.warn(`Pool div not found for type: ${type}`);
                return null;
            }
            return {
                poolDiv: poolDiv,
                baseMaxEnergyEl: poolDiv.querySelector(`#${type}-base-max-energy`),
                maxMultiplierEl: poolDiv.querySelector(`#${type}-max-multiplier`), // This is the POOL Max Multiplier
                totalEnergyEl: poolDiv.querySelector(`#${type}-total-energy`),
                currentEnergyEl: poolDiv.querySelector(`#${type}-current-energy`),
                damagePerPowerEl: poolDiv.querySelector(`#${type}-damage-per-power`),
                regenPercentEl: poolDiv.querySelector(`#${type}-regen-percent`),
                sliderSection: document.getElementById(`${type}-slider-section`), // In sliders container
                energySlider: document.getElementById(`${type}-energy-slider`),     // In sliders container
                sliderValueDisplay: document.getElementById(`${type}-slider-value-display`), // In sliders container
                formSelectContainer: poolDiv.querySelector('.form-select-container'), // NEW
                formSelect: poolDiv.querySelector('.form-select'),                     // NEW
            };
        }
        function calculateBaseMaxEnergy(type) {
            const baseHp = safeParseFloat(charBaseHealthInput?.value, 0);
            const vitality = safeParseFloat(charVitalityInput?.value, 0);
            const soulPower = safeParseFloat(charSoulPowerInput?.value, 0);
            const soulHp = safeParseFloat(charSoulHpInput?.value, 0);
            let baseMax = 0;
            switch (type) {
                case 'nen': baseMax = vitality * soulHp; break;
                case 'chakra': baseMax = vitality * (0.5 * soulHp + 0.5 * soulPower); break;
                case 'reiatsu': baseMax = soulHp * vitality * soulPower; break;
                case 'cursed': baseMax = soulPower * soulHp; break;
                case 'ki': case 'haki': baseMax = vitality * (soulPower + soulHp); break;
                case 'alchemy': baseMax = soulPower * baseHp; break;
                case 'nature': baseMax = vitality * (soulHp + baseHp + soulPower); break;
                case 'magic': baseMax = soulPower * (soulHp + baseHp + vitality); break;
                case 'force': baseMax = soulHp + vitality; break;
                default: console.warn(`Unknown energy type for base max calculation: ${type}`); baseMax = 0;
            }
            return Math.max(0, baseMax);
        }
        function updateSliderVisibility(type) {
            const els = getEnergyElements(type);
            if (els?.totalEnergyEl && els.sliderSection) {
                const totalEnergy = parseFormattedNumber(els.totalEnergyEl.textContent);
                const shouldShow = totalEnergy > 0;
                els.sliderSection.classList.toggle('hidden', !shouldShow);
                if (!shouldShow && els.energySlider) {
                    els.energySlider.value = 0;
                    updateSingleSliderDisplay(type);
                }
            }
        }
        function calculateAndResetEnergy(type) {
            const els = getEnergyElements(type);
            if (!els?.baseMaxEnergyEl || !els?.maxMultiplierEl || !els?.totalEnergyEl || !els?.currentEnergyEl) {
                // console.error(`Elements missing for energy calculation/reset: ${type}`);
                return 0; // Return 0 if elements not ready
            }

            const baseMaxEnergy = calculateBaseMaxEnergy(type);
            els.baseMaxEnergyEl.textContent = formatStatNumber(baseMaxEnergy);

            // Read Pool Max Multiplier DIRECTLY from the input (can be user-edited or form-set)
            const poolMaxMultiplier = safeParseFloat(els.maxMultiplierEl.value, 1);

            // Read Character Base Multiplier (potentially overridden by Ryoko)
            const characterBaseMultiplier = safeParseFloat(charBaseMultiplierInput.value, 1); // Reads directly from input

            const totalEnergy = baseMaxEnergy * characterBaseMultiplier * poolMaxMultiplier;
            els.totalEnergyEl.textContent = formatStatNumber(totalEnergy);
            els.currentEnergyEl.textContent = formatStatNumber(totalEnergy); // Reset current to new total

            updateSliderVisibility(type);
            updateSingleSliderDisplay(type);
            return totalEnergy;
        }
        function regenerateEnergy(type) { const els = getEnergyElements(type); if (!els?.totalEnergyEl || !els?.currentEnergyEl || !els?.regenPercentEl) { console.error(`Elements missing for energy regeneration: ${type}`); return; } const totalEnergy = parseFormattedNumber(els.totalEnergyEl.textContent); let currentEnergy = parseFormattedNumber(els.currentEnergyEl.textContent); const regenPercent = safeParseFloat(els.regenPercentEl.value, 0); if (totalEnergy <= 0) { showMessage('Total Energy must be positive (check character stats and multiplier) to regenerate.', 'error'); return; } if (regenPercent <= 0) { showMessage('Regen Rate must be positive.', 'error'); return; } const regenAmount = totalEnergy * (regenPercent / 100); let newEnergy = Math.min(currentEnergy + regenAmount, totalEnergy); els.currentEnergyEl.textContent = formatStatNumber(newEnergy); showMessage(`${formatStatNumber(regenAmount)} ${type} regenerated. Current: ${formatStatNumber(newEnergy)}`, 'success'); triggerAnimation(els.currentEnergyEl, 'flash-green'); updateSingleSliderDisplay(type); updateStatsDisplay(); }


        // --- Kaioken Styling ---
        function applyKaiokenStyle() { if (!statsPanel || !statsPanelHeader) return; statsPanel.classList.remove('border-stats-border'); statsPanel.classList.add('border-kaioken-border', 'animate-kaioken-glow'); statsPanelHeader.classList.remove('text-stats-header'); statsPanelHeader.classList.add('text-kaioken-header'); }
        function removeKaiokenStyle() { if (!statsPanel || !statsPanelHeader) return; statsPanel.classList.add('border-stats-border'); statsPanel.classList.remove('border-kaioken-border', 'animate-kaioken-glow'); statsPanelHeader.classList.add('text-stats-header'); statsPanelHeader.classList.remove('text-kaioken-header'); }
        // --- Health Update ---
        function updateCurrentHealthDisplay() { if (!currentHealthEl || !maxHealthInput) return; const maxHealth = safeParseFloat(maxHealthInput.value, 0); let currentHealth = parseFormattedNumber(currentHealthEl.textContent); if ((energyTypeSelect.value === 'ki' && kaiokenCheckbox.checked) || currentHealth === -1 || currentHealth > maxHealth || currentHealthEl.textContent.trim() === '' || currentHealthEl.textContent === '0') { currentHealthEl.textContent = formatStatNumber(maxHealth); } }
        function regenerateHealth() { if (!maxHealthInput || !currentHealthEl) { console.error("Health elements missing for regeneration."); return; } const maxHealth = safeParseFloat(maxHealthInput.value, 0); currentHealthEl.textContent = formatStatNumber(maxHealth); showMessage('Health fully regenerated!', 'success'); triggerAnimation(currentHealthEl, 'flash-green'); }


        // --- Show/Hide Logic & Pool Animation ---
        function showSelectedEnergyPool() {
            const selectedType = energyTypeSelect.value;
            const details = ENERGY_TYPE_DETAILS[selectedType];
            let newlyVisiblePool = null;

            if (poolAnimationTimeoutId) {
                clearTimeout(poolAnimationTimeoutId);
                poolAnimationTimeoutId = null;
            }

            // Hide all pools and form selects first, remove glows
            ALL_ENERGY_TYPES.forEach(type => {
                const els = getEnergyElements(type);
                const typeDetails = ENERGY_TYPE_DETAILS[type];
                if (els?.poolDiv && typeDetails) {
                    els.poolDiv.classList.remove(typeDetails.pulseGlow, typeDetails.staticGlow, 'animate__animated', 'animate__fadeIn');
                    els.poolDiv.style.display = 'none';
                    if (els.formSelectContainer) {
                        els.formSelectContainer.classList.add('hidden'); // Hide form select too
                    }
                }
            });

            // Calculate and reset energy for the selected type
            calculateAndResetEnergy(selectedType);

            // Show the selected pool and its form select
            const poolToShowEls = getEnergyElements(selectedType);
            if (poolToShowEls?.poolDiv && details) {
                poolToShowEls.poolDiv.style.display = 'block';
                newlyVisiblePool = poolToShowEls.poolDiv;
                poolToShowEls.poolDiv.classList.add('animate__animated', 'animate__fadeIn');
                poolToShowEls.poolDiv.classList.add(details.pulseGlow);
                poolToShowEls.poolDiv.addEventListener('animationend', (e) => {
                    if (e.animationName === 'fadeIn') {
                        poolToShowEls.poolDiv.classList.remove('animate__animated', 'animate__fadeIn');
                    }
                } , { once: true });

                // Show form select only if forms exist for this type
                if (poolToShowEls.formSelectContainer && poolToShowEls.formSelect && poolToShowEls.formSelect.options.length > 1) { // More than just "None"
                    poolToShowEls.formSelectContainer.classList.remove('hidden');
                }


                // Animation timeout for glow
                poolAnimationTimeoutId = setTimeout(() => {
                    const currentSelectedType = energyTypeSelect.value;
                    const stillSelectedPoolEls = getEnergyElements(currentSelectedType);
                    const stillSelectedDetails = ENERGY_TYPE_DETAILS[currentSelectedType];
                    if (stillSelectedPoolEls?.poolDiv && stillSelectedDetails && currentSelectedType === selectedType) {
                        stillSelectedPoolEls.poolDiv.classList.remove(stillSelectedDetails.pulseGlow);
                        stillSelectedPoolEls.poolDiv.classList.add(stillSelectedDetails.staticGlow);
                    }
                    poolAnimationTimeoutId = null;
                }, 5000);
            }

            // Kaioken visibility (unchanged)
            if (kaiokenSection) {
                if (selectedType === 'ki') {
                    kaiokenSection.classList.remove('hidden');
                    if (kaiokenCheckbox.checked) {
                        kaiokenDetails.classList.remove('hidden');
                        updateCurrentHealthDisplay();
                    }
                } else {
                    kaiokenSection.classList.add('hidden');
                    if (kaiokenCheckbox.checked) {
                        kaiokenCheckbox.checked = false;
                        kaiokenDetails.classList.add('hidden');
                        removeKaiokenStyle();
                    }
                }
            }

            // Update other UI elements based on the new context
            updateAttackButtonStates(selectedType);
            updateSliderLimitAndStyle(selectedType);
            applyActiveFormEffects(); // Apply form effects for the newly selected type
            updateStatsDisplay(); // Update general stats display
            updateEquationDisplay(); // Update equation display

        }


        // --- Attack Logic ---
        function updateAttackButtonStates(type) { const currentAttack = activeAttacks[type] || null; superAttackBtn.classList.toggle('active', currentAttack === 'super'); ultimateAttackBtn.classList.toggle('active', currentAttack === 'ultimate'); let statusClasses = 'text-xs mt-2 min-h-[1.25rem]'; if (currentAttack === 'super') { attackStatusMessage.textContent = `Super Attack active for ${ENERGY_TYPE_DETAILS[type]?.name || type}. Slider limited to 95%.`; attackStatusMessage.className = `${statusClasses} text-blue-600`; } else if (currentAttack === 'ultimate') { attackStatusMessage.textContent = `Ultimate Attack active for ${ENERGY_TYPE_DETAILS[type]?.name || type}. Slider limited to 90%.`; attackStatusMessage.className = `${statusClasses} text-purple-600`; } else { attackStatusMessage.textContent = ''; attackStatusMessage.className = `${statusClasses} text-gray-500`; } }
        function updateSliderLimitAndStyle(type) { const els = getEnergyElements(type); if (!els?.energySlider) return; const slider = els.energySlider; const activeAttack = activeAttacks[type] || null; let limitPercent = 100; let gradientStyle = `linear-gradient(to right, ${SLIDER_TRACK_COLOR} 100%, ${ATTACK_RESERVE_COLOR} 100%)`; if (activeAttack === 'super') { limitPercent = 95; gradientStyle = `linear-gradient(to right, ${SLIDER_TRACK_COLOR} ${limitPercent}%, ${ATTACK_RESERVE_COLOR} ${limitPercent}%)`; } else if (activeAttack === 'ultimate') { limitPercent = 90; gradientStyle = `linear-gradient(to right, ${SLIDER_TRACK_COLOR} ${limitPercent}%, ${ATTACK_RESERVE_COLOR} ${limitPercent}%)`; } slider.style.background = gradientStyle; if (parseInt(slider.value) > limitPercent) { slider.value = limitPercent; } updateSingleSliderDisplay(type); }
        function handleAttackButtonClick(event) { const button = event.currentTarget; const attackType = button.dataset.attackType; const selectedEnergyType = energyTypeSelect.value; const currentAttackForType = activeAttacks[selectedEnergyType] || null; const newAttackState = (currentAttackForType === attackType) ? null : attackType; activeAttacks[selectedEnergyType] = newAttackState; updateAttackButtonStates(selectedEnergyType); updateSliderLimitAndStyle(selectedEnergyType); triggerAnimation(button, 'pulse'); }


        // --- Dynamic Modifiers Logic ---
        function addDynamicModifier(modifierData = null) { dynamicModifierCount++; const modifierId = `dynamic-modifier-${dynamicModifierCount}`; const newModifierDiv = document.createElement('div'); const initialType = modifierData?.type || 'additive'; const initialValue = modifierData?.value || '0'; const initialName = modifierData?.name || ''; const isActiveAdditive = initialType === 'additive'; const boxClasses = `dynamic-box p-4 mt-3 border rounded-md border-l-4 relative transition-all duration-300 ease-in-out animate__animated animate__bounceIn ${isActiveAdditive ? 'additive bg-success-light border-success' : 'multiplicative bg-ki/10 border-ki'}`; newModifierDiv.className = boxClasses; newModifierDiv.id = modifierId; newModifierDiv.innerHTML = ` <div class="absolute top-2 right-2"> <button class="remove-dynamic-box bg-error text-white rounded-md shadow-sm w-6 h-6 flex items-center justify-center text-xs hover:bg-error-dark focus:outline-none focus:ring-2 focus:ring-error focus:ring-offset-1 transition-transform active:scale-95" aria-label="Remove this modifier" data-target="${modifierId}">×</button> </div> <div class="modifier-type-selector flex gap-2 mb-3 border-b pb-2"> <div class="modifier-type-option additive ${isActiveAdditive ? 'active' : ''} flex-1 p-2 text-center border rounded-md cursor-pointer transition-all duration-300 ease-in-out text-sm" data-value="additive" tabindex="0" role="radio" aria-checked="${isActiveAdditive}"> <input type="radio" name="modifier-type-${modifierId}" value="additive" class="sr-only" ${isActiveAdditive ? 'checked' : ''}> Additive (+) </div> <div class="modifier-type-option multiplicative ${!isActiveAdditive ? 'active' : ''} flex-1 p-2 text-center border rounded-md cursor-pointer transition-all duration-300 ease-in-out text-sm" data-value="multiplicative" tabindex="0" role="radio" aria-checked="${!isActiveAdditive}"> <input type="radio" name="modifier-type-${modifierId}" value="multiplicative" class="sr-only" ${!isActiveAdditive ? 'checked' : ''}> Multiplier (×) </div> </div> <div class="grid grid-cols-1 sm:grid-cols-2 gap-3"> <div> <label for="modifier-name-${modifierId}" class="lbl">Modifier Name:</label> <input type="text" id="modifier-name-${modifierId}" placeholder="e.g., Buff" value="${escapeHtml(initialName)}" class="modifier-name-input w-full p-1.5 border border-gray-300 rounded-md focus:ring-1 focus:ring-success focus:border-transparent text-sm"> </div> <div> <label for="modifier-value-${modifierId}" class="lbl">Value:</label> <input type="text" id="modifier-value-${modifierId}" placeholder="e.g., 50 or 1.2" value="${escapeHtml(initialValue)}" class="modifier-value-input w-full p-1.5 border border-gray-300 rounded-md focus:ring-1 focus:ring-success focus:border-transparent text-sm"> </div> </div>`; dynamicModifiersContainer.appendChild(newModifierDiv); addListenersToModifierBox(newModifierDiv); newModifierDiv.addEventListener('animationend', () => { newModifierDiv.classList.remove('animate__animated', 'animate__bounceIn'); }, { once: true }); }
        function addListenersToModifierBox(modifierDiv) { modifierDiv.querySelector('.remove-dynamic-box')?.addEventListener('click', function() { const targetBox = document.getElementById(this.dataset.target); if (targetBox) { targetBox.classList.add('animate__animated', 'animate__bounceOut'); targetBox.addEventListener('animationend', () => { targetBox.remove(); updateEquationDisplay(); }, { once: true }); } else { updateEquationDisplay(); } }); modifierDiv.querySelectorAll('.modifier-type-option').forEach(option => { option.addEventListener('click', function() { const box = this.closest('.dynamic-box'); const value = this.dataset.value; box.querySelectorAll('input[type="radio"]').forEach(radio => radio.checked = (radio.value === value)); box.querySelectorAll('.modifier-type-option').forEach(opt => { const isActive = opt.dataset.value === value; opt.classList.toggle('active', isActive); opt.setAttribute('aria-checked', isActive); }); box.classList.remove('additive', 'multiplicative', 'bg-success-light', 'border-success', 'bg-ki/10', 'border-ki'); box.classList.add(value === 'additive' ? 'additive' : 'multiplicative'); box.classList.add(value === 'additive' ? 'bg-success-light' : 'bg-ki/10'); box.classList.add(value === 'additive' ? 'border-success' : 'border-ki'); updateEquationDisplay(); }); option.addEventListener('keydown', function(e) { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); this.click(); } }); }); const valueInput = modifierDiv.querySelector('.modifier-value-input'); if (valueInput) { valueInput.addEventListener('input', updateEquationDisplay); valueInput.addEventListener('change', updateEquationDisplay); } const nameInput = modifierDiv.querySelector('.modifier-name-input'); if (nameInput) { nameInput.addEventListener('input', updateEquationDisplay); nameInput.addEventListener('change', updateEquationDisplay); } }


        // --- Stats Update Logic ---
        function updateStatsDisplay() {
            // Standard stats
            if (statTotalDamageEl) statTotalDamageEl.textContent = formatStatNumber(totalDamageDealt);
            if (statTotalEnergySpentEl) statTotalEnergySpentEl.textContent = formatStatNumber(totalEnergySpent);
            if (statHighestDamageEl) statHighestDamageEl.textContent = formatStatNumber(highestDamage);
            if (statAttackCountEl) statAttackCountEl.textContent = attackCount.toLocaleString();

            // Current Energy
            const selectedType = energyTypeSelect.value;
            const els = getEnergyElements(selectedType);
            if (statCurrentEnergyEl && els?.currentEnergyEl) {
                statCurrentEnergyEl.textContent = els.currentEnergyEl.textContent || '0';
            } else if (statCurrentEnergyEl) {
                statCurrentEnergyEl.textContent = 'N/A';
            }

            // AC / TR - Read base from inputs, apply form bonuses from state, calculate total
            const baseAC = safeParseFloat(charBaseAcInput?.value, 0);
            const baseTR = safeParseFloat(charBaseTrInput?.value, 0);

            // Get form bonuses (already updated in calculatorState by applyActiveFormEffects)
            let formAcBonus = calculatorState.appliedAcBonus || 0;
            let formTrBonus = calculatorState.appliedTrueResistanceBonus || 0;

            // Display bonuses and totals
            if (statFormAcBonusEl) statFormAcBonusEl.textContent = formatSimpleNumber(formAcBonus);
            if (statFormTrBonusEl) statFormTrBonusEl.textContent = formatSimpleNumber(formTrBonus);
            if (statTotalAcEl) statTotalAcEl.textContent = formatSimpleNumber(baseAC + formAcBonus);
            if (statTotalTrEl) statTotalTrEl.textContent = formatSimpleNumber(baseTR + formTrBonus);
        }


        // --- Calculation Logic ---
        function updateSingleSliderDisplay(type) { const els = getEnergyElements(type); if (!els?.energySlider || !els?.sliderValueDisplay || !els?.currentEnergyEl || !els?.damagePerPowerEl) { return; } const percentSpan = els.sliderValueDisplay.querySelector('.slider-percent-value'); const detailsSpan = els.sliderValueDisplay.querySelector('.slider-details-value'); if (!percentSpan || !detailsSpan) { console.error("Slider display spans not found for", type); return; } const sliderPercent = parseInt(els.energySlider.value); const currentEnergy = parseFormattedNumber(els.currentEnergyEl.textContent); const damagePerPower = safeParseFloat(els.damagePerPowerEl.value, 1); const activeAttack = activeAttacks[type] || null; let limitPercent = 100; if (activeAttack === 'super') limitPercent = 95; else if (activeAttack === 'ultimate') limitPercent = 90; const effectivePercent = Math.min(sliderPercent, limitPercent); const potentialEnergyUsed = currentEnergy * (effectivePercent / 100); const actualEnergyUsed = Math.min(potentialEnergyUsed, currentEnergy); const extraDamage = actualEnergyUsed * damagePerPower; percentSpan.textContent = `${sliderPercent}%`; detailsSpan.textContent = `(E: ${formatStatNumber(actualEnergyUsed)}, D: ${formatStatNumber(extraDamage)})`; }
        function performCalculation() {
            showLoading(true);
            setTimeout(() => {
                let finalDamage = 0;
                let healthDepleted = false;
                try {
                    const baseDamage = safeParseFloat(baseDamageInput.value, 0);
                    const compressionPoints = safeParseFloat(attackCompressionPointsInput.value, 0);
                    const baseMultiplier = safeParseFloat(baseMultiplierInput.value, 1);
                    // Read the FORM multiplier from the READONLY input (updated by applyActiveFormEffects)
                    const formMultiplierVal = safeParseFloat(formMultiplierInput.value, 1);
                    const energyType = energyTypeSelect.value;

                    let baseDamagePart = baseDamage * baseMultiplier * formMultiplierVal; // Use formMultiplierVal

                    let compressionMultiplierValue = 1;
                    if (compressionPoints > 0) {
                        compressionMultiplierValue = Math.max(1, (compressionPoints * 1.5) + (Math.floor(compressionPoints / 10) * 3));
                    }
                    finalDamage = baseDamagePart * compressionMultiplierValue;

                    // Apply dynamic multiplicative factors
                    document.querySelectorAll('#dynamic-modifiers-container .dynamic-box').forEach(modifierDiv => {
                        const valueInput = modifierDiv.querySelector('.modifier-value-input');
                        const typeOption = modifierDiv.querySelector('.modifier-type-option.active');
                        if (valueInput && typeOption && typeOption.dataset.value === 'multiplicative') {
                            const modifierValue = safeParseFloat(valueInput.value, 1);
                            finalDamage *= modifierValue;
                        }
                    });

                    let totalEnergyUsedFromSliders = 0;
                    let totalExtraDamageFromEnergy = 0;
                    // Apply energy damage from sliders
                    ALL_ENERGY_TYPES.forEach(type => {
                        const els = getEnergyElements(type);
                        if (els?.energySlider && els.currentEnergyEl && els.damagePerPowerEl) {
                            const sliderPercent = safeParseFloat(els.energySlider.value, 0);
                            const activeAttack = activeAttacks[type] || null;
                            let limitPercent = 100;
                            if (activeAttack === 'super') limitPercent = 95;
                            else if (activeAttack === 'ultimate') limitPercent = 90;
                            const effectivePercent = Math.min(sliderPercent, limitPercent);

                            if (effectivePercent > 0) {
                                const currentEnergy = parseFormattedNumber(els.currentEnergyEl.textContent);
                                const damagePerPower = safeParseFloat(els.damagePerPowerEl.value, 1);
                                const energyUsedThisType = currentEnergy * (effectivePercent / 100);
                                const actualEnergyUsed = Math.min(energyUsedThisType, currentEnergy);
                                const extraDamageThisType = actualEnergyUsed * damagePerPower;

                                totalEnergyUsedFromSliders += actualEnergyUsed;
                                totalExtraDamageFromEnergy += extraDamageThisType;

                                // Deplete energy
                                let newCurrentEnergyThisType = Math.max(0, currentEnergy - actualEnergyUsed);
                                els.currentEnergyEl.textContent = formatStatNumber(newCurrentEnergyThisType);
                                if (newCurrentEnergyThisType < currentEnergy) {
                                    triggerAnimation(els.currentEnergyEl, 'flash-red');
                                }
                                updateSingleSliderDisplay(type); // Update display after depletion
                            }
                        }
                    });
                    finalDamage += totalExtraDamageFromEnergy;

                    // Apply dynamic additive factors
                    document.querySelectorAll('#dynamic-modifiers-container .dynamic-box').forEach(modifierDiv => {
                        const valueInput = modifierDiv.querySelector('.modifier-value-input');
                        const typeOption = modifierDiv.querySelector('.modifier-type-option.active');
                        if (valueInput && typeOption && typeOption.dataset.value === 'additive') {
                            const modifierValue = safeParseFloat(valueInput.value, 0);
                            finalDamage += modifierValue;
                        }
                    });

                    // Apply Kaioken Health Strain (unchanged)
                    healthDepleted = false;
                    if (energyType === 'ki' && kaiokenCheckbox.checked) {
                        const currentHealthVal = parseFormattedNumber(currentHealthEl.textContent);
                        if (currentHealthVal > 0) {
                            const maxHealth = safeParseFloat(maxHealthInput.value, 0);
                            const kaiokenStrainPercent = safeParseFloat(kaiokenStrainInput.value, 0);
                            if (maxHealth > 0 && kaiokenStrainPercent > 0) {
                                const strainCost = maxHealth * (kaiokenStrainPercent / 100);
                                let newHealth = Math.max(0, currentHealthVal - strainCost);
                                currentHealthEl.textContent = formatStatNumber(newHealth);
                                if (newHealth < currentHealthVal) {
                                    triggerAnimation(currentHealthEl, 'flash-red');
                                }
                                if (newHealth === 0) {
                                    healthDepleted = true;
                                }
                            }
                        }
                    }

                    // Update overall stats
                    totalDamageDealt += finalDamage;
                    totalEnergySpent += totalEnergyUsedFromSliders;
                    attackCount++;
                    if (finalDamage > highestDamage) {
                        highestDamage = finalDamage;
                    }
                    updateStatsDisplay(); // Update stats panel including AC/TR

                    // Display results
                    resultValueEl.textContent = formatSimpleNumber(finalDamage);
                    resultTotalEnergyUsedEl.textContent = formatStatNumber(totalEnergyUsedFromSliders);
                    resultTotalExtraDamageEl.textContent = formatStatNumber(totalExtraDamageFromEnergy);
                    displayAllFormats(finalDamage);
                    updateEquationDisplay(); // Update equation after everything
                    resultDiv.classList.remove('hidden', 'bg-error-light', 'border-error', 'text-error-dark');
                    resultDiv.classList.add('bg-success-light', 'border-success', 'text-success-dark');
                    resultDiv.classList.remove('animate__animated', 'animate__fadeInUp');
                    void resultDiv.offsetWidth;
                    resultDiv.classList.add('animate__animated', 'animate__fadeInUp');
                    resultDiv.querySelector('.result-title').className = 'result-title text-lg font-semibold mb-2 text-success-dark';
                    let successMsg = 'Calculation successful!';
                    if (healthDepleted) { successMsg += ' Warning: Health depleted by Kaioken strain!'; }
                    showMessage(successMsg, healthDepleted ? 'error' : 'success');

                } catch (error) {
                    console.error("Calculation Error:", error);
                    resultValueEl.textContent = 'Error';
                    resultTotalEnergyUsedEl.textContent = 'N/A';
                    resultTotalExtraDamageEl.textContent = 'N/A';
                    resultScientificEl.textContent = 'N/A';
                    resultWordsEl.textContent = 'Error';
                    equationDisplayEl.innerHTML = '<span class="text-error-dark">Error calculating equation.</span>';
                    resultDiv.classList.remove('hidden', 'bg-success-light', 'border-success', 'text-success-dark');
                    resultDiv.classList.add('bg-error-light', 'border-error', 'text-error-dark');
                    resultDiv.querySelector('.result-title').className = 'result-title text-lg font-semibold mb-2 text-error-dark';
                    showMessage(`Calculation failed: ${error.message || 'Unknown error'}`, 'error');
                } finally {
                    showLoading(false);
                }
            }, 50); // Short delay for loading indicator
        }


        // --- Number Formatting ---
        function displayAllFormats(damage) { try { resultScientificEl.textContent = damage.toExponential(2).replace(/e\+?(-?)/, ' x 10^$1'); } catch (e) { resultScientificEl.textContent = "Invalid"; console.error("Scientific notation error:", e); } try { resultWordsEl.textContent = convertNumberToWords(damage); } catch (e) { resultWordsEl.textContent = "Error: " + e.message; console.error("Number to words error:", e); } }
        function convertNumberToWords(number) { const units = ['', 'One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Eleven', 'Twelve', 'Thirteen', 'Fourteen', 'Fifteen', 'Sixteen', 'Seventeen', 'Eighteen', 'Nineteen']; const tens = ['', '', 'Twenty', 'Thirty', 'Forty', 'Fifty', 'Sixty', 'Seventy', 'Eighty', 'Ninety']; const scales = [ '', 'Thousand', 'Million', 'Billion', 'Trillion', 'Quadrillion', 'Quintillion', 'Sextillion', 'Septillion', 'Octillion', 'Nonillion', 'Decillion', 'Undecillion', 'Duodecillion', 'Tredecillion', 'Quattuordecillion', 'Quindecillion', 'Sexdecillion', 'Septendecillion', 'Octodecillion', 'Novemdecillion', 'Vigintillion', 'Unvigintillion', 'Duovigintillion', 'Tresvigintillion', 'Quattuorvigintillion', 'Quinvigintillion', 'Sesvigintillion', 'Septemvigintillion', 'Octovigintillion', 'Novemvigintillion', 'Trigintillion', 'Untrigintillion', 'Duotrigintillion', 'Trestrigintillion', 'Quattuortrigintillion', 'Quintrigintillion', 'Sestrigintillion', 'Septentrigintillion', 'Octotrigintillion', 'Noventrigintillion', 'Quadragintillion', 'Unquadragintillion', 'Duoquadragintillion', 'Tresquadragintillion', 'Quattuorquadragintillion', 'Quinquadragintillion', 'Sesquadragintillion', 'Septenquadragintillion', 'Octoquadragintillion', 'Novemquadragintillion', 'Quinquagintillion', 'Unquinquagintillion', 'Duoquinquagintillion', 'Tresquinquagintillion', 'Quattuorquinquagintillion', 'Quinquinquagintillion', 'Sesquinquagintillion', 'Septenquinquagintillion', 'Octoquinquagintillion', 'Novemquinquagintillion', 'Sexagintillion', 'Unsexagintillion', 'Duosexagintillion', 'Tresexagintillion', 'Quattuorsexagintillion', 'Quinsexagintillion', 'Sesexagintillion', 'Septensexagintillion', 'Octosexagintillion', 'Novemsexagintillion', 'Septuagintillion', 'Unseptuagintillion', 'Duoseptuagintillion', 'Tresseptuagintillion', 'Quattuorseptuagintillion', 'Quinseptuagintillion', 'Seseptuagintillion', 'Septenseptuagintillion', 'Octoseptuagintillion', 'Novemseptuagintillion', 'Octogintillion', 'Unoctogintillion', 'Duooctogintillion', 'Tresoctogintillion', 'Quattuoroctogintillion', 'Quinoctogintillion', 'Sexoctogintillion', 'Septemoctogintillion', 'Octooctogintillion', 'Novemoctogintillion', 'Nonagintillion', 'Unnonagintillion', 'Duononagintillion', 'Tresnonagintillion', 'Quattuornonagintillion', 'Quinnonagintillion', 'Senonagintillion', 'Septenonagintillion', 'Octononagintillion', 'Novenonagintillion', 'Centillion' ]; if (typeof number !== 'number' || !isFinite(number)) { return 'Invalid Number'; } if (number === 0) { return 'Zero'; } const MAX_SAFE_INTEGER_FOR_WORDS = BigInt("9".repeat((scales.length) * 3)); let numForCheck; try { numForCheck = number < 0 ? BigInt(Math.abs(Math.trunc(number))) : BigInt(Math.trunc(number)); } catch (e) { console.error("Error converting number to BigInt for size check:", number, e); return number.toExponential(2) + " (Extremely large)"; } if (numForCheck > MAX_SAFE_INTEGER_FOR_WORDS) { console.warn("Number too large for full word conversion, returning scientific."); return number.toExponential(2) + " (Too large for words)"; } let isNegative = number < 0; if (isNegative) number = -number; let integerPart; let fractionalPart = 0; try { const numStr = number.toLocaleString('en-US', { useGrouping: false, maximumFractionDigits: 20 }); const parts = numStr.split('.'); integerPart = BigInt(parts[0]); if (parts.length > 1) { fractionalPart = parseFloat('0.' + parts[1]); } } catch (e) { console.error("Error processing number for words:", number, e); return "Number too large or invalid format"; } let words = isNegative ? 'Negative ' : ''; function convertHundreds(num) { let word = ''; const h = Math.floor(num / 100); const r = num % 100; if (h > 0) { word += units[h] + ' Hundred'; } if (r > 0) { if (word !== '') word += ' '; if (r < 20) { word += units[r]; } else { const t = Math.floor(r / 10); const o = r % 10; word += tens[t]; if (o > 0) { word += '-' + units[o]; } } } return word; } if (integerPart === 0n) { if (fractionalPart === 0) words += 'Zero'; } else { let scaleIndex = 0; let tempWords = []; let currentInt = integerPart; while (currentInt > 0n) { if (scaleIndex >= scales.length) { console.error("Number exceeds defined scales during conversion:", number); return number.toExponential(2) + " (Too large for words)"; } const chunk = Number(currentInt % 1000n); if (chunk !== 0) { const chunkWords = convertHundreds(chunk); tempWords.push(chunkWords + (scaleIndex > 0 ? ' ' + scales[scaleIndex] : '')); } currentInt /= 1000n; scaleIndex++; } words += tempWords.reverse().filter(w => w.trim()).join(', '); } if (fractionalPart > 1e-9) { words += ' Point'; let fractionalStr = fractionalPart.toFixed(6).substring(2).replace(/0+$/, ''); if (fractionalStr.length > 0) { for (const digit of fractionalStr) { words += ' ' + (units[parseInt(digit)] || 'Zero'); } } else { words = words.replace(/ Point$/, ''); } } return words.trim(); }


        // --- State Management ---
        function gatherState() {
            const state = {
                baseDamage: baseDamageInput.value, baseMultiplier: baseMultiplierInput.value,
                // formMultiplier is readonly, no need to save its value explicitly
                attackCompressionPoints: attackCompressionPointsInput.value,
                selectedEnergyType: energyTypeSelect.value, sliderPercentages: {}, energyPools: {}, dynamicModifiers: [], activeAttacks: activeAttacks,
                kaiokenActive: kaiokenCheckbox.checked, maxHealth: maxHealthInput.value, kaiokenStrain: kaiokenStrainInput.value, currentHealth: currentHealthEl?.textContent || '0',
                characterName: characterNameInput?.value || '', charBaseHealth: charBaseHealthInput?.value || '',
                charBaseMultiplier: charBaseMultiplierInput?.value || '1',
                charVitality: charVitalityInput?.value || '', charSoulPower: charSoulPowerInput?.value || '', charSoulHp: charSoulHpInput?.value || '',
                charBaseAc: charBaseAcInput?.value || '10', // Save Base AC
                charBaseTr: charBaseTrInput?.value || '5',   // Save Base TR
                ryokoCheckboxState: ryokoCheckbox?.checked || false,
                ryokoEquationValue: ryokoEquationInput?.value || '',
                activeView: characterStatsScreen?.classList.contains('hidden') ? 'calculator' : 'stats',
                totalDamageDealt: totalDamageDealt, totalEnergySpent: totalEnergySpent, attackCount: attackCount, highestDamage: highestDamage,
                // Form System State
                characterForms: characterForms, // Save the array of form objects
                calculatorState: calculatorState, // Save selected forms state
            };
            ALL_ENERGY_TYPES.forEach(type => { const els = getEnergyElements(type); if (els) { state.energyPools[type] = { maxMultiplier: els.maxMultiplierEl?.value || '1', currentEnergy: els.currentEnergyEl?.textContent || '0', damagePerPower: els.damagePerPowerEl?.value || '1', regenPercent: els.regenPercentEl?.value || '' }; state.sliderPercentages[type] = els.energySlider?.value || '0'; } });
            dynamicModifiersContainer.querySelectorAll('.dynamic-box').forEach(box => { const nameInput = box.querySelector('.modifier-name-input'); const valueInput = box.querySelector('.modifier-value-input'); const typeOption = box.querySelector('.modifier-type-option.active'); if (nameInput && valueInput && typeOption) { state.dynamicModifiers.push({ name: nameInput.value, value: valueInput.value, type: typeOption.dataset.value }); } });
            return state;
        }
        function applyState(state) {
            if (!state) return;
            // Restore Character Stats
            if (characterNameInput) characterNameInput.value = state.characterName || '';
            if (charBaseHealthInput) charBaseHealthInput.value = state.charBaseHealth || '';
            if (charBaseMultiplierInput) charBaseMultiplierInput.value = state.charBaseMultiplier || '1';
            if (charVitalityInput) charVitalityInput.value = state.charVitality || '';
            if (charSoulPowerInput) charSoulPowerInput.value = state.charSoulPower || '';
            if (charSoulHpInput) charSoulHpInput.value = state.charSoulHp || '';
            if (charBaseAcInput) charBaseAcInput.value = state.charBaseAc || '10'; // Restore Base AC
            if (charBaseTrInput) charBaseTrInput.value = state.charBaseTr || '5';   // Restore Base TR

            // Restore Ryoko state
            if (ryokoCheckbox) ryokoCheckbox.checked = state.ryokoCheckboxState || false;
            if (ryokoEquationInput) ryokoEquationInput.value = state.ryokoEquationValue || '';
            handleRyokoCheckboxChange(); // Apply UI changes based on loaded Ryoko state

            // Restore Calculator Inputs
            baseDamageInput.value = state.baseDamage || ''; baseMultiplierInput.value = state.baseMultiplier || '1';
            // formMultiplierInput is readonly, its value will be set by applyActiveFormEffects
            attackCompressionPointsInput.value = state.attackCompressionPoints || '0';
            energyTypeSelect.value = state.selectedEnergyType || 'ki';

             // Restore Form Data
            characterForms = state.characterForms || []; // Load forms
            calculatorState = state.calculatorState || { selectedForms: {} }; // Load selected forms state
             // Ensure selectedForms object has keys for all energy types
            ALL_ENERGY_TYPES.forEach(type => {
                if (!calculatorState.selectedForms || typeof calculatorState.selectedForms !== 'object') {
                     calculatorState.selectedForms = {}; // Initialize if undefined or wrong type
                }
                if (!calculatorState.selectedForms[type]) {
                     calculatorState.selectedForms[type] = 'none';
                }
            });

             // Restore energy pool values AFTER character stats and forms are loaded
            if (state.energyPools) {
                 ALL_ENERGY_TYPES.forEach(type => {
                    const els = getEnergyElements(type);
                    const poolData = state.energyPools[type];
                    if (els && poolData) {
                        if(els.maxMultiplierEl) els.maxMultiplierEl.value = poolData.maxMultiplier || '1';
                        if(els.damagePerPowerEl) els.damagePerPowerEl.value = poolData.damagePerPower || '1';
                        if(els.regenPercentEl) els.regenPercentEl.value = poolData.regenPercent || '';

                        // Recalculate base/total AFTER character stats are applied
                        const baseMaxEnergy = calculateBaseMaxEnergy(type);
                        const poolMultiplier = safeParseFloat(poolData.maxMultiplier || '1', 1);
                        const charMultiplier = safeParseFloat(charBaseMultiplierInput.value, 1); // Read current char multiplier
                        const totalEnergy = baseMaxEnergy * charMultiplier * poolMultiplier;

                        if(els.baseMaxEnergyEl) els.baseMaxEnergyEl.textContent = formatStatNumber(baseMaxEnergy);
                        if(els.totalEnergyEl) els.totalEnergyEl.textContent = formatStatNumber(totalEnergy);

                        // Restore current energy, capped by the potentially recalculated total
                        if(els.currentEnergyEl) {
                            const savedCurrentNum = parseFormattedNumber(poolData.currentEnergy || '0');
                            els.currentEnergyEl.textContent = formatStatNumber(Math.min(savedCurrentNum, totalEnergy));
                        }
                    }
                 });
            }

            // Restore sliders
            if (state.sliderPercentages) { ALL_ENERGY_TYPES.forEach(type => { const els = getEnergyElements(type); if (els?.energySlider) { els.energySlider.value = state.sliderPercentages[type] || '0'; updateSingleSliderDisplay(type); } updateSliderVisibility(type); }); }

            // Restore dynamic modifiers
            dynamicModifiersContainer.innerHTML = '<h4 class="text-md font-semibold mb-2 text-gray-700">Additional Factors:</h4>'; dynamicModifierCount = 0; if (state.dynamicModifiers && Array.isArray(state.dynamicModifiers)) { state.dynamicModifiers.forEach(modData => addDynamicModifier(modData)); }

            // Restore Kaioken
            kaiokenCheckbox.checked = state.kaiokenActive || false; maxHealthInput.value = state.maxHealth || '1000'; kaiokenStrainInput.value = state.kaiokenStrain || '10'; if(currentHealthEl) { const savedHealthNum = parseFormattedNumber(state.currentHealth || '0'); currentHealthEl.textContent = formatStatNumber(savedHealthNum); }

            // Restore overall stats
            totalDamageDealt = state.totalDamageDealt || 0; totalEnergySpent = state.totalEnergySpent || 0; attackCount = state.attackCount || 0; highestDamage = state.highestDamage || 0;

            // Restore attack states
            activeAttacks = state.activeAttacks || {};
            ALL_ENERGY_TYPES.forEach(type => { updateSliderLimitAndStyle(type); });
            updateAttackButtonStates(energyTypeSelect.value);

            // Restore UI State AFTER data is loaded
            renderFormList(); // Display loaded forms
            populateFormDropdowns(); // Populate dropdowns based on loaded forms & state
            showSelectedEnergyPool(); // Show correct pool, applies form effects
            updateStatsDisplay(); // Update stats panel (includes AC/TR)
            updateEquationDisplay();

            // Restore active view
            if (state.activeView === 'stats') { showCharacterStatsView(); }
            else { showCalculatorView(); }
        }
     // *** NEW ASYNC Firebase State Functions (MODIFIED FOR AUTH) ***
        async function saveState() { 
             if (!currentUser) { // Check if user is signed in
                showMessage('You must be signed in to save state.', 'error');
                return; 
             }
             try {
                 const state = gatherState(); // Assumes gatherState is defined elsewhere
                 // Construct path using the user's unique ID
                 const userSavePath = `<span class="math-inline">\{FIREBASE\_SAVE\_PATH\_BASE\}/</span>{currentUser.uid}`; 
                 const dbRef = window.firebaseDbRef(window.firebaseDb, userSavePath); 
                 await window.firebaseDbSet(dbRef, state); 
                 showMessage('State saved successfully to Firebase!', 'success');
             } catch (error) {
                 console.error("Firebase save error:", error);
                 showMessage(`Failed to save state to Firebase. ${error.message}`, 'error');
             }
         }

        async function loadState() { 
             if (!currentUser) { // Check if user is signed in
                console.warn("Attempted to load state before user was signed in.");
                return false; // Can't load without a user
             }
             // Construct path using the user's unique ID
             const userSavePath = `<span class="math-inline">\{FIREBASE\_SAVE\_PATH\_BASE\}/</span>{currentUser.uid}`; 
             try {
                 const dbRef = window.firebaseDbRef(window.firebaseDb, userSavePath); 
                 const snapshot = await window.firebaseDbGet(dbRef); 
                 if (snapshot.exists()) {
                     const state = snapshot.val();
                     if (state) {
                         applyState(state); // Assumes applyState is defined elsewhere
                         // Message moved to onAuthStateChanged
                         return true; 
                     } else { 
                          console.warn("Firebase data node exists but is null or empty.");
                          // Message handled in onAuthStateChanged
                          return false; 
                     }
                 } else { 
                     console.log("No saved state found at Firebase path:", userSavePath);
                     // Message handled in onAuthStateChanged
                     return false; 
                 }
             } catch (error) { 
                 console.error("Error loading state from Firebase:", error);
                 showMessage(`Failed to load state from Firebase. ${error.message}`, 'error');
                 return false; 
             }
         }

        async function clearState() { 
             if (!currentUser) { // Check if user is signed in
                 showMessage('You must be signed in to clear state.', 'error');
                 return; 
             }
             if (confirm('Are you sure you want to clear your saved state FROM FIREBASE? This cannot be undone.')) {
                // Construct path using the user's unique ID
                const userSavePath = `<span class="math-inline">\{FIREBASE\_SAVE\_PATH\_BASE\}/</span>{currentUser.uid}`; 
                try {
                    const dbRef = window.firebaseDbRef(window.firebaseDb, userSavePath); 
                    await window.firebaseDbRemove(dbRef); 
                    showMessage('Saved state cleared from Firebase. Reloading.', 'success');
                    setTimeout(() => window.location.reload(), 1000); // Reload to get default state cleanly
                } catch (error) { 
                     console.error("Firebase clear error:", error);
                     showMessage(`Failed to clear state from Firebase. ${error.message}`, 'error');
                }
             }
         }
        // *** END OF REPLACEMENT STATE FUNCTIONS ***
      // *** ADDED FUNCTIONS FOR GOOGLE SIGN-IN / SIGN-OUT ***
        async function handleGoogleSignIn() {
            const provider = new window.firebaseGoogleAuthProvider(); 
            try {
                console.log("Attempting Google Sign-in...");
                const result = await window.firebaseSignInWithPopup(window.firebaseAuth, provider);
                // onAuthStateChanged will handle loading state and UI updates
                const user = result.user;
                console.log("Google Sign-in successful for:", user.displayName);
                showMessage(`Signed in as ${user.displayName || user.email}`, 'success');
            } catch (error) {
                console.error("Google Sign-in error:", error);
                showMessage(`Google Sign-in failed: ${error.message}`, 'error');
            }
        }

        async function handleSignOut() {
            try {
                await window.firebaseSignOut(window.firebaseAuth);
                console.log("Sign-out successful.");
                showMessage('Signed out successfully.', 'info');
                // onAuthStateChanged will handle UI/state reset
            } catch (error) {
                console.error("Sign-out error:", error);
                showMessage(`Sign-out failed: ${error.message}`, 'error');
            }
        }
        // *** END OF ADDED FUNCTIONS ***

        // --- Generate Elements from Templates ---
        function generateEnergySections() {
            if (!energyPoolTemplate || !energySliderTemplate || !energyPoolsContainer || !slidersGrid) {
                console.error("Required templates or containers not found! Cannot generate energy sections.");
                return;
            }
            energyPoolsContainer.innerHTML = '';
            slidersGrid.innerHTML = '';

            ALL_ENERGY_TYPES.forEach(type => {
                const details = ENERGY_TYPE_DETAILS[type];
                if (!details) return;

                // --- Generate Energy Pool Section ---
                const poolClone = energyPoolTemplate.content.cloneNode(true);
                const poolDiv = poolClone.querySelector('.energy-pool');
                if (poolDiv) {
                    poolDiv.id = `${type}-pool`;
                    poolDiv.style.display = 'none'; // Start hidden
                    poolDiv.classList.add(details.border, details.gradientTo);

                    const titleEl = poolDiv.querySelector('.pool-title');
                    if (titleEl) titleEl.textContent = `${details.name} Energy Pool`;

                    // Setup inputs/spans with unique IDs and labels
                    const setupElement = (selectorSuffix, isInput = true, focusClass = '') => {
                        const el = poolDiv.querySelector(`.${selectorSuffix}`);
                        const labelEl = poolDiv.querySelector(`.${selectorSuffix}-label`);
                        if (el) {
                            el.id = `${type}-${selectorSuffix}`;
                            if(labelEl) {
                                if(isInput) { labelEl.htmlFor = el.id; } else { labelEl.removeAttribute('for'); }
                            }
                            if (isInput && focusClass) el.classList.add(focusClass);
                        }
                    };
                    setupElement('base-max-energy', false);
                    setupElement('max-multiplier', true, details.focusRing); // Pool Max Multiplier
                    setupElement('total-energy', false);
                    setupElement('current-energy', false);
                    setupElement('damage-per-power', true, details.focusRing);
                    setupElement('regen-percent', true, details.focusRing);

                    // Setup Form Select Dropdown
                    const formSelectContainer = poolDiv.querySelector('.form-select-container');
                    const formSelect = poolDiv.querySelector('.form-select');
                    const formSelectLabel = poolDiv.querySelector('.form-select-label');
                    if (formSelect && formSelectLabel && formSelectContainer) {
                         formSelect.id = `formSelect-${type}`;
                         formSelect.dataset.energyType = type; // Link to energy type
                         formSelectLabel.htmlFor = formSelect.id;
                         formSelectLabel.textContent = `${details.name} Form:`;
                         formSelectContainer.classList.add('hidden'); // Start hidden
                    }


                    const regenBtn = poolDiv.querySelector('.regen-btn');
                    if (regenBtn) { regenBtn.dataset.type = type; }

                    energyPoolsContainer.appendChild(poolClone);
                } else {
                    console.error(`Could not find .energy-pool in template clone for ${type}`);
                }

                // --- Generate Slider Section ---
                const sliderClone = energySliderTemplate.content.cloneNode(true);
                const sliderSection = sliderClone.querySelector('.energy-slider-section');
                if (sliderSection) {
                    sliderSection.id = `${type}-slider-section`;
                    sliderSection.dataset.type = type; // Link to energy type
                    const sliderLabel = sliderSection.querySelector('.slider-label');
                    if (sliderLabel) { sliderLabel.htmlFor = `${type}-energy-slider`; sliderLabel.textContent = `${details.name} Energy Used (%):`; }
                    const energySlider = sliderSection.querySelector('.energy-slider');
                    if (energySlider) { energySlider.id = `${type}-energy-slider`; energySlider.dataset.type = type; } // Link slider too
                    const valueDisplay = sliderSection.querySelector('.energy-slider-value-display');
                    if (valueDisplay) { valueDisplay.id = `${type}-slider-value-display`; }
                    slidersGrid.appendChild(sliderClone);
                } else {
                    console.error(`Could not find .energy-slider-section in template clone for ${type}`);
                }
            });
            console.log("Energy sections generated from templates.");
        }


        // --- Equation Display Function ---
        function updateEquationDisplay() {
             if (!equationDisplayEl) return;
             let equationHTML = '';
             const op = (operator) => `<span class="equation-operator">${operator}</span>`;
             const group = (content) => `<span class="equation-group">(</span>${content}<span class="equation-group">)</span>`;
             const num = (value, targetId, title = '') => { const titleAttr = title ? ` title="${escapeHtml(title)}"` : ''; return `<span class="equation-number" data-target-id="${targetId}"${titleAttr}>${formatSimpleNumber(value)}</span>`; };

             try {
                 const baseDamage = safeParseFloat(baseDamageInput.value, 0);
                 const baseMultiplier = safeParseFloat(baseMultiplierInput.value, 1);
                 const formMultiplierVal = safeParseFloat(formMultiplierInput.value, 1); // Read main form multiplier

                 let basePart = num(baseDamage, 'base-damage', 'Base Damage');
                 if (baseMultiplier !== 1 || baseMultiplierInput.value.trim() !== '1') {
                     basePart += op('*') + num(baseMultiplier, 'base-multiplier', 'Base Multiplier');
                 }
                 // Only show form multiplier if it's not 1
                 if (formMultiplierVal !== 1 || formMultiplierInput.value.trim() !== '1') {
                     basePart += op('*') + num(formMultiplierVal, 'form-multiplier', 'Form Multiplier');
                 }

                 let baseCalculationHTML = (basePart.includes(op('*'))) ? group(basePart) : basePart;

                 const compressionPoints = safeParseFloat(attackCompressionPointsInput.value, 0);
                 if (compressionPoints > 0) {
                     let compressionMultiplierValue = Math.max(1, (compressionPoints * 1.5) + (Math.floor(compressionPoints / 10) * 3));
                     baseCalculationHTML += op('*') + `<span class="equation-number" data-target-id="attack-compression-points" title="${compressionPoints} Compression Points -> x${formatSimpleNumber(compressionMultiplierValue)} Multiplier">${formatSimpleNumber(compressionMultiplierValue)}</span>`;
                 }
                 equationHTML = baseCalculationHTML;

                 let multiplicativeTerms = [];
                 document.querySelectorAll('#dynamic-modifiers-container .dynamic-box').forEach((modifierDiv) => {
                     const valueInput = modifierDiv.querySelector('.modifier-value-input');
                     const typeOption = modifierDiv.querySelector('.modifier-type-option.active');
                     const nameInput = modifierDiv.querySelector('.modifier-name-input');
                     const modifierId = valueInput?.id;
                     const factorName = nameInput?.value.trim() || 'Unnamed Multiplier';
                     if (valueInput && typeOption && modifierId && typeOption.dataset.value === 'multiplicative') {
                         const multiplier = safeParseFloat(valueInput.value, 1);
                         if (multiplier !== 1 || valueInput.value.trim() !== '1') {
                             multiplicativeTerms.push(num(multiplier, modifierId, factorName));
                         }
                     }
                 });
                 if (multiplicativeTerms.length > 0) {
                     if (multiplicativeTerms.length > 1 || equationHTML.includes(op('*')) || equationHTML.includes(op('+'))) {
                         equationHTML = group(equationHTML);
                     }
                     equationHTML += op('*') + group(multiplicativeTerms.join(op('*')));
                 }

                 let energyTerms = [];
                 ALL_ENERGY_TYPES.forEach(type => {
                     const els = getEnergyElements(type);
                     if (els?.energySlider && els.currentEnergyEl && els.damagePerPowerEl) {
                         const sliderPercent = safeParseFloat(els.energySlider.value, 0);
                         const activeAttack = activeAttacks[type] || null;
                         let limitPercent = 100;
                         if (activeAttack === 'super') limitPercent = 95;
                         else if (activeAttack === 'ultimate') limitPercent = 90;
                         const effectivePercent = Math.min(sliderPercent, limitPercent);
                         if (effectivePercent > 0) {
                             const currentEnergy = parseFormattedNumber(els.currentEnergyEl.textContent);
                             const damagePerPower = safeParseFloat(els.damagePerPowerEl.value, 1);
                             const energyUsed = Math.min(currentEnergy * (effectivePercent / 100), currentEnergy);
                             const energyDamage = energyUsed * damagePerPower;
                             if (energyDamage !== 0) {
                                 const energyTitle = `${ENERGY_TYPE_DETAILS[type]?.name || type} Energy Used (${sliderPercent}%)`;
                                 const dppTitle = `${ENERGY_TYPE_DETAILS[type]?.name || type} Damage/Point`;
                                 energyTerms.push(group(num(energyUsed, `${type}-energy-slider`, energyTitle) + op('*') + num(damagePerPower, `${type}-damage-per-power`, dppTitle)));
                             }
                         }
                     }
                 });
                 if (energyTerms.length > 0) {
                      if (equationHTML.includes(op('*')) || equationHTML.includes(op('+'))) {
                          equationHTML = group(equationHTML);
                      }
                     equationHTML += op('+') + group(energyTerms.join(op('+')));
                 }

                 let additiveTerms = [];
                 document.querySelectorAll('#dynamic-modifiers-container .dynamic-box').forEach((modifierDiv) => {
                     const valueInput = modifierDiv.querySelector('.modifier-value-input');
                     const typeOption = modifierDiv.querySelector('.modifier-type-option.active');
                     const nameInput = modifierDiv.querySelector('.modifier-name-input');
                     const modifierId = valueInput?.id;
                     const factorName = nameInput?.value.trim() || 'Unnamed Additive';
                     if (valueInput && typeOption && modifierId && typeOption.dataset.value === 'additive') {
                         const modifierValue = safeParseFloat(valueInput.value, 0);
                         if (modifierValue !== 0 || valueInput.value.trim() !== '0') {
                             additiveTerms.push(num(modifierValue, modifierId, factorName));
                         }
                     }
                 });
                 if (additiveTerms.length > 0) {
                      if (equationHTML.includes(op('*')) || equationHTML.includes(op('+'))) {
                          equationHTML = group(equationHTML);
                      }
                     equationHTML += op('+') + group(additiveTerms.join(op('+')));
                 }

                 equationDisplayEl.innerHTML = equationHTML;
             } catch (error) {
                 console.error("Error updating equation:", error);
                 equationDisplayEl.innerHTML = '<span class="text-error-dark">Could not generate equation.</span>';
             }
        }


        // --- Click Handler for Equation Numbers ---
        function handleEquationClick(event) { const target = event.target; if (target.classList.contains('equation-number') && target.dataset.targetId) { const targetId = target.dataset.targetId; const sourceElement = document.getElementById(targetId); if (sourceElement) { sourceElement.scrollIntoView({ behavior: 'smooth', block: 'center' }); let elementToPulse = sourceElement; if (sourceElement.tagName === 'SPAN' && sourceElement.classList.contains('readonly-display')) { elementToPulse = sourceElement.closest('.energy-pool') || sourceElement; } else if (sourceElement.type === 'range') { elementToPulse = sourceElement.closest('.energy-slider-section') || sourceElement; } else if (sourceElement.classList.contains('modifier-value-input')) { elementToPulse = sourceElement.closest('.dynamic-box') || sourceElement; } triggerAnimation(elementToPulse, 'pulse-source'); if (sourceElement.tagName === 'INPUT' && !sourceElement.readOnly && sourceElement.type !== 'range') { sourceElement.focus(); } const energyTypeMatch = targetId.match(/^([a-z]+)-(damage-per-power|energy-slider|max-multiplier)/); if (energyTypeMatch) { const energyType = energyTypeMatch[1]; if (ALL_ENERGY_TYPES.includes(energyType) && energyTypeSelect.value !== energyType) { console.log(`Switching view to ${energyType} pool triggered by equation click...`); energyTypeSelect.value = energyType; showSelectedEnergyPool(); } } } else { console.warn(`Equation link target element not found: #${targetId}`); } } }
        // --- Tab Switching Logic ---
        function showCharacterStatsView() { if (mainCalculatorContent) mainCalculatorContent.classList.add('hidden'); if (characterStatsScreen) characterStatsScreen.classList.remove('hidden'); if (mainTitle) mainTitle.textContent = 'Character Stats'; if (showCharacterStatsBtn) showCharacterStatsBtn.textContent = 'Energy Calculator'; if (characterStatsScreen) triggerAnimation(characterStatsScreen, 'fadeIn'); }
        function showCalculatorView() { if (characterStatsScreen) characterStatsScreen.classList.add('hidden'); if (mainCalculatorContent) mainCalculatorContent.classList.remove('hidden'); if (mainTitle) mainTitle.textContent = 'Energy Calculator'; if (showCharacterStatsBtn) showCharacterStatsBtn.textContent = 'Character Stats'; if (mainCalculatorContent) triggerAnimation(mainCalculatorContent, 'fadeIn'); }


        // --- Event Listener Helper ---
        /** Recalculates all energy pools and updates related displays. */
        function handleStatChange() {
            // Update Base AC/TR in stats panel display immediately
            updateStatsDisplay();
            // Recalculate all energy pools as base stats affect them
            ALL_ENERGY_TYPES.forEach(type => calculateAndResetEnergy(type));
            // Re-apply form effects in case pool max changed
            applyActiveFormEffects();
            // Update equation
            updateEquationDisplay();
        }

        // --- Ryoko Mode Logic ---
        function handleRyokoCheckboxChange() { if (!ryokoCheckbox || !ryokoEquationContainer || !charBaseMultiplierInput || !ryokoEquationInput) return; const isChecked = ryokoCheckbox.checked; ryokoEquationContainer.classList.toggle('hidden', !isChecked); charBaseMultiplierInput.readOnly = isChecked; charBaseMultiplierInput.classList.toggle('bg-gray-100', isChecked); charBaseMultiplierInput.classList.toggle('cursor-not-allowed', isChecked); charBaseMultiplierInput.classList.toggle('opacity-70', isChecked); if (isChecked) { if (ryokoEquationInput.value.trim() === '') { ryokoEquationInput.value = DEFAULT_RYOKO_EQUATION; } evaluateRyokoEquation(); ryokoEquationInput.focus(); } else { ryokoEquationInput.classList.remove('border-red-500', 'focus:ring-red-500'); ryokoEquationInput.classList.add('border-gray-300', 'focus:ring-teal-focus'); } handleStatChange(); }
        function evaluateRyokoEquation() { if (!ryokoCheckbox || !ryokoCheckbox.checked || !ryokoEquationInput || !charBaseMultiplierInput) return; const expression = ryokoEquationInput.value.trim(); let result = 1; ryokoEquationInput.classList.remove('border-red-500', 'focus:ring-red-500'); ryokoEquationInput.classList.add('border-gray-300', 'focus:ring-teal-focus'); if (expression) { try { const evaluatedResult = math.evaluate(expression); if (typeof evaluatedResult === 'number' && isFinite(evaluatedResult)) { result = evaluatedResult; } else { console.error("Ryoko equation evaluated to non-finite number:", evaluatedResult); throw new Error("Invalid result (NaN or Infinity)"); } } catch (error) { console.error("Error evaluating Ryoko equation:", error); ryokoEquationInput.classList.remove('focus:ring-teal-focus'); ryokoEquationInput.classList.add('border-red-500', 'focus:ring-red-500'); showMessage(`Invalid Ryoko equation: ${error.message}`, 'error'); result = 1; } } charBaseMultiplierInput.value = formatSimpleNumber(result); handleStatChange(); }

        // --- NEW: Form System Logic ---

        /** Renders the list of saved forms in the stats panel */
        function renderFormList() {
            if (!formListContainer) return;
            formListContainer.innerHTML = ''; // Clear current list

            if (!characterForms || characterForms.length === 0) {
                formListContainer.innerHTML = '<p class="text-gray-500">No forms created yet.</p>';
                return;
            }

            // Group forms by energy type
            const formsByEnergyType = characterForms.reduce((acc, form) => {
                const type = form.energyType || 'None';
                if (!acc[type]) acc[type] = [];
                acc[type].push(form);
                return acc;
            }, {});

            const sortedEnergyTypes = Object.keys(formsByEnergyType).sort((a, b) => {
                 if (a === 'None') return 1; if (b === 'None') return -1;
                 const aIndex = ALL_ENERGY_TYPES.indexOf(a);
                 const bIndex = ALL_ENERGY_TYPES.indexOf(b);
                 if (aIndex !== -1 && bIndex !== -1) return aIndex - bIndex; // Sort by defined order
                 return a.localeCompare(b); // Alphabetical fallback
            });


            for (const type of sortedEnergyTypes) {
                const groupDiv = document.createElement('div');
                groupDiv.className = 'form-list-group'; // Add class for potential styling
                groupDiv.innerHTML = `<h4>${ENERGY_TYPE_DETAILS[type]?.name || type} Forms</h4>`;
                formListContainer.appendChild(groupDiv);

                const listDiv = document.createElement('div');
                // Use flexbox to align form name and delete button
                listDiv.className = 'flex flex-col items-start gap-0.5'; // Changed to vertical stack

                formsByEnergyType[type].forEach(form => {
                    const formItemContainer = document.createElement('div');
                    formItemContainer.className = 'flex items-center gap-1 w-full'; // Container for name + button

                    const formElement = document.createElement('span');
                    formElement.className = 'form-list-item flex-grow'; // Allow name to take space
                    formElement.textContent = form.name;
                    formElement.setAttribute('data-form-id', form.id); // Keep for potential future actions
                    formElement.title = `Form Multiplier: ${form.formMultiplier}, Pool Multiplier: ${form.poolMaxMultiplier}${form.affectsResistances ? `, AC: ${form.acBonus}, TR: ${form.trueResistanceBonus}` : ''}`;

                    const deleteButton = document.createElement('button');
                    deleteButton.textContent = '×'; // Simple 'x' for delete
                    deleteButton.className = 'delete-form-btn text-red-500 hover:text-red-700 focus:outline-none focus:ring-1 focus:ring-red-300 rounded px-1 py-0 text-xs font-bold transition-colors duration-150 active:scale-95';
                    deleteButton.title = `Delete form "${form.name}"`;
                    deleteButton.setAttribute('aria-label', `Delete form ${form.name}`);
                    deleteButton.dataset.formId = form.id; // Link button to form ID

                    formItemContainer.appendChild(formElement);
                    formItemContainer.appendChild(deleteButton);
                    listDiv.appendChild(formItemContainer); // Append the container to the list
                });
                 formListContainer.appendChild(listDiv);
            }
        }


        /** Populates all the form selection dropdowns in the energy pools */
        function populateFormDropdowns() {
            console.log("Populating form dropdowns...");
             ALL_ENERGY_TYPES.forEach(type => {
                const els = getEnergyElements(type);
                if (!els || !els.formSelect) {
                    // console.warn(`Form select dropdown not found for energy type: ${type}`);
                    return; // Skip if elements aren't ready
                }
                const select = els.formSelect;
                const currentSelection = (calculatorState.selectedForms && calculatorState.selectedForms[type]) ? calculatorState.selectedForms[type] : 'none';


                select.innerHTML = '<option value="none">None</option>'; // Reset options, keep "None"

                const formsForType = characterForms.filter(form => form.energyType === type || form.energyType === 'None'); // Include "None" type forms

                formsForType.forEach(form => {
                    const option = document.createElement('option');
                    option.value = form.id;
                    option.textContent = form.name;
                    select.appendChild(option);
                });

                select.value = currentSelection; // Restore previous selection for this type
            });
            console.log("Dropdowns populated.");
        }

        /** Applies effects of the currently selected form for the current energy type */
        function applyActiveFormEffects() {
            const currentEnergyType = energyTypeSelect.value;
            const selectedFormId = (calculatorState.selectedForms && calculatorState.selectedForms[currentEnergyType]) ? calculatorState.selectedForms[currentEnergyType] : 'none';

            let activeForm = null;
            let formAcBonus = 0;
            let formTrBonus = 0;
            let mainFormMultiplier = 1; // Default multiplier

            // Find the active form object
            if (selectedFormId !== 'none') {
                activeForm = characterForms.find(form => form.id === selectedFormId);
            }

            // Apply effects if a form is active
            if (activeForm) {
                 console.log(`Applying effects for form: ${activeForm.name} on type: ${currentEnergyType}`);
                 mainFormMultiplier = activeForm.formMultiplier;

                 // Apply Pool Max Multiplier to the *current* energy pool's input
                 const els = getEnergyElements(currentEnergyType);
                 if (els && els.maxMultiplierEl) {
                     const baseMaxPool = calculateBaseMaxEnergy(currentEnergyType); // Use the base calculation
                     // Set the initial value based on the form, user can still edit
                     els.maxMultiplierEl.value = formatSimpleNumber(activeForm.poolMaxMultiplier);
                     // Recalculate total/current energy for this pool immediately after setting multiplier
                     calculateAndResetEnergy(currentEnergyType);
                     triggerAnimation(els.maxMultiplierEl, 'pulse-source'); // Pulse the affected input
                 }

                 // Apply Resistance Bonuses (store in state for stats panel)
                 if (activeForm.affectsResistances) {
                     formAcBonus = activeForm.acBonus;
                     formTrBonus = activeForm.trueResistanceBonus;
                 }
            } else {
                 console.log(`No active form for type: ${currentEnergyType}`);
                 // If no form is active, reset the Pool Max Multiplier for the current pool to 1
                 const els = getEnergyElements(currentEnergyType);
                 if (els && els.maxMultiplierEl) {
                     els.maxMultiplierEl.value = '1';
                     // Recalculate total/current energy
                     calculateAndResetEnergy(currentEnergyType);
                 }
            }

             // Update the main (readonly) Form Multiplier input
             if (formMultiplierInput) {
                 formMultiplierInput.value = formatSimpleNumber(mainFormMultiplier);
             }

             // Store applied resistance bonuses in state for the stats display
             if (!calculatorState.appliedAcBonus) calculatorState.appliedAcBonus = 0; // Ensure exists
             if (!calculatorState.appliedTrueResistanceBonus) calculatorState.appliedTrueResistanceBonus = 0; // Ensure exists
             calculatorState.appliedAcBonus = formAcBonus;
             calculatorState.appliedTrueResistanceBonus = formTrBonus;


             // Update dependent UI (stats panel, equation)
             updateStatsDisplay(); // This will now show correct AC/TR totals
             updateEquationDisplay();
        }

        /** Handles change event on any form selection dropdown */
        function handleFormSelectChange(event) {
            const select = event.target;
            const energyType = select.dataset.energyType;
            const selectedFormId = select.value;

            if (energyType) {
                console.log(`Form selected for ${energyType}: ${selectedFormId}`);
                 // Ensure calculatorState.selectedForms exists
                 if (!calculatorState.selectedForms) {
                     calculatorState.selectedForms = {};
                 }
                calculatorState.selectedForms[energyType] = selectedFormId;

                // If the change happened for the currently viewed energy type, apply effects immediately
                if (energyType === energyTypeSelect.value) {
                    applyActiveFormEffects();
                }
                 // No need to save state on every selection, only on manual save button click
            }
        }

        // --- NEW: Add function to handle form deletion ---
        /** Handles clicks on delete buttons within the form list */
        function handleDeleteFormClick(event) {
            // Use closest to handle clicks potentially on the icon inside the button
            const deleteButton = event.target.closest('.delete-form-btn');

            if (deleteButton && deleteButton.dataset.formId) {
                const formIdToDelete = deleteButton.dataset.formId;
                const formToDelete = characterForms.find(form => form.id === formIdToDelete);

                if (!formToDelete) {
                    console.error("Could not find form to delete with ID:", formIdToDelete);
                    return;
                }

                // Confirm deletion
                if (confirm(`Are you sure you want to delete the form "${formToDelete.name}"? This cannot be undone.`)) {
                    // Find the index and remove from the main array
                    const formIndex = characterForms.findIndex(form => form.id === formIdToDelete);
                    if (formIndex > -1) {
                        characterForms.splice(formIndex, 1);
                        console.log(`Form "${formToDelete.name}" removed from characterForms.`);

                        // Check if this form was selected in any energy pool and reset if necessary
                        let formWasActive = false;
                        if (calculatorState.selectedForms) {
                            for (const energyType in calculatorState.selectedForms) {
                                if (calculatorState.selectedForms[energyType] === formIdToDelete) {
                                    calculatorState.selectedForms[energyType] = 'none';
                                    console.log(`Reset selected form for ${energyType} as deleted form was active.`);
                                    if (energyType === energyTypeSelect.value) {
                                        formWasActive = true; // Mark if it was active for the *current* view
                                    }
                                }
                            }
                        }


                        // Update UI
                        renderFormList();          // Refresh the list in the stats panel
                        populateFormDropdowns();   // Refresh dropdowns in energy pools

                        // If the deleted form was active for the currently viewed energy type,
                        // re-apply effects (which will now be 'None' or the default)
                        if (formWasActive) {
                            applyActiveFormEffects();
                        } else {
                            // Even if not active for the current view, ensure stats/equation are consistent
                            updateStatsDisplay();
                            updateEquationDisplay();
                        }


                        showMessage(`Form "${formToDelete.name}" deleted successfully.`, 'success');
                        // Note: State is not auto-saved here. User needs to click "Save State".
                    } else {
                         console.error("Form index not found after finding the form object. Inconsistency detected.");
                    }
                }
            }
        }
// --- Helper functions for initialization ---
        function initializeDefaultState() {
            console.log("Initializing default state...");
            // Reset core calculator state variables if needed
            characterForms = [];
            calculatorState = { selectedForms: {} };
            ALL_ENERGY_TYPES.forEach(type => { calculatorState.selectedForms[type] = 'none'; });
            totalDamageDealt = 0; totalEnergySpent = 0; attackCount = 0; highestDamage = 0; 
            activeAttacks = {};
            // Reset UI elements 
            if (characterNameInput) characterNameInput.value = '';
            if (charBaseHealthInput) charBaseHealthInput.value = '';
            if (charBaseMultiplierInput) charBaseMultiplierInput.value = '1';
            if (charVitalityInput) charVitalityInput.value = '';
            if (charSoulPowerInput) charSoulPowerInput.value = '';
            if (charSoulHpInput) charSoulHpInput.value = '';
            if (charBaseAcInput) charBaseAcInput.value = '10'; 
            if (charBaseTrInput) charBaseTrInput.value = '5';  
            if (ryokoCheckbox) ryokoCheckbox.checked = false;
            if (ryokoEquationInput) ryokoEquationInput.value = '';
            handleRyokoCheckboxChange(); 
            baseDamageInput.value = ''; 
            attackCompressionPointsInput.value = '0';
            energyTypeSelect.value = 'ki'; 
            dynamicModifiersContainer.innerHTML = '<h4 class="text-md font-semibold mb-2 text-gray-700">Additional Factors:</h4>'; dynamicModifierCount = 0; 
            kaiokenCheckbox.checked = false; maxHealthInput.value = '1000'; kaiokenStrainInput.value = '10'; 
             if(currentHealthEl) { currentHealthEl.textContent = maxHealthInput.value; }
            removeKaiokenStyle(); 
            // Recalculate energy based on potentially reset stats
            ALL_ENERGY_TYPES.forEach(type => { calculateAndResetEnergy(type); });
            renderFormList(); 
            populateFormDropdowns(); 
            showCalculatorView(); // Default to calculator view
            showSelectedEnergyPool(); // Show default pool (Ki)
            updateStatsDisplay(); // Update stats panel
            updateEquationDisplay();
        }

        function initializeLoadedStateUI() {
            console.log("Initializing UI based on loaded state...");
            // applyState was called within loadState, these ensure UI matches
            handleRyokoCheckboxChange(); 
            renderFormList(); 
            populateFormDropdowns(); 
             if (mainCalculatorContent?.classList.contains('hidden')) {
               showCharacterStatsView(); 
             } else {
               showCalculatorView(); 
             }
            showSelectedEnergyPool(); 
            updateStatsDisplay(); 
            updateEquationDisplay();
        }

        // --- Event Listeners Setup ---

        /** Sets up all initial event listeners for the calculator UI elements upon page load. */
        function setupEventListeners() {
            energyTypeSelect.addEventListener('change', () => { showSelectedEnergyPool(); updateEquationDisplay(); });
            calculateBtn.addEventListener('click', () => { triggerAnimation(calculateBtn, 'pulse'); performCalculation(); });
            addDynamicBoxBtn.addEventListener('click', () => { triggerAnimation(addDynamicBoxBtn, 'pulse'); addDynamicModifier(); updateEquationDisplay(); });
            [baseDamageInput, attackCompressionPointsInput, baseMultiplierInput, formMultiplierInput].forEach(input => { if(input) { input.addEventListener('input', updateEquationDisplay); input.addEventListener('change', updateEquationDisplay); } });

            // Character Stat inputs listener (including Base AC/TR)
            const characterStatInputs = [ charBaseHealthInput, charVitalityInput, charSoulPowerInput, charSoulHpInput, charBaseAcInput, charBaseTrInput ];
            characterStatInputs.forEach(input => { if (input) { input.addEventListener('input', handleStatChange); } });

            // Specific handling for Character Base Multiplier and Ryoko Mode
            if (charBaseMultiplierInput) { charBaseMultiplierInput.addEventListener('input', () => { if (!charBaseMultiplierInput.readOnly) { handleStatChange(); } }); }
            if (ryokoCheckbox) { ryokoCheckbox.addEventListener('change', handleRyokoCheckboxChange); }
            if (ryokoEquationInput) { ryokoEquationInput.addEventListener('input', evaluateRyokoEquation); ryokoEquationInput.addEventListener('change', evaluateRyokoEquation); }

            // Dynamically generated energy pool inputs and sliders
            ALL_ENERGY_TYPES.forEach(type => {
                const els = getEnergyElements(type);
                if (els) {
                    // Pool Max Multiplier input - needs recalculation on change
                    if (els.maxMultiplierEl) { els.maxMultiplierEl.addEventListener('input', () => { calculateAndResetEnergy(type); updateStatsDisplay(); updateEquationDisplay(); }); }
                    // Damage Per Power input
                    if (els.damagePerPowerEl) { els.damagePerPowerEl.addEventListener('input', () => { updateSingleSliderDisplay(type); updateEquationDisplay(); }); }
                    // Energy Slider input
                    if (els.energySlider) { els.energySlider.addEventListener('input', (event) => { const slider = event.target; const currentType = slider.dataset.type; const activeAttack = activeAttacks[currentType] || null; let limitPercent = 100; if (activeAttack === 'super') limitPercent = 95; else if (activeAttack === 'ultimate') limitPercent = 90; if (parseInt(slider.value) > limitPercent) { slider.value = limitPercent; } updateSingleSliderDisplay(currentType); updateEquationDisplay(); }); }
                    // Regen Button click
                    const regenBtn = els.poolDiv?.querySelector('.regen-btn'); if (regenBtn) { regenBtn.addEventListener('click', function() { triggerAnimation(this, 'pulse'); regenerateEnergy(this.dataset.type); }); }
                    // Form Select Dropdown change
                    if (els.formSelect) { els.formSelect.addEventListener('change', handleFormSelectChange); }

                } else { console.warn(`Could not find elements for type ${type} to attach listeners.`); }
                // *** ADD LISTENERS FOR NEW AUTH BUTTONS ***
            // Ensure elements exist before adding listeners
            const googleSignInBtn = document.getElementById('google-signin-btn');
            const signOutBtn = document.getElementById('sign-out-btn');

            if (googleSignInBtn) {
                googleSignInBtn.removeEventListener('click', handleGoogleSignIn); // Prevent duplicates if run multiple times
                googleSignInBtn.addEventListener('click', handleGoogleSignIn);
            } else {
                console.warn("Google Sign-in button not found");
            }
            if (signOutBtn) {
                signOutBtn.removeEventListener('click', handleSignOut); // Prevent duplicates
                signOutBtn.addEventListener('click', handleSignOut);
            } else {
                 console.warn("Sign out button not found");
            }
            // *** END OF NEW LISTENERS ***
            });

            // Kaioken section listeners
            if (kaiokenCheckbox) { kaiokenCheckbox.addEventListener('change', () => { const isChecked = kaiokenCheckbox.checked; kaiokenDetails.classList.toggle('hidden', !isChecked); if (isChecked) { applyKaiokenStyle(); updateCurrentHealthDisplay(); } else { removeKaiokenStyle(); } updateEquationDisplay(); }); }
            if (maxHealthInput) { maxHealthInput.addEventListener('input', () => { updateCurrentHealthDisplay(); updateEquationDisplay(); }); maxHealthInput.addEventListener('change', () => { updateCurrentHealthDisplay(); updateEquationDisplay(); }); }
            if (kaiokenStrainInput) { kaiokenStrainInput.addEventListener('input', updateEquationDisplay); }
            if (regenHealthBtn) { regenHealthBtn.addEventListener('click', () => { triggerAnimation(regenHealthBtn, 'pulse'); regenerateHealth(); }); }

            // Save/Load/Clear Button Listeners
            if (saveBtn) saveBtn.addEventListener('click', () => { triggerAnimation(saveBtn, 'pulse'); saveState(); });
            if (loadBtn) loadBtn.addEventListener('click', () => { triggerAnimation(loadBtn, 'pulse'); loadState(); });
            if (clearBtn) clearBtn.addEventListener('click', () => { triggerAnimation(clearBtn, 'pulse'); clearState(); });

            // Equation click listener
            if (equationDisplayEl) { equationDisplayEl.addEventListener('click', handleEquationClick); }

            // Reset Attack Count button listener
            if (resetAttackCountBtn) { resetAttackCountBtn.addEventListener('click', () => { triggerAnimation(resetAttackCountBtn, 'pulse'); attackCount = 0; updateStatsDisplay(); showMessage('Attack count reset.', 'info'); }); }

            // Attack Button Listeners
            if (superAttackBtn) superAttackBtn.addEventListener('click', handleAttackButtonClick);
            if (ultimateAttackBtn) ultimateAttackBtn.addEventListener('click', handleAttackButtonClick);

            // Tab Switching Button Listener
            if (showCharacterStatsBtn) { showCharacterStatsBtn.addEventListener('click', () => { triggerAnimation(showCharacterStatsBtn, 'pulse'); if (characterStatsScreen && characterStatsScreen.classList.contains('hidden')) { showCharacterStatsView(); } else { showCalculatorView(); } }); }

            // Form Creator Listeners
            if (formAffectsResistancesCheckbox) {
                formAffectsResistancesCheckbox.addEventListener('change', () => {
                     formResistanceBonusInputsDiv.classList.toggle('hidden', !formAffectsResistancesCheckbox.checked);
                    if (!formAffectsResistancesCheckbox.checked) {
                        if(formAcBonusInput) formAcBonusInput.value = 0;
                        if(formTrueResistanceBonusInput) formTrueResistanceBonusInput.value = 0;
                    }
                });
            }
            if (addFormButton) {
                addFormButton.addEventListener('click', () => {
                    triggerAnimation(addFormButton, 'pulse');
                    const formName = formNameInput.value.trim();
                    const energyType = formEnergyTypeSelect.value; // Use the correct select element
                    const affectsResistances = formAffectsResistancesCheckbox.checked;

                    if (!formName) { showMessage("Please enter a Form Name.", 'error'); return; }
                    if (characterForms.some(form => form.name === formName)) { showMessage(`A form named "${formName}" already exists.`, 'error'); return; }

                    const newForm = {
                        id: `form_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`,
                        name: formName,
                        formMultiplier: safeParseFloat(formFormMultiplierInput.value, 1),
                        poolMaxMultiplier: safeParseFloat(formPoolMaxMultiplierInput.value, 1),
                        energyType: energyType,
                        affectsResistances: affectsResistances,
                        acBonus: affectsResistances ? (safeParseFloat(formAcBonusInput.value, 0)) : 0,
                        trueResistanceBonus: affectsResistances ? (safeParseFloat(formTrueResistanceBonusInput.value, 0)) : 0,
                    };

                    characterForms.push(newForm);
                    console.log("Form Added:", newForm);
                    showMessage(`Form "${newForm.name}" added!`, 'success');

                    renderFormList(); // Update the list in the stats panel
                    populateFormDropdowns(); // Update dropdowns in energy pools

                    // Reset Form Creator fields
                    formNameInput.value = '';
                    formEnergyTypeSelect.value = 'None'; // Reset dropdown
                    formFormMultiplierInput.value = 1;
                    formPoolMaxMultiplierInput.value = 1;
                    formAffectsResistancesCheckbox.checked = false;
                    formResistanceBonusInputsDiv.classList.add('hidden');
                    formAcBonusInput.value = 0;
                    formTrueResistanceBonusInput.value = 0;
                     // No need to save state automatically, user uses Save button
                });
            }

            // --- NEW: Listener for deleting forms ---
            if (formListContainer) {
                formListContainer.addEventListener('click', handleDeleteFormClick);
            }


            console.log("Event listeners set up.");
        }
            // --- Initial Setup / Runtime Code (Now inside firebaseReady) ---
             console.log("DOM Loaded, Firebase ready. Initializing Energy Calculator v11.0 (Firebase)...");
             
             activeAttacks = {};
             ALL_ENERGY_TYPES.forEach(type => { activeAttacks[type] = null; });
             
             generateEnergySections(); // Generate HTML structure first

             // Use an async IIFE to handle awaiting loadState
             (async () => { 
                 let stateLoaded = false;
                 try {
                     // *** THIS CALL IS NOW ASYNC ***
                     stateLoaded = await loadState(); // Attempt to load state from Firebase
                 } catch (loadError) {
                     console.error("Error during initial state load:", loadError);
                     // stateLoaded remains false, will proceed to default init
                 }
     
                 // Setup event listeners AFTER trying to load state and generating sections
                 // Assumes setupEventListeners function is defined elsewhere in the firebaseReady scope
                 setupEventListeners(); 
     
                 // Initialize UI based on whether state was loaded or not
                 if (!stateLoaded) {
                      // *** This is your original default initialization logic ***
                      console.log("No valid state loaded from Firebase, initializing defaults.");
                      characterForms = [];
                      calculatorState = { selectedForms: {} };
                      ALL_ENERGY_TYPES.forEach(type => {
                          if (!calculatorState.selectedForms) calculatorState.selectedForms = {};
                          calculatorState.selectedForms[type] = 'none';
                      });
                      ALL_ENERGY_TYPES.forEach(type => { calculateAndResetEnergy(type); });
                      handleRyokoCheckboxChange(); 
                      renderFormList(); 
                      populateFormDropdowns(); 
                      showCalculatorView(); 
                      showSelectedEnergyPool(); 
                      updateStatsDisplay(); 
                      updateEquationDisplay();
                 }
                 else {
                      // *** This is your original post-load logic ***
                      console.log("Saved state loaded from Firebase.");
                      // applyState was called within loadState. Ensure UI reflects it.
                      // Re-running these might be redundant if applyState handles them, 
                      // but can ensure consistency. Test if needed.
                       if (mainCalculatorContent?.classList.contains('hidden')) {
                        showCharacterStatsView(); 
                      } else {
                        showCalculatorView(); 
                      }
                      showSelectedEnergyPool(); // Refresh currently selected pool/form effects
                      updateStatsDisplay();
                      updateEquationDisplay();
                 }
     
                 // Make the main Form Multiplier input readonly (always do this)
                 if (formMultiplierInput) {
                     formMultiplierInput.readOnly = true;
                     formMultiplierInput.classList.add('bg-gray-100', 'opacity-70', 'cursor-not-allowed');
                     formMultiplierInput.title = "This value is determined by the active form selected for the current energy type.";
                 }
     
                 console.log(`Initialization complete. ${stateLoaded ? '(State loaded from Firebase)' : '(Using default state)'}`);
                 // --- Initial Setup Trigger ---
             console.log("DOM Loaded, Firebase ready. Setting up auth listener...");
             generateEnergySections(); // Generate HTML structure first
             // The Auth Listener below handles the rest 
             // of the initialization sequence (loading state, setting up listeners, etc.)

            // --- Authentication State Change Listener ---
            // This is now the main driver for initialization after Firebase is ready
            window.firebaseOnAuthStateChanged(window.firebaseAuth, async (user) => { 
                const googleSignInBtn = document.getElementById('google-signin-btn'); // Get refs inside listener
                const signOutBtn = document.getElementById('sign-out-btn');
                const userInfoSpan = document.getElementById('user-info');

                if (user) {
                    // User is signed in.
                    currentUser = user; 
                    console.log("User signed in:", currentUser.displayName, currentUser.uid);
                    
                    // Update UI
                    if (userInfoSpan) userInfoSpan.textContent = `Signed in as: ${currentUser.displayName || currentUser.email || 'User'}`;
                    if (googleSignInBtn) googleSignInBtn.classList.add('hidden');
                    if (signOutBtn) signOutBtn.classList.remove('hidden');
                    
                    // Attempt to load state for THIS user
                    console.log("Attempting to load state for user:", currentUser.uid);
                    let stateLoaded = false;
                    try {
                        stateLoaded = await loadState(); 
                    } catch (loadError) {
                        console.error("Error during state load after sign-in:", loadError);
                    }
                    
                    // Setup event listeners (might be needed again if elements changed during applyState)
                    setupEventListeners(); 

                    // Initialize UI based on loaded state or defaults
                    if (!stateLoaded) {
                         console.log("No valid state loaded, initializing defaults for user.");
                         initializeDefaultState(); // Use helper
                    } else {
                         console.log("Saved state loaded from Firebase for user.");
                         initializeLoadedStateUI(); // Use helper
                    }
                    
                    // Ensure readonly status is correct
                    if (formMultiplierInput) {
                        formMultiplierInput.readOnly = true;
                        formMultiplierInput.classList.add('bg-gray-100', 'opacity-70', 'cursor-not-allowed');
                        formMultiplierInput.title = "This value is determined by the active form selected for the current energy type.";
                    }
                    console.log("Initialization complete for user.");

                } else {
                    // User is signed out.
                    currentUser = null;
                    console.log("User is signed out.");

                    // Update UI
                    if (userInfoSpan) userInfoSpan.textContent = 'Not signed in.';
                    if (googleSignInBtn) googleSignInBtn.classList.remove('hidden');
                    if (signOutBtn) signOutBtn.classList.add('hidden');
                    
                    // Initialize with defaults when user signs out
                    console.log("Initializing default state as user is signed out.");
                    initializeDefaultState(); 
                    
                    // Setup essential listeners even when logged out
                    setupEventListeners(); 
                     
                    // Ensure readonly status is correct
                    if (formMultiplierInput) {
                        formMultiplierInput.readOnly = true; 
                        formMultiplierInput.classList.add('bg-gray-100', 'opacity-70', 'cursor-not-allowed');
                        formMultiplierInput.title = "This value is determined by the active form selected for the current energy type.";
                     }
                }
            });
        // End onAuthStateChanged
 // --- END of firebaseReady listener ---
    });
    </script>

</body>
</html>
